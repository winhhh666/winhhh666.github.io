<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2024/01/14/vscode-zhong-shi-yong-cookie-deng-lu-leetcode/"/>
      <url>/2024/01/14/vscode-zhong-shi-yong-cookie-deng-lu-leetcode/</url>
      
        <content type="html"><![CDATA[<p>在vscode中使用cookie登录leetcode</p><p><a href="https://blog.csdn.net/zora_55/article/details/130547860">「VScode」在vscode中通过cookie登录leetcode_vscode登录leetcode-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/07/untitled/"/>
      <url>/2024/01/07/untitled/</url>
      
        <content type="html"><![CDATA[<h3 id="203链表相同元素的删除"><a href="#203链表相同元素的删除" class="headerlink" title="203链表相同元素的删除"></a>203链表相同元素的删除</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/submissions/494751055/">https://leetcode.cn/problems/remove-linked-list-elements/submissions/494751055/</a></p><p>两种思路和一个技巧</p><h3 id="141环形链表"><a href="#141环形链表" class="headerlink" title="141环形链表"></a>141环形链表</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle/description/">https://leetcode.cn/problems/linked-list-cycle/description/</a></p><p>两种思路</p><p>1.哈希</p><p>set</p><p>2.快慢指针(双指针)</p><h3 id="146LRU缓存-重要-在vue的keep-alive组件中有应用"><a href="#146LRU缓存-重要-在vue的keep-alive组件中有应用" class="headerlink" title="146LRU缓存(重要,在vue的keep-alive组件中有应用)"></a>146LRU缓存(重要,在vue的keep-alive组件中有应用)</h3><p><a href="https://leetcode.cn/problems/lru-cache/description/">https://leetcode.cn/problems/lru-cache/description/</a></p><p>Map的使用</p><pre class="line-numbers language-none"><code class="language-none">let cache = new Map()cache.set('a', 1)cache.set('b', 2)cache.set('c', 3)console.log(cache.keys().next().value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vue的缓存机制也是这样实现的</p><h3 id="136题位运算-授权-鉴权操作"><a href="#136题位运算-授权-鉴权操作" class="headerlink" title="136题位运算 授权,鉴权操作"></a>136题位运算 授权,鉴权操作</h3><p><a href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></p><p>文本  , html标签, 组件</p><p>text = 001</p><p>element = 010</p><p>component = 100</p><p>在二进制位上标记某个属性是1</p><p>let target1 = text | element 同时拥有文本 html两个属性</p><p>001  </p><p> 010</p><p>011</p><p>即用 | 进行授权</p><p>&amp;进行校验</p><p>target1 &amp; text</p><p>target1 &amp; elememt</p><p>target1 &amp; component</p><p>011 001   001证明有这个权限</p><p>2的幂次的数n,二进制中n和n-1的所有数位都不一样,可以用这个特点来判定2的幂次</p><p>异或运算^</p><p>数字不同为1</p><p>数字相同为0</p><p>位运算在前端实践中叫组合权限认证</p><p>拿虚拟DOM举例</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> <span class="token constant">STYLE</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token constant">CLASS</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">let</span> <span class="token constant">CHILDREN</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//授权</span><span class="token keyword">let</span> vnodeType <span class="token operator">=</span> <span class="token constant">STYLE</span> <span class="token operator">|</span> <span class="token constant">CLASS</span><span class="token comment">//判断 &amp;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'vnodeType的类型 STYLE'</span><span class="token punctuation">,</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>vnodeType <span class="token operator">&amp;</span> <span class="token constant">STYLE</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'vnodeType的类型 STYLE'</span><span class="token punctuation">,</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>vnodeType <span class="token operator">&amp;</span> <span class="token constant">CLASS</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'vnodeType的类型 STYLE'</span><span class="token punctuation">,</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>vnodeType <span class="token operator">&amp;</span> <span class="token constant">CHILDREN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//删除授权</span>异或运算就行vnodeType <span class="token operator">=</span> vnodeType <span class="token operator">^</span> <span class="token constant">CLASS</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a>树型结构</h3><pre class="line-numbers language-none"><code class="language-none">function TreeNode(val){this.val = val;this.left = null;this.right = null;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">fuction TreeNode(val, left, right) {this.val = (val===undefined ? 0 : val)this.left = (val===undefined ? 0 : left)this.right = (val===undefined ? 0 : right)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="104二叉树的最大深度"><a href="#104二叉树的最大深度" class="headerlink" title="104二叉树的最大深度"></a>104二叉树的最大深度</h3><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/submissions/495476312/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/submissions/495476312/</a></p><pre class="line-numbers language-none"><code class="language-none">//中止条件if(root == null)retrun 0;//二叉树最大深度等于左子树或右子树的最大值+1, 分治的思想return Math.max(maxDepth(root.left), maxDepth(root.right))+1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h3><pre class="line-numbers language-none"><code class="language-none">/** * Definition for a binary tree node. * function TreeNode(val, left, right) { *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * } *//** * @param {TreeNode} root * @return {TreeNode} */var invertTree = function(root) {    if(root == null){        return root;    }    //递归子问题,涉及到js语法解构赋值    [root.left, root.right] = [invertTree(root.right), invertTree(root.left)]    return root;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vite与webpack中用到图</p><p>moadleGraph</p><p>队列先入先出</p><p>栈先入后出  JSX template</p><p>判断一段HTML/JS/CSS的合法性</p><p>{a:1, b:2}底层:哈希表</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240114190040603.png" alt="image-20240114190040603"></p><p>查找链表中的某个值</p><p>用空间换时间的方法,构建一个跳表 再用二分查找的方法,O(logn)</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240114190940208.png" alt="image-20240114190940208"></p><h3 id="20-有效括号"><a href="#20-有效括号" class="headerlink" title="20  有效括号"></a>20  有效括号</h3><p><a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p><p>使用哈希表,栈</p><pre class="line-numbers language-none"><code class="language-none">let obj = {'(':')','[':']','{':'}'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>如果指定的属性在指定的对象或其原型链中，则 <strong><code>in</code></strong> <strong>运算符</strong>返回 <code>true</code>。</p><h3 id="71简化路径"><a href="#71简化路径" class="headerlink" title="71简化路径"></a>71简化路径</h3><p><a href="https://leetcode.cn/problems/simplify-path/">https://leetcode.cn/problems/simplify-path/</a></p><p>用栈的方式实现文件路径的简化</p><p>js中拆分字符串与合并字符串的函数</p><pre class="line-numbers language-none"><code class="language-none">.join('/')//把数组转化为字符串, 括号内是分割符,首尾没有.split('/')//将字符串分割成数组, 括号内是分隔符,如果有两个这样的分割符,就会存入空<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>内置函数</p><pre class="line-numbers language-none"><code class="language-none">arr.sort((a, b)=&gt;a-b)//升序arr.sort((a, b)=&gt;b-a)//降序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>冒泡排序</p><pre class="line-numbers language-none"><code class="language-none">function bubbleSort(arr){//每个人和右边人比较,如果比他高就交换位置,否则就不动let len = arr.length-1;for(let i=0; i&lt;len; i++){for(let j = 0; j&lt;len-i; j++){if(arr[j] &gt; arr[j+1]){//swap(arr[i], arr[i+1]);//用结构赋值的方式实现交换变量[arr[j], arr[j+1]] = [arr[j+1], arr[j]];}}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>快排</p><pre class="line-numbers language-none"><code class="language-none">时间(n*logn)空间(n*logn)function quickSort(arr){if(arr.length &lt; 2){return arr;}let flag = arr[0];let left = [];let right = [];for(let i = 1; i&lt;arr.length; i++){if(arr[i] &gt; flag){right.push(arr[i]);}  }}//原地快排[a,b,c,d,e,f,g]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/06/qian-duan-ti-xi-ke/"/>
      <url>/2024/01/06/qian-duan-ti-xi-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="前端知识体系"><a href="#前端知识体系" class="headerlink" title="前端知识体系"></a>前端知识体系</h1><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>alt+shift+上/</p><p>将某一行的元素向上/下复制一次     ////测试阿克苏京东卡</p><h1 id="01HTML"><a href="#01HTML" class="headerlink" title="01HTML"></a>01HTML</h1><p>核心：html + CSS + js</p><p>TypeScript是js的超集</p><img src="./photo/image-20240106195803605.png" alt="image-20240106195803605"><p>高屋建瓴</p><p><img src="/./photo/image-20240106204748593.png" alt="image-20240106204748593"></p><p><img src="/./photo/image-20240106204830658.png" alt="image-20240106204830658"></p><p>技术的出现是为了解决问题的，不是为了让大家学技术</p><p><img src="/./photo/image-20240107000437262.png" alt="image-20240107000437262"></p><p><a href="https://www.w3.org/TR/">W3C standards and drafts | W3C</a></p><p><a href="https://developer.mozilla.org/zh-CN/">MDN Web Docs (mozilla.org)</a></p><p><img src="/./photo/image-20240107001420771.png" alt="image-20240107001420771"></p><h2 id="HTML结构-元素-剖析"><a href="#HTML结构-元素-剖析" class="headerlink" title="HTML结构 元素 剖析"></a>HTML结构 元素 剖析</h2><h3 id="认识网页和网站"><a href="#认识网页和网站" class="headerlink" title="认识网页和网站"></a>认识网页和网站</h3><p><img src="/./photo/image-20240107005157046.png" alt="image-20240107005157046"></p><p>网址  经过DNS服务器解析（domain name system)   ip地址</p><p><img src="/./photo/image-20240107005714061.png" alt="image-20240107005714061"></p><p>网页显示过程-用户角度</p><p><img src="/./photo/image-20240107005855467.png" alt="image-20240107005855467"></p><p>网页显示-前端工程师角度</p><p>开发</p><p>打包 部署到服务器里面</p><p><img src="/./photo/image-20240107010116613.png" alt="image-20240107010116613"></p><p>服务器是什么</p><p><img src="/./photo/image-20240107010250352.png" alt="image-20240107010250352"></p><p>网页组成</p><p><img src="/./photo/image-20240107010835320.png" alt="image-20240107010835320"></p><p>html+css+js形象</p><p><img src="/./photo/image-20240107011218240.png" alt="image-20240107011218240"></p><p>检查工具位置切换</p><p>点击右上角竖着的三个点</p><ul><li>无序列表</li><li>无序列表</li><li>6</li></ul><pre class="line-numbers language-none"><code class="language-none">*加上空格<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="一-邂逅前端开发"><a href="#一-邂逅前端开发" class="headerlink" title="一.邂逅前端开发"></a>一.邂逅前端开发</h2><h3 id="1-1软件开发，软件体系开发"><a href="#1-1软件开发，软件体系开发" class="headerlink" title="1.1软件开发，软件体系开发"></a>1.1软件开发，软件体系开发</h3><h2 id="1-2完善的应用程序包括哪些"><a href="#1-2完善的应用程序包括哪些" class="headerlink" title="1.2完善的应用程序包括哪些"></a>1.2完善的应用程序包括哪些</h2><ul><li>服务器开发</li><li>iOS开发，Android开发</li><li>Web开发</li><li>桌面开发（windows ,macos)</li></ul><h3 id="1-3前端开发内容"><a href="#1-3前端开发内容" class="headerlink" title="1.3前端开发内容"></a>1.3前端开发内容</h3><ul><li>前端开发的任务：<ul><li>web开发，小程序开发</li><li>移动端,桌面端（electron,vxcode),服务器开发Node</li></ul></li><li>前端开发的路线</li></ul><h3 id="1-4学习方法"><a href="#1-4学习方法" class="headerlink" title="1.4学习方法"></a>1.4学习方法</h3><ul><li>学习任何东西了解历史，局限性，本质</li><li>知识分类：<ul><li>常用：非常熟</li><li>不常用：知道有，知道在哪查</li></ul></li></ul><h2 id="二-邂逅web开发"><a href="#二-邂逅web开发" class="headerlink" title="二.邂逅web开发"></a>二.邂逅web开发</h2><h3 id="2-1电脑配置，推荐软件"><a href="#2-1电脑配置，推荐软件" class="headerlink" title="2.1电脑配置，推荐软件"></a>2.1电脑配置，推荐软件</h3><h3 id="2-2网站和网页的关系"><a href="#2-2网站和网页的关系" class="headerlink" title="2.2网站和网页的关系"></a>2.2网站和网页的关系</h3><h3 id="2-3网页显示过程（重要）"><a href="#2-3网页显示过程（重要）" class="headerlink" title="2.3网页显示过程（重要）"></a>2.3网页显示过程（重要）</h3><ul><li>用户角度</li><li>前端工程师角度</li><li>服务器</li></ul><p>2.4 网页的组成部分</p><ul><li>HTML：网页的结构</li><li>CSS：样式美化</li><li>JS:网页交互 灵魂</li></ul><h2 id="邂逅浏览器"><a href="#邂逅浏览器" class="headerlink" title="邂逅浏览器"></a>邂逅浏览器</h2><h3 id="浏览器的作用"><a href="#浏览器的作用" class="headerlink" title="浏览器的作用"></a>浏览器的作用</h3><p>浏览器渲染html+css+js</p><p>浏览器最核心的部分：内核</p><p>即：渲染引擎（rendering Engine），一般也称为浏览器内核</p><p>负责解析网页语法，并渲染（显示）网页</p><h3 id="常见浏览器内核"><a href="#常见浏览器内核" class="headerlink" title="常见浏览器内核"></a>常见浏览器内核</h3><p><img src="/./photo/image-20240107013843627.png" alt="image-20240107013843627"></p><p>不同内核解析，渲染规则不同，所以同一网页在不同内核浏览器渲染效果也可能不同</p><h2 id="邂逅HTML"><a href="#邂逅HTML" class="headerlink" title="邂逅HTML"></a>邂逅HTML</h2><p>Hyper Text Markup Language</p><p>是标记语言不是编程语言</p><p>标签和内容组成的部分被称为元素</p><p>什么是超文本？</p><p>不仅仅可以插入普通的文本，还可以插入图片音频视频</p><p>还可以表示超链接</p><p><img src="/./photo/image-20240107015057655.png" alt="image-20240107015057655"></p><h3 id="html文件特点-扩展名（后缀"><a href="#html文件特点-扩展名（后缀" class="headerlink" title="html文件特点-扩展名（后缀"></a>html文件特点-扩展名（后缀</h3><p><img src="/./photo/image-20240107015150677.png" alt="image-20240107015150677"></p><h3 id="html文件结构特点"><a href="#html文件结构特点" class="headerlink" title="html文件结构特点"></a>html文件结构特点</h3><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/./photo/image-20240107015606326.png" alt="image-20240107015606326"></p><h3 id="VScode工具安装与工具配置"><a href="#VScode工具安装与工具配置" class="headerlink" title="VScode工具安装与工具配置"></a>VScode工具安装与工具配置</h3><p><img src="/./photo/image-20240107020243619.png" alt="image-20240107020243619"></p><p><img src="/./photo/image-20240107020956053.png" alt="image-20240107020956053"></p><h3 id="元素组成"><a href="#元素组成" class="headerlink" title="元素组成"></a>元素组成</h3><p><img src="/./photo/image-20240107103018314.png" alt="image-20240107103018314"></p><p>常见单标签</p><p>img</p><p>input</p><p>单标签 双标签</p><p>html元素是不区分大小写的，但是推荐小写</p><h3 id="元素的属性"><a href="#元素的属性" class="headerlink" title="元素的属性"></a>元素的属性</h3><p><img src="/./photo/image-20240107103445965.png" alt="image-20240107103445965"></p><p>段落</p><p>标题</p><p>超链接</p><h3 id="元素属性分类"><a href="#元素属性分类" class="headerlink" title="元素属性分类"></a>元素属性分类</h3><h4 id="公共的元素属性（每个元素都可以设置"><a href="#公共的元素属性（每个元素都可以设置" class="headerlink" title="公共的元素属性（每个元素都可以设置"></a>公共的元素属性（每个元素都可以设置</h4><pre class="line-numbers language-none"><code class="language-none">class id title<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="特有的元素属性"><a href="#特有的元素属性" class="headerlink" title="特有的元素属性"></a>特有的元素属性</h4><pre class="line-numbers language-none"><code class="language-none">meta元素的charset属性img元素的alt属性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>元结构回顾</p><p><img src="/./photo/image-20240107104258055.png" alt="image-20240107104258055"></p><h3 id="元素嵌套"><a href="#元素嵌套" class="headerlink" title="元素嵌套"></a>元素嵌套</h3><pre class="line-numbers language-none"><code class="language-none">&lt;ul&gt;&lt;/ul&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="元素间关系"><a href="#元素间关系" class="headerlink" title="元素间关系"></a>元素间关系</h3><p>父子关系</p><p>兄弟关系</p><p><img src="/./photo/image-20240107105152836.png" alt="image-20240107105152836"></p><h3 id="HTML注释"><a href="#HTML注释" class="headerlink" title="HTML注释"></a>HTML注释</h3><pre class="line-numbers language-none"><code class="language-none">&lt;!-- sa --&gt;ctrl+/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对网页进行补充</p><ul><li>html<ul><li>head<ul><li>title</li></ul></li><li>body<ul><li>h1</li><li>p</li><li>div</li><li>span</li></ul></li></ul></li></ul><h2 id="HTML-body元素和额外知识补充"><a href="#HTML-body元素和额外知识补充" class="headerlink" title="HTML body元素和额外知识补充"></a>HTML body元素和额外知识补充</h2><h3 id="HTML结构分析"><a href="#HTML结构分析" class="headerlink" title="HTML结构分析"></a>HTML结构分析</h3><p>完整html</p><p>用htm基本上是上古项目</p><pre class="line-numbers language-none"><code class="language-none">文档声明<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="文档声明"><a href="#文档声明" class="headerlink" title="文档声明"></a>文档声明</h3><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;document文档type类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/./photo/image-20240107112202877.png" alt="image-20240107112202877"></p><p><img src="/./photo/image-20240107112330541.png" alt="image-20240107112330541"></p><h3 id="html元素"><a href="#html元素" class="headerlink" title="html元素"></a>html元素</h3><p>表示文档的根（顶级元素）元素</p><p>其他元素必须是此元素的后代</p><p><img src="/./photo/image-20240107112727380.png" alt="image-20240107112727380"></p><p>其他元素必须是此元素的后代</p><p>w3c建议加入lang属性</p><p><img src="/./photo/image-20240107112734927.png" alt="image-20240107112734927"></p><p>常用</p><pre class="line-numbers language-none"><code class="language-none">lang="en"lang="zh-CN"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="head元素"><a href="#head元素" class="headerlink" title="head元素"></a>head元素</h3><p>规定文档的配置信息（元数据）</p><p>包括文档标题  引用文档样式 脚本</p><p>常见设置</p><p>标题title元素</p><p>编码：meta元素</p><p><img src="/./photo/image-20240107114208710.png" alt="image-20240107114208710"></p><p>utf-8大小写都行</p><h3 id="body元素"><a href="#body元素" class="headerlink" title="body元素"></a>body元素</h3><p>浏览器中看到的元素</p><h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><p>HTML记住常用的，其他的看文档</p><pre class="line-numbers language-none"><code class="language-none">p ， himg , a, iframediv span<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下阶段学习</p><pre class="line-numbers language-none"><code class="language-none">ul, ol, libutton inputtable thead tbody thead th tr td<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>不同标签用不同的css样式，我觉得就是一种封装</p><p>h元素通常和SEO优化有关系（什么是seo？后面讲</p><p>p元素多个段落间有一定间距</p><p><img src="/./photo/image-20240107153142010.png" alt="image-20240107153142010"></p><h3 id="img元素"><a href="#img元素" class="headerlink" title="img元素"></a>img元素</h3><p>可替换元素</p><pre class="line-numbers language-none"><code class="language-none">&lt;img src="" alt=""&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>src必须</p><p>alt属性 不强制 有两个作用</p><p><img src="/./photo/image-20240107162355704.png" alt="image-20240107162355704"></p><h3 id="src的路径"><a href="#src的路径" class="headerlink" title="src的路径"></a>src的路径</h3><p>路径分隔符是/   而不是\</p><p>img支持的图片格式很多</p><p><img src="/./photo/image-20240107170907275.png" alt="image-20240107170907275"></p><h3 id="a元素anchor"><a href="#a元素anchor" class="headerlink" title="a元素anchor"></a>a元素anchor</h3><p>锚元素</p><p>定义超链接，用于打开</p><p>两个属性</p><p>href ：Hypertext Reference</p><p>可以是网址</p><p>可以是本地的html文件路径</p><p>可以是页面定位id要加上#</p><p>target:</p><p> _blank</p><p> _self</p><p>可以在a中嵌套img</p><pre class="line-numbers language-none"><code class="language-none">&lt;a&gt;&lt;img src=""&gt;&lt;/a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="a元素——其他URL"><a href="#a元素——其他URL" class="headerlink" title="a元素——其他URL"></a>a元素——其他URL</h3><p>指向压缩包的地址</p><pre class="line-numbers language-none"><code class="language-none">&lt;a href="压缩包地址"&gt; 下载压缩包&lt;/a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指向其他协议地址</p><pre class="line-numbers language-none"><code class="language-none">&lt;a href="mailto:123@qq.com"&gt; 向123@qq.com发邮件&lt;/a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="iframe元素"><a href="#iframe元素" class="headerlink" title="iframe元素"></a>iframe元素</h3><p>在HTML文档中嵌入其他HTML文档</p><p>建议不通过属性设置样式相关的东西</p><p>微前端有些会用到</p><p>要注意有的网站不支持iframe的访问(如何禁止这样的功能？</p><p>在Network请求里</p><p>response headers</p><p>X-Frame_Options:SAMEORIGIN</p><p>可以在ngix里面添加对应的header</p><p>)</p><pre class="line-numbers language-none"><code class="language-none">&lt;iframe src="" width="" height="" frameborder=""&gt;&lt;/iframe&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="iframe属性"><a href="#iframe属性" class="headerlink" title="iframe属性"></a>iframe属性</h3><p>边框frameborder</p><p>用于规定是否显示边框</p><p>1：显示</p><p>0：不显示</p><h3 id="a元素target的其他值"><a href="#a元素target的其他值" class="headerlink" title="a元素target的其他值"></a>a元素target的其他值</h3><p>_parget:在父窗口中打开URL,如在嵌套窗口所在的页面打开</p><p>_top:顶层窗口中打开URL，到顶层打开（多次嵌套的情况</p><p>_self</p><p>_blank</p><h3 id="div元素，span元素的历史"><a href="#div元素，span元素的历史" class="headerlink" title="div元素，span元素的历史"></a>div元素，span元素的历史</h3><p><img src="/./photo/image-20240107175552698.png" alt="image-20240107175552698"></p><p>div:division,分开分配的意思</p><p>span：跨域，涵盖的意思</p><p><img src="/./photo/image-20240107180142214.png" alt="image-20240107180142214"></p><p><img src="/./photo/image-20240107180251308.png" alt="image-20240107180251308"></p><p>div和span都是纯粹的容器，也可以理解成盒子</p><p>div元素：多个div在不同行显示</p><p>作为其他元素的父容器 </p><p>span元素：多个span显示在同一行</p><p>默认情况和普通文本没区别</p><p>用于区分特殊文本和普通文本，比如显示关键字</p><h3 id="不常用的"><a href="#不常用的" class="headerlink" title="不常用的"></a>不常用的</h3><p><img src="/./photo/image-20240107200632221.png" alt="image-20240107200632221"></p><h3 id="HTML全局属性"><a href="#HTML全局属性" class="headerlink" title="HTML全局属性"></a>HTML全局属性</h3><p>某些属性只能设置在特定元素中</p><pre class="line-numbers language-none"><code class="language-none">img中的src a元素的href<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/./photo/image-20240107201333605.png" alt="image-20240107201333605"></p><p>class可以添加多个</p><pre class="line-numbers language-none"><code class="language-none">&lt;h1 class="title area why"&gt; &lt;/h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目前掌握id  class   style   title就行</p><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><h3 id="字符实体"><a href="#字符实体" class="headerlink" title="字符实体"></a>字符实体</h3><p><img src="/./photo/image-20240107203349695.png" alt="image-20240107203349695"></p><h3 id="常见字符实体"><a href="#常见字符实体" class="headerlink" title="常见字符实体"></a>常见字符实体</h3><p><img src="/./photo/image-20240107203512977.png" alt="image-20240107203512977"></p><h3 id="认识URL"><a href="#认识URL" class="headerlink" title="认识URL"></a>认识URL</h3><p>统一资源定位器</p><p>uniform Reasourse Locator</p><p><img src="/./photo/image-20240107203737442.png" alt="image-20240107203737442"></p><h3 id="URL格式"><a href="#URL格式" class="headerlink" title="URL格式"></a>URL格式</h3><p>标准格式：</p><p><code>[协议类型]://[服务器地址(ip)地址]:[端口号]/[文件路径][文件名]？[查询]#[片段ID]</code></p><p>[查询]#[片段ID]是queryString查询字符串</p><p><img src="/./photo/image-20240107204550689.png" alt="image-20240107204550689"></p><h3 id="和URI的区别"><a href="#和URI的区别" class="headerlink" title="和URI的区别"></a>和URI的区别</h3><p><img src="/./photo/image-20240107204703562.png" alt="image-20240107204703562"></p><p><img src="/./photo/image-20240107205216139.png" alt="image-20240107205216139"></p><h2 id="内容回顾"><a href="#内容回顾" class="headerlink" title="内容回顾"></a>内容回顾</h2><h3 id="文档声明-1"><a href="#文档声明-1" class="headerlink" title="文档声明"></a>文档声明</h3><p>html元素</p><p>head</p><p>元数据（配置信息</p><p> meta-》charset-&gt;utf-8</p><p>title标题</p><p>img：</p><p>alt占位属性</p><h3 id="额外知识补充"><a href="#额外知识补充" class="headerlink" title="额外知识补充"></a>额外知识补充</h3><h3 id="元素语义化"><a href="#元素语义化" class="headerlink" title="元素语义化"></a>元素语义化</h3><p>不同标签间没有本质区别，都是加上了css样式</p><p>理论上说：所有的HTML元素可以实现相同的东西</p><p>标签语义化好处</p><p><img src="/./photo/image-20240108140806038.png" alt="image-20240108140806038"></p><h3 id="什么是SEO？"><a href="#什么是SEO？" class="headerlink" title="什么是SEO？"></a>什么是SEO？</h3><p>搜索引擎优化</p><p><img src="/./photo/image-20240108141101963.png" alt="image-20240108141101963"></p><p><img src="/./photo/image-20240108145338593.png" alt="image-20240108145338593"></p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p><img src="/./photo/image-20240108150339667.png" alt="image-20240108150339667"></p><h1 id="邂逅CSS"><a href="#邂逅CSS" class="headerlink" title="邂逅CSS"></a>邂逅CSS</h1><p>层叠样式表</p><p>cascading Style Sheet</p><p>为网页添加样式</p><p><img src="/./photo/image-20240108151338417.png" alt="image-20240108151338417"></p><h3 id="CSS历史"><a href="#CSS历史" class="headerlink" title="CSS历史"></a>CSS历史</h3><p><img src="/./photo/image-20240108151909687.png" alt="image-20240108151909687"></p><p>现在分模块发布</p><p>让结构HTML与样式CSS分离</p><p><img src="/./photo/image-20240108152046676.png" alt="image-20240108152046676"></p><h3 id="CSS如何编写？"><a href="#CSS如何编写？" class="headerlink" title="CSS如何编写？"></a>CSS如何编写？</h3><p>语法规则</p><pre class="line-numbers language-none"><code class="language-none">color: red;属性   属性值声明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/./photo/image-20240108152442599.png" alt="image-20240108152442599"></p><p>提供三种方法应用css样式</p><p><img src="/./photo/image-20240108154523670.png" alt="image-20240108154523670"></p><p><img src="/./photo/image-20240108154553292.png" alt="image-20240108154553292"></p><h3 id="内联样式（inline-style"><a href="#内联样式（inline-style" class="headerlink" title="内联样式（inline style"></a>内联样式（inline style</h3><p>全局属性：global attribute</p><p>style-&gt;添加内联样式</p><p><code>&lt;div style="color&gt;内容&lt;/div&gt;"</code></p><p>存在style属性中</p><p>多个css要用分号;进行分割</p><p>最好在属性前加上空格</p><p>内联样式表存于HTML元素的style属性中</p><pre class="line-numbers language-none"><code class="language-none">&lt;div style="color: red; font-size: 20px;"&gt;我是div元素&lt;/div&gt;&lt;p style="color: white; background: blue;"&gt;&lt;/p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>建议每条css样式后面都加上分号</p><p>很多资料不推荐这种写法</p><p>1.原生html编写中写法不推荐</p><p>2.在vue的template中某些动态的样式是会使用内联样式的</p><h3 id="内部样式表（internal-style-sheet"><a href="#内部样式表（internal-style-sheet" class="headerlink" title="内部样式表（internal style sheet"></a>内部样式表（internal style sheet</h3><p>在head里面用style</p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以用标签直接作为一种选择然后添加样式</p><p>但是这样没法单独添加样式</p><p>这时候我们就用到了什么呢?</p><p>我们就用到了class</p><p>在style里面定义一个样式的名称注意前面要加.号</p><p>在vue开发过程中，每个组件也会有一个style元素，和内部样式表非常相似（原理不同</p><h3 id="外部样式表（external-style-sheet"><a href="#外部样式表（external-style-sheet" class="headerlink" title="外部样式表（external style sheet"></a>外部样式表（external style sheet</h3><p>将css编写在独立文件中，并且通过<code>&lt;link&gt;</code>元素引入进来</p><p>多个网页格式相似时候就可以这样</p><p>创建一个叫style.css的文件</p><pre class="line-numbers language-none"><code class="language-none">&lt;link rel="stylesheet" href="./css/style.css"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在head中链接上述代码</p><p>可以引入多个外部样式</p><p>但是多个link的链接引用可以在css文件夹中使用index.css当成索引</p><p>index中索引如下</p><pre class="line-numbers language-none"><code class="language-none">@import url(./style.css);@import url(./test.css);也可以使用如下格式@import "./test.css"两种实现原理不同第一个是函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/./photo/image-20240108183528183.png" alt="image-20240108183528183"></p><pre class="line-numbers language-none"><code class="language-none">&lt;link rel="stylesheet" href="./css/index.css"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="css的注释"><a href="#css的注释" class="headerlink" title="css的注释"></a>css的注释</h3><pre class="line-numbers language-none"><code class="language-none">/*这里是注释*/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">/*字体大小*/font-size: 30px;/*颜色*/color: red;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在学习阶段最好多添加注释</p><h3 id="常见的css元素"><a href="#常见的css元素" class="headerlink" title="常见的css元素"></a>常见的css元素</h3><p>最重要的是知道怎么查</p><h3 id="必须掌握的-css属性"><a href="#必须掌握的-css属性" class="headerlink" title="必须掌握的 css属性"></a>必须掌握的 css属性</h3><p>在开发中90%都是这些</p><p>w3</p><p>或MDN</p><p>兼容性支持查询</p><pre class="line-numbers language-none"><code class="language-none">https://caniuse.com/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询css属性的可用性</p><p>这个网站在后续的browserlist工具中我们再详细说明</p><h3 id="seo优化"><a href="#seo优化" class="headerlink" title="seo优化"></a>seo优化</h3><p><img src="/./photo/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%88%AC%E8%99%AB%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="搜索引擎爬虫的原理"></p><p>蛋糕</p><p>百度一下</p><p>加钱的放前面（算法决策</p><p>元素语义化</p><h3 id="目前需要掌握的CSS属性"><a href="#目前需要掌握的CSS属性" class="headerlink" title="目前需要掌握的CSS属性"></a>目前需要掌握的CSS属性</h3><pre class="line-numbers language-none"><code class="language-none">font-sizecolorbackground-colorwidthheight<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况字体16px</p><p>emmet语法简写</p><p>fz   font-size</p><p>bgc background</p><p>display属性</p><p>可以设置block独占一行</p><p>或者inline多个在一起</p><p>默认情况下宽度为一整行，但是块级元素无论宽度设置多少都会独占一行的</p><h3 id="css属性-color"><a href="#css属性-color" class="headerlink" title="css属性-color"></a>css属性-color</h3><p>设置文本前景色</p><p>包括文字，装饰线，边框，外轮廓等的颜色</p><p><strong>内容大于高度时会把高度撑起来</strong></p><p>display:inline-block</p><p>vertical-align:top</p><p>为什么会有缝隙呢？</p><p>后面讲</p><p>星球案例</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;style&gt;    .box{      width: 500px;      display: inline-block;      vertical-align: top;    }    .imgs{      width: 500px;    }    .keywords{      color: white;      background-color: chocolate;    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;星球介绍&lt;/h1&gt;  &lt;div class="box"&gt;    &lt;h3&gt;木星&lt;/h3&gt;    &lt;img class="imgs" src="./images/muxing.jpg" alt="木星"&gt;    &lt;p&gt;    &lt;span class="keywords"&gt;木星&lt;/span&gt;爱的会爱卡卡是你    &lt;/p&gt;  &lt;/div&gt;  &lt;div class="box"&gt;    &lt;h3&gt;地球&lt;/h3&gt;    &lt;img class="imgs" src="./images/diqiu.jpg" alt=""&gt;    &lt;p&gt;    &lt;span class="keywords"&gt;地球v&lt;/span&gt;毒药撒断骨的撒    &lt;/p&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="额外知识补充-1"><a href="#额外知识补充-1" class="headerlink" title="额外知识补充"></a>额外知识补充</h2><h3 id="link元素"><a href="#link元素" class="headerlink" title="link元素"></a>link元素</h3><p>外部资源链接</p><p>规范文档与外部资源的关系</p><p>link元素通常在head元素中</p><p>可以用link引用页面标题的小图标</p><p>最常用链接：样式表CSS</p><p>也可以用来创建站点图标（比如：“favicon”图标</p><p>link元素常见属性</p><p>href 指定被链接资源的URL，URL可以是绝对的也可以是相对的</p><p>rel：指定链接类型</p><p>rel链接类型查询：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes/rel">HTML 属性：rel - HTML（超文本标记语言） | MDN (mozilla.org)</a></p><p>常见链接类型</p><p>icon：站点图标</p><p>stylesheet： CSS样式</p><p>性能优化之link元素的rel属性优化</p><p>dns-prefetch</p><p>DNS域名解析服务器</p><p>域名解析成ip 根据ip地址找到对应服务器</p><p>DNS进行解析-》花时间</p><p>用dns-prefetch提前解析好</p><pre class="line-numbers language-none"><code class="language-none">&lt;link rel="dns-prefetch" href="//d.jd.com"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>pre预先提前</p><h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>二进制 0b开头binary</p><p>八进制 0o开头 Octonary  </p><p>十六进制 0x开头   hexadecimal</p><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;    console.log(90)    console.log(0b110000071)&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="css颜色表示方法"><a href="#css颜色表示方法" class="headerlink" title="css颜色表示方法"></a>css颜色表示方法</h3><p> 是不区分大小写的标识符，它表示一个具体的颜色； </p><p> 可以表示哪些颜色呢？</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value#%E8%AF%AD%E6%B3%95"> - CSS：层叠样式表 | MDN (mozilla.org)</a></p><p>太有限了</p><h3 id="RGB颜色"><a href="#RGB颜色" class="headerlink" title="RGB颜色"></a>RGB颜色</h3><p>每个原色取值范围0-255</p><pre class="line-numbers language-none"><code class="language-none">color: rgb(255, 0, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>黑是最纯的 0 0 0</p><p>白是所有达到最大的</p><h3 id="十六进制颜色"><a href="#十六进制颜色" class="headerlink" title="十六进制颜色"></a>十六进制颜色</h3><pre class="line-numbers language-none"><code class="language-none">background-color: rgb(100, 100, 100);background-color: #646464;bgc: #000000等价#000#FFFFFF等价#fff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>是rgb中的每个十进制变成十六进制拼在一起</p><p>rgba</p><p>a是指alpha 透明度</p><p><img src="/./photo/image-20240109012801161.png" alt="image-20240109012801161"></p><h3 id="Chrome浏览器开发者工具"><a href="#Chrome浏览器开发者工具" class="headerlink" title="Chrome浏览器开发者工具"></a>Chrome浏览器开发者工具</h3><p>可以在网页的特定部位右键检查可以检查特定部位</p><p>可以删除某些元素进行检查</p><p><img src="/./photo/image-20240109013614829.png" alt="image-20240109013614829"></p><p>删除某些元素</p><p>调试台左上角有个选择部分的按钮</p><p>也可以在调试台中通过改一些字体 颜色来调试</p><p><img src="/./photo/image-20240109013935527.png" alt="image-20240109013935527"></p><h3 id="理解浏览器的渲染流程"><a href="#理解浏览器的渲染流程" class="headerlink" title="理解浏览器的渲染流程"></a>理解浏览器的渲染流程</h3><p><img src="/./photo/image-20240109014614770.png" alt="image-20240109014614770"></p><p>parse解析</p><p>从上往下解析</p><p><img src="/./photo/image-20240109014850255.png" alt="image-20240109014850255"></p><p>是等待外部样式表下载完再继续解析还是边下载边解析？</p><p>边下载边解析</p><p>树形结构</p><p><img src="/./photo/image-20240109015430473.png" alt="image-20240109015430473"></p><p>css渲染完后加到上面的骨架上</p><p>最后形成一颗Render Tree</p><p>渲染树DOM tree</p><h3 id="css文本属性"><a href="#css文本属性" class="headerlink" title="css文本属性"></a>css文本属性</h3><p>text-decoration</p><p>text-transform</p><p>text-indent</p><p>text-align重要，其他了解就好</p><p>word/letter-spacing</p><h3 id="css属性text-decoraion常用"><a href="#css属性text-decoraion常用" class="headerlink" title="css属性text-decoraion常用"></a>css属性text-decoraion常用</h3><p>设置文字的装饰线</p><p>常见值</p><pre class="line-numbers language-none"><code class="language-none">none 无任何装饰线可去除a元素默认的下划线uderline 下划线overline上划线live-through中划线（删除线可以在商品促销价格打折时候使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以全局设置</p><pre class="line-numbers language-none"><code class="language-none">a{text-decoration: none;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>开发时候一般会在css文件夹中设置一个</p><p>reset.css来重置网页格式</p><h3 id="text-transform-一般"><a href="#text-transform-一般" class="headerlink" title="text-transform(一般)"></a>text-transform(一般)</h3><p>控制文本的东西的时候就基本要用到js</p><p>所以这个属性没什么必要，复杂的还是要js</p><pre class="line-numbers language-none"><code class="language-none">capitalize每个单词首字母大写uppercase  将每个单词的所有字符变为大写lowercase  每个单词所有字母小写none 无影响<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实际开发中用js转化更多</p><h3 id="text-indent"><a href="#text-indent" class="headerlink" title="text-indent"></a>text-indent</h3><p>首行缩进</p><pre class="line-numbers language-none"><code class="language-none">p{text-indent: 20px;font-size:40px;/*em相对于字体大小*/text-indent: 2em;那么font-size: 2em;又是什么呢？是相对于继承来的字体大小}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以在调试台中调试找到合适的距离再存下来去改，鼠标滚轮滚动</p><h3 id="text-align-重要"><a href="#text-align-重要" class="headerlink" title="text-align(重要)"></a>text-align(重要)</h3><p>直接翻译：文本对齐方式</p><p>MDN：定义行内内容（如文字或者图片）如何相对它的块父元素对齐</p><p>常用值</p><p>left：左对齐</p><p>right:右对齐</p><p>center：正中间显示</p><p>justify：两端对齐</p><p>图片输入框或者别的元素都可以设置格式</p><p>W3C解释</p><p>可以将所有行内级元素对齐</p><p><img src="/./photo/image-20240109113131703.png" alt="image-20240109113131703"></p><p>text-align:justify;两端对齐</p><p>文字两端对齐不留空</p><p>最后一行默认不生效，便于阅读</p><p>但是最后一行有单独的标签</p><p>text-align-last: justify;</p><h3 id="letter-spacing-word-spacing-一般"><a href="#letter-spacing-word-spacing-一般" class="headerlink" title="letter-spacing . word-spacing(一般)"></a>letter-spacing . word-spacing(一般)</h3><p>默认设置0，可以设置为复数</p><p>text-decoration:color;</p><p>前景色</p><h3 id="CSS属性-字体"><a href="#CSS属性-字体" class="headerlink" title="CSS属性-字体"></a>CSS属性-字体</h3><p>font-size</p><p><img src="/./photo/image-20240109120652393.png" alt="image-20240109120652393"></p><p>font-size</p><p>浏览器默认16px</p><p>当父元素使用em时就会继承浏览器默认的大小</p><p>子元素会默认继承父元素的字体大小</p><p>三种设置方式</p><p>px</p><p>em</p><p>百分比（移动端适配</p><p>百分比的相对属性最好去查文档，一般是相对父元素</p><h3 id="font-family-重要不过一般仅设置一次"><a href="#font-family-重要不过一般仅设置一次" class="headerlink" title="font-family(重要不过一般仅设置一次)"></a>font-family(重要不过一般仅设置一次)</h3><p>font-family用于设置文字的字体名称</p><p>可以设置一个或多个字体名称</p><p><img src="/./photo/image-20240109121946647.png" alt="image-20240109121946647"></p><p>继承属性值</p><p>子元素修改的话就要用子元素</p><p>而有些浏览器会给一些子元素默认值，覆盖掉继承的父元素属性</p><p>所以需要都设置</p><pre class="line-numbers language-none"><code class="language-none">font-family字体族多个字体间以逗号分割<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以去别人的网站找淘宝，京东等</p><p><img src="/./photo/image-20240109122914542.png" alt="image-20240109122914542"></p><p>如果在字体族中有多个单词的最好加上引号</p><p>逗号后最好加上空格</p><h3 id="font-weight重要fw"><a href="#font-weight重要fw" class="headerlink" title="font-weight重要fw"></a>font-weight重要fw</h3><p>设置文字的粗细（重量</p><p>常见取值</p><p>100|200.。。。。。|900：每个数字表示一个重量</p><p>normal：400</p><p>bold： 700</p><p>默认不设置</p><p>有些浏览器可以精准设置，有些只能粗糙设置</p><p>strong b h1-h6等标签的font-weight默认bold</p><h3 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a>font-style</h3><p>normal</p><p>italic</p><p>oblique</p><p><img src="/./photo/image-20240109124742013.png" alt="image-20240109124742013"></p><h3 id="font-variant-了解"><a href="#font-variant-了解" class="headerlink" title="font-variant(了解)"></a>font-variant(了解)</h3><p>可以将小写字母替换为缩小过的大写字母</p><p><img src="/./photo/image-20240109125001070.png" alt="image-20240109125001070"></p><h3 id="line-height（常用"><a href="#line-height（常用" class="headerlink" title="line-height（常用"></a>line-height（常用</h3><p>设置文本的行高</p><p>简单理解为一行文字占据的高度</p><p>w为啥需要行高？</p><p>方便文本阅读</p><p>行高严格定义：</p><p>两行文字基线间的间距</p><p><img src="/./photo/image-20240109125658334.png" alt="image-20240109125658334"></p><img src="./photo/image-20240109125816947.png" alt="image-20240109125816947" style="zoom:150%;"><p>文本高font-size只有顶线到底线的距离</p><p>line-height-文本高度=行距</p><h3 id="font"><a href="#font" class="headerlink" title="font"></a>font</h3><p>font是缩写属性</p><p><img src="/./photo/image-20240109132202397.png" alt="image-20240109132202397"></p><p><img src="/./photo/image-20240109132325279.png" alt="image-20240109132325279"></p><p><img src="/./photo/image-20240109132419344.png" alt="image-20240109132419344"></p><p>1.5是行高是字体高的1.5倍</p><p>阅读文档可知规则</p><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><h3 id="属性选择器-后代选择器-兄弟选择器-选择器组-伪类-选择器-伪元素"><a href="#属性选择器-后代选择器-兄弟选择器-选择器组-伪类-选择器-伪元素" class="headerlink" title="属性选择器  后代选择器  兄弟选择器  选择器组 伪类 选择器   伪元素"></a>属性选择器  后代选择器  兄弟选择器  选择器组 伪类 选择器   伪元素</h3><p>selector</p><p>开发中要找到特定的网页元素进行设置</p><p>如何找到元素？</p><p>什么是 CSS selector</p><p>选择器种类归类：</p><h3 id="通用选择器-universal-sl"><a href="#通用选择器-universal-sl" class="headerlink" title="通用选择器  universal sl"></a>通用选择器  universal sl</h3><p>通配符</p><pre class="line-numbers language-none"><code class="language-none">*{//可以统一设置样式//一般不推荐使用//浏览器不管有没有用到的元素都会进行遍历一遍消耗性能//更好是用并集选择器但是有的浏览器会进行优化}body{margin: 0px;padding}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>浏览器会默认设置样式，要改</p><h3 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h3><p>元素  type    元素名</p><p>类 class   .类名</p><p>一个class有多个值时应该用空格分割</p><p>单词之间用-  或者_链接</p><p>id   id   #id</p><p>id注意事项</p><p>在同一个HTML文档中id不要重复，应该是唯一的</p><p>id有多个单词，中间用下划线或中划线-连接，也可以驼峰</p><p>最好不要用标签名作为id值</p><p>中划线又叫连字符</p><p>css层叠，后来的覆盖前面的</p><h3 id="属性-attribute-sl"><a href="#属性-attribute-sl" class="headerlink" title="属性 attribute sl"></a>属性 attribute sl</h3><p>title</p><pre class="line-numbers language-none"><code class="language-none">[title]{}[title=div]{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/./photo/image-20240110120801903.png" alt="image-20240110120801903"></p><p>了解就行</p><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p> 解决痛点:</p><p>开发中遇到要选择一些特定的标签,用类太麻烦,用元素选择器也不行,因为不想全选中</p><p>1.所有后代</p><pre class="line-numbers language-none"><code class="language-none">.home span{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.直接子代生效</p><pre class="line-numbers language-none"><code class="language-none">.home &gt; span{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/./photo/image-20240110122242230.png" alt="image-20240110122242230"></p><h3 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h3><p>1.相邻兄弟选择器</p><p>+连接</p><pre class="line-numbers language-none"><code class="language-none">.one + div{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.普遍兄弟选择器(后面)</p><p>~连接</p><pre class="line-numbers language-none"><code class="language-none">.one ~ div{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>小程序插槽中会用到,其余开发中用到不多</p><p><img src="/./photo/image-20240110122952011.png" alt="image-20240110122952011"></p><p>组合 combinators</p><p>伪类 pseudo-classes</p><p>伪元素  pseudo-elements</p><h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><pre class="line-numbers language-none"><code class="language-none">div, p, span{font-size:30px;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="选择器组-交集选择器"><a href="#选择器组-交集选择器" class="headerlink" title="选择器组,交集选择器"></a>选择器组,交集选择器</h3><pre class="line-numbers language-none"><code class="language-none">紧挨着div.box{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="认识伪类"><a href="#认识伪类" class="headerlink" title="认识伪类"></a>认识伪类</h3><p>Pseudo 伪装的</p><p>Pseudo-classes 翻译过来是伪类</p><pre class="line-numbers language-none"><code class="language-none">:hover{}类是.box{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>伪类:状态改变的</p><p>hover悬浮状态</p><p>伪类是选择器的一种,选择特定状态的元素</p><p>pseudo</p><pre class="line-numbers language-none"><code class="language-none">div:hover{color: red;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>常见伪类</p><p>1.动态伪类</p><p>dynamic</p><p>基本上就是hover</p><p><img src="/./photo/image-20240110125731084.png" alt="image-20240110125731084"></p><pre class="line-numbers language-none"><code class="language-none">a:link 未访问的链接a:visited  已访问a:focus tab框选时用的a:hover 鼠标挪链接上a:active 激活的链接(鼠标在链接上长按住未松开)所有的状态下相同的样式a{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了a元素,:hover.:active 也能用于其他元素上</p><p>要按顺序来:</p><p>lvha</p><p>lvfha</p><p>2.目标伪类</p><p>target </p><p><img src="/./photo/image-20240110125502691.png" alt="image-20240110125502691"></p><p>用到很少</p><p>3.语言伪类</p><p>:lang(en)</p><p>4.元素状态伪类</p><p><img src="/./photo/image-20240110125745063.png" alt="image-20240110125745063"></p><p>5.结构伪类</p><p><img src="/./photo/image-20240110125754795.png" alt="image-20240110125754795"></p><p>6.否定伪类</p><p>伪类文档查找:</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes">伪类 - CSS：层叠样式表 | MDN (mozilla.org)</a></p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>可以写一个冒号或两个冒号</p><p>建议两个冒号,方便与伪类区分</p><pre class="line-numbers language-none"><code class="language-none">.box::first-line{}.box::firstletter{}.box::before{}//用于在前面后面加上元素.box::after{}.box::after{content: "cba";color:green;font-size: 20px;content: url("");position:relative;//相对定位微调方便left: px;top: px;}.box5::after{content: "";//使用伪元素的过程中不要把content省略//默认情况下伪元素是行内非替换元素display: inline-block;width:8px;height:8px;bgc: #f00;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vsc里面的换行符到浏览器中就会显示一个空格</p><p>class类选择器中添加多的类时,中间用空格分割</p><p>class=”www sss ddd”;</p><p>伪元素用法一般是创一个class并到用到的类里</p><h2 id="CSS属性的特性"><a href="#CSS属性的特性" class="headerlink" title="CSS属性的特性"></a>CSS属性的特性</h2><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>inhrited</p><p>子继承父</p><p>子有自己的先用自己的</p><p>如何知道继承性</p><p>font-size</p><p>font-family</p><p>font-weight</p><p>line-height</p><p>color</p><p>text-align</p><p>查文档</p><p>继承过来的属性是计算值不是设置值</p><h3 id="强制继承"><a href="#强制继承" class="headerlink" title="强制继承"></a>强制继承</h3><p>border不能继承</p><p>但是可强继</p><pre class="line-numbers language-none"><code class="language-none">.box{color: red;border: 2px solid purple;}.box p{border: inherit;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CSS层叠"><a href="#CSS层叠" class="headerlink" title="CSS层叠"></a>CSS层叠</h3><p>选择器权重的大的生效</p><p>权重相同时后面的生效</p><h3 id="选择器的权重"><a href="#选择器的权重" class="headerlink" title="选择器的权重"></a>选择器的权重</h3><p>方便比较优先级,设置环境</p><p><img src="/./photo/image-20240110162000107.png" alt="image-20240110162000107"></p><p><img src="/./photo/image-20240110172306126.png" alt="image-20240110172306126"></p><p><img src="/./photo/image-20240110172319420.png" alt="image-20240110172319420"></p><p><img src="/./photo/image-20240110173504592.png" alt="image-20240110173504592"></p><p>img是行内替换元素可以设置宽高</p><p>行内非替换元素不可以设置宽高</p><p>display:<br>inline-block</p><p>block</p><p>inline</p><h3 id="编写hml元素的注意事项"><a href="#编写hml元素的注意事项" class="headerlink" title="编写hml元素的注意事项"></a>编写hml元素的注意事项</h3><p>不要在p中放div</p><p>行内元素不要放块元素</p><h3 id="元素隐藏"><a href="#元素隐藏" class="headerlink" title="元素隐藏"></a>元素隐藏</h3><p>第一种</p><p>display:none;</p><p>不显示,不占位置,不占任何空间</p><p>第二种</p><p>visibility设置为hidden</p><p>元素不可见但是会占据元素应该占据的空间</p><p>默认为visible 元素是可见的</p><p>第三种</p><p>rgba</p><p>alpha,可以设置透明的,不影响子元素</p><p>rgba(255, 0, 0, .5)</p><p>用.5打包小一点</p><p>空格会被自动移除</p><p>背景色透明度设置为0时对内容没有影响</p><p>第四种</p><p>会把子元素也带上透明度</p><h3 id="CSS不生效技巧"><a href="#CSS不生效技巧" class="headerlink" title="CSS不生效技巧"></a>CSS不生效技巧</h3><p>编写css不好使</p><p>1.选择器优先级太低</p><p>2.选择器未选中对应元素(例如拼写错误)</p><p>2.css形式不对</p><p>元素不支持此css</p><p>浏览器不支持此css属性</p><p>被同类型css属性覆盖</p><p><img src="/./photo/image-20240111224043820.png" alt="image-20240111224043820"></p><p>建议:</p><p>充分利用浏览器开发者工具进行调试(增加,修改样式),查错</p><h3 id="认识盒子模型"><a href="#认识盒子模型" class="headerlink" title="认识盒子模型"></a>认识盒子模型</h3><p><img src="/./photo/image-20240111225634196.png" alt="image-20240111225634196"></p><p>html每个元素都可以看做是一个盒子</p><p>具备4个属性</p><p>content</p><p>元素内容 width/height</p><p>内边距padding</p><p>元素和内容之间的间距</p><p>边框border</p><p>元素自己的边框</p><p>外边距 margin</p><p>元素与其他元素之间的间距</p><p><img src="/./photo/image-20240111230417602.png" alt="image-20240111230417602"></p><p>盒子模型的四边</p><p>top/bottom/right/left</p><p>四个盒子分</p><p><img src="/./photo/image-20240111231418033.png" alt="image-20240111231418033"></p><p>文档里查元素的盒子属性</p><p>浏览器默认宽高auto</p><p><img src="/./photo/image-20240111233959698.png" alt="image-20240111233959698"></p><p>移动端适配设置最大宽度和最小宽度</p><p>auto默认占据整个父元素</p><h3 id="padding属性设置"><a href="#padding属性设置" class="headerlink" title="padding属性设置"></a>padding属性设置</h3><p><img src="/./photo/image-20240112001041575.png" alt="image-20240112001041575"></p><p><img src="/./photo/image-20240112001122717.png" alt="image-20240112001122717"></p><p><img src="/./photo/image-20240112001342407.png" alt="image-20240112001342407"></p><h3 id="边框border"><a href="#边框border" class="headerlink" title="边框border"></a>边框border</h3><p>相对content/padding/margin来说特殊</p><p>边框具有宽度widrh </p><p>样式style</p><p>颜色color</p><p>十二个属性</p><p>边框宽</p><p><img src="/./photo/image-20240112001722277.png" alt="image-20240112001722277"></p><p><img src="/./photo/image-20240112001756016.png" alt="image-20240112001756016"></p><p>总缩写属性</p><pre class="line-numbers language-none"><code class="language-none">boder: 10px solid red;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>边框样式</p><p><img src="/./photo/image-20240112002906868.png" alt="image-20240112002906868"></p><p><img src="/./photo/image-20240112003100715.png" alt="image-20240112003100715"></p><h3 id="外边距margin"><a href="#外边距margin" class="headerlink" title="外边距margin"></a>外边距margin</h3><p> 边框颜色、宽度、样式的编写顺序任意</p><p><img src="/./photo/image-20240112004619754.png" alt="image-20240112004619754"></p><h3 id="圆角border-radius"><a href="#圆角border-radius" class="headerlink" title="圆角border-radius"></a>圆角border-radius</h3><p>数值: 设置小圆角 npx</p><p>百分比 L设置一定的弧度或者圆形</p><p>补充</p><p><img src="/./photo/image-20240112005046207.png" alt="image-20240112005046207"></p><pre class="line-numbers language-none"><code class="language-none">.box{width:100px;height: 100px;bgc: #f00;border: 5px solid #0f0;border-radius: 50%;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h3><p>上下折叠,左右不折叠</p><p>缩写属性</p><p>顺时针</p><p><img src="/./photo/image-20240112012030330.png" alt="image-20240112012030330"></p><p>调整子元素在父元素中的页边距</p><p>第一种</p><p>父元素中用padding增加边距时会把整个页边距增大</p><p>用这种方法解决</p><pre class="line-numbers language-none"><code class="language-none">box-sizing: border-box;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二种</p><p>用子元素的margin</p><pre class="line-numbers language-none"><code class="language-none">margin-left<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种方法设置左右没有问题,设置上下有问题</p><p>父子间最好用padding设置页边距(语义化来说)</p><h3 id="margin上下传递问题"><a href="#margin上下传递问题" class="headerlink" title="margin上下传递问题"></a>margin上下传递问题</h3><p>margin左右不传递</p><p><img src="/./photo/image-20240112113350207.png" alt="image-20240112113350207"></p><p>但是在有border的情况下就不传递了</p><p>注意此时边框大小不能为0</p><p>如何防止出现传递问题</p><p>1.父元素设置padding-top/bottom</p><p>2.父元素设置border</p><p>3.触发设置BFC overflow为auto</p><p>margin一般用来设置兄弟元素间的距离</p><p>padding 父子元素间的距离</p><h3 id="上下margin的折叠"><a href="#上下margin的折叠" class="headerlink" title="上下margin的折叠"></a>上下margin的折叠</h3><p>取两个值中的较大值</p><p><img src="/./photo/image-20240112141150479.png" alt="image-20240112141150479"></p><pre class="line-numbers language-none"><code class="language-none">p, body, h1, div{box-sizing: boreder-box;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>兄弟折叠,父子折叠</p><h3 id="块级元素的居中问题"><a href="#块级元素的居中问题" class="headerlink" title="块级元素的居中问题"></a>块级元素的居中问题</h3><p>浏览器默认情况给body设置</p><pre class="line-numbers language-none"><code class="language-none">body{display: block;margin: 8px;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>text-align:center;只对行内级元素(替换,非替换)生效</p><p>块级元素 block</p><p>margin-right有默认值</p><p>设置</p><p>margin-left:auto;</p><p>margin-right:auto;</p><p>就可以让块级元素居中</p><p>联系盒子模型思考</p><p>那么子元素就用</p><p>margin:0 auto;来实现居中</p><p>真正居中就用flex布局</p><p>前面的最后都别用</p><h3 id="外轮廓outline"><a href="#外轮廓outline" class="headerlink" title="外轮廓outline"></a>外轮廓outline</h3><p>不占用空间</p><p>显示默认在border的外侧</p><p>border是占据空间的</p><p>很少用到外轮廓</p><p>行内级元素设置margin无效</p><p>默认outlin是0</p><pre class="line-numbers language-none"><code class="language-none">a{outline: none;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>某些元素的聚焦状态,或者输入框这样点中输入的</p><p><img src="/./photo/image-20240112191950942.png" alt="image-20240112191950942"></p><h3 id="盒子阴影-box-shadow"><a href="#盒子阴影-box-shadow" class="headerlink" title="盒子阴影  box-shadow"></a>盒子阴影  box-shadow</h3><p>网页中横右x轴</p><p>竖下y轴</p><pre class="line-numbers language-none"><code class="language-none">box-shadow: offset-x offset-y blur   npx color inset;模糊度 周围模糊度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/./photo/image-20240112192907037.png" alt="image-20240112192907037"></p><p>inset外框阴影变成内框阴影</p><p>阴影会叠加</p><pre class="line-numbers language-none"><code class="language-none">box-shadow: 5px 5px 10px orange, 10px 10px 10px green;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="文字阴影-text-shadow"><a href="#文字阴影-text-shadow" class="headerlink" title="文字阴影  text-shadow"></a>文字阴影  text-shadow</h3><p>文字阴影没有spread,其他和图片阴影一样</p><p>卡片阴影设置例子</p><pre class="line-numbers language-none"><code class="language-none">box-shadow: 0 5px 10px 5px rgba(0, 0, 0, .2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="行内非替换元素注意事项"><a href="#行内非替换元素注意事项" class="headerlink" title="行内非替换元素注意事项"></a>行内非替换元素注意事项</h3><p>width  height都是不生效的</p><p>内边距  上下被撑起来但是这里使用内边距是不占空间的</p><p> margin:50px   这里面的margin不生效的 </p><p>为啥不生效?</p><p>为了不破坏段落美感</p><p>1.背景色有设置到border里面 </p><p>2.前景色在border没有设置颜色的情况下,显示出来color颜色</p><p><img src="/./photo/image-20240112212819261.png" alt="image-20240112212819261"></p><h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><p>设置盒子模型中宽高的行为</p><p>content-box</p><p>padding,border都布置在width,height外面</p><p>border-box</p><p>padding border都设置在width,height里面</p><p>元素实际占用宽box width = width + padding + border</p><p>高 = height+padding+border</p><p>conent:width</p><pre class="line-numbers language-none"><code class="language-none">box-sizing: border-box;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="盒子尺寸计算"><a href="#盒子尺寸计算" class="headerlink" title="盒子尺寸计算"></a>盒子尺寸计算</h3><h3 id="ie盒子模型"><a href="#ie盒子模型" class="headerlink" title="ie盒子模型"></a>ie盒子模型</h3><p><img src="/./photo/image-20240112231803970.png" alt="image-20240112231803970"></p><h3 id="元素水平居中方案"><a href="#元素水平居中方案" class="headerlink" title="元素水平居中方案"></a>元素水平居中方案</h3><p>一些需求中, 需要元素在父元素中显示(父元素一般是块级元素,inine-block)</p><p>行内元素(包括inline-block)</p><p>父元素中设置text-align:center</p><p>块级元素</p><p>水平居中</p><p>margin: 0 auto</p><p>先整体后局部的样式调整顺序</p><h3 id="文字的垂直居中和水平居中"><a href="#文字的垂直居中和水平居中" class="headerlink" title="文字的垂直居中和水平居中"></a>文字的垂直居中和水平居中</h3><pre class="line-numbers language-none"><code class="language-none">line-height和height的大小相同实现垂直text-align实现水平<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>背景稍灰的f5f5f5</p><p>单行多出显示省略号</p><pre class="line-numbers language-none"><code class="language-none">white-space: nowrap;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>超出部分隐藏:</p><p>overflow: hidden</p><p>文本超出省略效果</p><p>text-overflow</p><p>margin左右不传递</p><p>在一行里面多的显示省略号的</p><pre class="line-numbers language-none"><code class="language-none">white-space: nowrap;overflow: hidden;text-overflow: ellipsis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>1.标准不是死的, </p><p>2.块级.行内块级(inline-block)元素可以存放任何的元素</p><p>手指点上去变成小手cursor: pointer</p><p>1.路由跳转</p><p>2.打开新链接</p><p>网站不让拿图片时,可以通过在img里添加如下属性</p><pre class="line-numbers language-none"><code class="language-none">referrerpolicy="no-referrer"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  显示多行然后省略</p><p><img src="/./photo/image-20240113163745047.png" alt="image-20240113163745047"></p><p>伪类before的使用,插入元素到指定内容的前面,如svg图标的插入</p><p>使用content:url()在伪类中插入元素</p><p>content</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/content#%E6%A6%82%E8%A6%81">概要</a></h2><p>CSS 的 <code>content</code> CSS 属性用于在元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before"><code>::before</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after"><code>::after</code></a> 伪元素中插入内容。使用 <code>content</code> 属性插入的内容都是匿名的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element"><em>可替换元素</em></a>。</p><p>设置如下属性可以微调图标</p><p>position:relative;</p><p>top: 1px;</p><p>inline-block默认width: auto;所以会有一行内无限延伸</p><p>可以将宽度变为100%</p><p>或者将a元素改为block元素,这样宽度就和父元素一样了,不会无限延伸</p><h3 id="设置背景"><a href="#设置背景" class="headerlink" title="设置背景"></a>设置背景</h3><h4 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h4><p>会盖在background-color上面</p><p>如果设置多张图片</p><p>设置的第一张图片显示在最上面,其他图片按顺序叠在下面</p><pre class="line-numbers language-none"><code class="language-none">background-image: url(), url();//默认平铺如何取消平铺?background-color: no-repeat;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a>background-repeat</h4><p>值: </p><pre class="line-numbers language-none"><code class="language-none">repeat默认可以设置只在x轴或y轴平铺repeat-x;repeat-y;no-repeat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很多背景都是由平铺得来的</p><p>如:</p><p><img src="/./photo/image-20240113212042874.png" alt="image-20240113212042874"></p><h4 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h4><p>不想平铺,设置尺寸</p><p>默认值auto显示原来大小</p><p>contain等比例放大/缩小,知道有一边接触到background-color的一边停止</p><p>cover覆盖,等比例放大/缩小,直到覆盖掉全部的bgc,多余的部分会隐藏掉</p><p>如何强行将图片塞进框里去呢?</p><p>background-size: 100% 100%;缺点:让图片变形</p><p><img src="/./photo/image-20240113213012678.png" alt="image-20240113213012678"></p><h4 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h4><pre class="line-numbers language-none"><code class="language-none">background-position: 100px 100px;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以设置负值,往左上角走</p><pre class="line-numbers language-none"><code class="language-none">right bottom;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置到右下角</p><pre class="line-numbers language-none"><code class="language-none">center center<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>居中显示</p><pre class="line-numbers language-none"><code class="language-none">top//另一个方向默认center<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/./photo/image-20240113214137518.png" alt="image-20240113214137518"></p><p>缩小浏览器时,如何让图片缩小时是缩小左右而不仅挨着一边缩小</p><p>bgp:center;</p><h4 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h4><p> 如何实现内容滚动?</p><p>在div盒子中设置溢出</p><pre class="line-numbers language-none"><code class="language-none">overflow: scroll;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>bga决定背景图像在视口内固定或者随着包含它的区块滚动</p><p>默认scorll在视口内固定</p><p>local随着包含它的区块滚动(会平铺)</p><p>fixed视口固定(相对浏览器)</p><h3 id="background背景属性的缩写属性"><a href="#background背景属性的缩写属性" class="headerlink" title="background背景属性的缩写属性"></a>background背景属性的缩写属性</h3><p>查文档</p><p>*表示零个或者多个  final至少还是要有一个的</p><p>带上问号说明可有可无的</p><p><img src="/./photo/image-20240113222224923.png" alt="image-20240113222224923"></p><p>不用记,查文档</p><h3 id="bgi和img对比"><a href="#bgi和img对比" class="headerlink" title="bgi和img对比"></a>bgi和img对比</h3><p><img src="/./photo/image-20240113224213185.png" alt="image-20240113224213185"></p><p><img src="/./photo/image-20240113224318729.png" alt="image-20240113224318729"></p><h3 id="水平居中注意事项"><a href="#水平居中注意事项" class="headerlink" title="水平居中注意事项"></a>水平居中注意事项</h3><p>text-align:center;居中要在父元素中设置,而且只对父元素中的行内级元素生效,块级元素不生效</p><p>maigin+width = contain box width</p><p>所以margin放在块级的子元素内</p><h3 id="HTML高级元素"><a href="#HTML高级元素" class="headerlink" title="HTML高级元素"></a>HTML高级元素</h3><p>列表元素</p><p>列表的实现方式</p><p>1.div</p><p>2.元素语义化 列表</p><p><img src="/./photo/image-20240114013838232.png" alt="image-20240114013838232"></p><p><img src="/./photo/image-20240114014440842.png" alt="image-20240114014440842"></p><h3 id="有序列表ol-li"><a href="#有序列表ol-li" class="headerlink" title="有序列表ol li"></a>有序列表ol li</h3><p>ol直接子元素只能是li</p><h3 id="无序列表ul-li"><a href="#无序列表ul-li" class="headerlink" title="无序列表ul  li"></a>无序列表ul  li</h3><h3 id="自定义列表dl-dt-dd"><a href="#自定义列表dl-dt-dd" class="headerlink" title="自定义列表dl  dt   dd"></a>自定义列表dl  dt   dd</h3><p>它们有自带的margin和padding 使用时要归零</p><p>  重置示例</p><pre class="line-numbers language-none"><code class="language-none">reset.cssul,li, body, p, a{margin: 0;padding: 0;}ul, li, ol{list-style: none;}a{text-decoration: none;color: #333;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//直接子代元素选择ul &gt; li &gt; a{display: inline-block;}ul &gt; li &gt; a:hover{color: #f04142;}//局部ul &gt; li .ranking{display: inline-block;width: 24px;height: 24px;margin-right: 24px;text-align: center;line-height: 24px;font-weight: 700;color: #999;}ul &gt; li .content{display: inline;}ul &gt; li .icon{position: relative;top: 2px;left: 4px;display: inline-block;width: 16px;height: 16px;background-image: url(../images/new_icon.svg);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">body{&lt;ul&gt;&lt;li class="item"&gt;&lt;a href="#"&gt;&lt;span class="ranking"&gt;1&lt;/span&gt;&lt;div class="content"&gt;哈哈哈哈哈&lt;/div&gt;&lt;i class="icon"&gt;&lt;/i&gt;//小图标设置!!!&lt;/li&gt;&lt;/ul&gt;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="position相对行为和绝对定位详解"><a href="#position相对行为和绝对定位详解" class="headerlink" title="position相对行为和绝对定位详解"></a>position相对行为和绝对定位详解</h2><p><img src="/./photo/image-20240114114053948.png" alt="image-20240114114053948"></p><h3 id="所有案例的思路"><a href="#所有案例的思路" class="headerlink" title="所有案例的思路"></a>所有案例的思路</h3><p><img src="/./photo/image-20240115150133548.png" alt="image-20240115150133548"></p><h3 id="认识表格元素"><a href="#认识表格元素" class="headerlink" title="认识表格元素"></a>认识表格元素</h3><p>排行榜也可以用表格</p><p>table<br>    tr(table row)<br>    td(table data)</p><p><img src="/./photo/image-20240115150520981.png" alt="image-20240115150520981"></p><p>table有很多属性,但是都不推荐使用了</p><p><img src="/./photo/image-20240115150644570.png" alt="image-20240115150644570"></p><p>股票类网站表格多,但是别的相对少,排行榜之类的(就算是这些也是列表居多)</p><p>对表格操作要对td操作</p><p>那么如何去除td边框间的空格呢?</p><p>在table<strong>这个父元素中操作</strong></p><pre class="line-numbers language-none"><code class="language-none">text-align: center; //居中, 可以继承border-collapse: collapse; //这样折叠就行了,合并单元格td<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如何选中列表中的行?</p><p>table tr:nth-child(n);//n是选中的第几个当前元素</p><p> 但是不够语义化</p><p> 如何语义化?</p><p>thead   tbody    tfoot</p><p>还有标题caption   (但是一般用h元素,方便调整以及SEO优化)</p><p>th表格的表头单元格</p><p><img src="/./photo/image-20240115202330027.png" alt="image-20240115202330027"></p><h3 id="单元格合并"><a href="#单元格合并" class="headerlink" title="单元格合并"></a>单元格合并</h3><p>1.跨列合并colspan</p><p>最左单元格写上colspan属性,省略合并的td</p><p>2行合并 rowspan</p><p>最上面rowspan属性</p><p>制表缩写</p><p>制表emmet语法</p><pre class="line-numbers language-none"><code class="language-none">&lt;table&gt;tr*12&gt;td{数学}*6&lt;/table&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如何选择多个结构伪类?一个一个输入很麻烦,如何简化呢?</p><pre class="line-numbers language-none"><code class="language-none">table tr:nth-child(-n+m){}//其中m代表要取到多少个的个数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用属性选择器的方法有利于制表</p><pre class="line-numbers language-none"><code class="language-none">table tr td[rowspan]{font-weight: 700;font-size: 20px;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注意属性的继承以及权重的关系"><a href="#注意属性的继承以及权重的关系" class="headerlink" title="注意属性的继承以及权重的关系"></a>注意属性的继承以及权重的关系</h3><p>后代元素自己有设置该属性,那么优先使用后代自己的属性, 不管继承过来的属性权重多高</p><p>知识模糊时,最好先写个案例,这样印象清楚</p><p>!important属性是权重最高的属性</p><p><img src="/./photo/image-20240115220801164.png" alt="image-20240115220801164"></p><p>实现这个</p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>像是搜索框,输入框之类的都是这个表单</p><p>注册,信息收集….</p><h3 id="常见表单元素"><a href="#常见表单元素" class="headerlink" title="常见表单元素"></a>常见表单元素</h3><p>form</p><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><p>行内替换元素</p><p>type属性 text  password(isShowPassword)</p><p><img src="/./photo/image-20240115231050192.png" alt="image-20240115231050192"></p><p>time data</p><p><img src="/./photo/image-20240116002555368.png" alt="image-20240116002555228"></p><p>想让input的东西独占一行   用div包裹起来(别再用br换行了)</p><p>其他属性查看文档</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>bu’er</p><p>textarea</p><p>多行文本框</p><p>select.option下拉选择框</p><p>button 按钮</p><p>label  表单元素的标题</p><h3 id="布尔属性boolean-attributes"><a href="#布尔属性boolean-attributes" class="headerlink" title="布尔属性boolean attributes"></a>布尔属性boolean attributes</h3><p>常见</p><p>disabled  checked  readonly  mulyiple autofocus  selected</p><p><img src="/./photo/image-20240116002922616.png" alt="image-20240116002922616"></p><p>其它input元素的属性type的值以及其他属性参考MDN文档</p><p>input是替换元素吗</p><p><img src="/./photo/image-20240117213335538.png" alt="image-20240117213335538"></p><h3 id="表单实现按钮"><a href="#表单实现按钮" class="headerlink" title="表单实现按钮"></a>表单实现按钮</h3><pre class="line-numbers language-none"><code class="language-none">&lt;button&gt; 我是普通按钮&lt;/button&gt;&lt;button type="reset"&gt;重置按钮&lt;/button&gt;&lt;button type="submit"&gt; 提交按钮&lt;/button&gt;&lt;!-- 用input来实现按钮的效果 --&gt;&lt;input type="button" value="我是普通按钮"&gt;&lt;input type="reset" value="这是重置按钮"&gt;&lt;input type="submit" value="提交"&gt;//提交到form的action中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列表,表单综合使用</p><p>label聚焦到输入框中</p><p>label元素与另一个元素绑定,用label来激活另一个元素</p><p>第一种 label包裹input</p><pre class="line-numbers language-none"><code class="language-none">&lt;div&gt;&lt;label for="username"&gt;用户:&lt;input id="username" type="text"&gt;&lt;/label&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种 input在label外面</p><pre class="line-numbers language-none"><code class="language-none">&lt;div&gt;&lt;label for="username"&gt;用户:&lt;/label&gt;&lt;input id="username" type="text"&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="radio的使用"><a href="#radio的使用" class="headerlink" title="radio的使用"></a>radio的使用</h3><pre class="line-numbers language-none"><code class="language-none">&lt;input type="radio"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;lable for="male"&gt;&lt;input id="male" type="radio" name="sex" value="male"&gt;男&lt;/label&gt;&lt;lable for="female"&gt;&lt;input id="female" type="radio" name="sex" value="male"&gt;女&lt;/label&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要有name属性才能互斥,name属性是传给服务器的key</p><p>还要定义一个value作为传入值</p><p>name值相同的radio才具有单选功能</p><h3 id="checkbox多选框"><a href="#checkbox多选框" class="headerlink" title="checkbox多选框"></a>checkbox多选框</h3><pre class="line-numbers language-none"><code class="language-none">&lt;form&gt;&lt;div&gt;您的爱好:&lt;label for="basketball"&gt;&lt;input type="checkbox" id="basketball" name="hobby"value="basketball"&gt;篮球&lt;/label&gt;&lt;label for="foottball"&gt;&lt;input type="checkbox" id="basketball" name="hobby"value="basketball"&gt;足球&lt;/label&gt;&lt;/div&gt;&lt;input type="submit"&gt;&lt;/form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h3><pre class="line-numbers language-none"><code class="language-none">text area常用属性:cols列数rows行数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="缩放的css设置"><a href="#缩放的css设置" class="headerlink" title="缩放的css设置"></a>缩放的css设置</h3><pre class="line-numbers language-none"><code class="language-none">禁止缩放: resize: none;水平缩放: resize: horizontal;垂直缩放: resize: vertical;水平垂直缩放: resize: both;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="select-option"><a href="#select-option" class="headerlink" title="select-option"></a>select-option</h3><p><img src="/./photo/image-20240117233214895.png" alt="image-20240117233214895"></p><p>multiple用户按ctrl可以选中多个</p><p>size设置多选框中展示出的个数</p><p>option常用属性: selected默认被选中</p><p><img src="/./photo/image-20240117233432992.png" alt="image-20240117233432992"></p><h3 id="form常见属性"><a href="#form常见属性" class="headerlink" title="form常见属性"></a>form常见属性</h3><p>action method target</p><p>提交到自己服务器的地址</p><p>这个地址填到action里面</p><p>注意form中内容的提交字段</p><p>目前的提交方式叫get请求,信息都在网址里,要么加密,要么换一种提交方式</p><p>一般密码记录的是密文</p><h3 id="请求方式的对比"><a href="#请求方式的对比" class="headerlink" title="请求方式的对比"></a>请求方式的对比</h3><p>method的两种属性 get 和post</p><p><img src="/./photo/image-20240118112616689.png" alt="image-20240118112616689"></p><p> 现在一般不用form表单单独提交了,一般用axios</p><p>模仿百度</p><pre class="line-numbers language-none"><code class="language-none">&lt;form action="www.baidu.com/s"&gt;&lt;input type="text" name="wd"&gt;&lt;button type="submit"&gt; 百度一下&lt;/button&gt;&lt;/form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们使用的也是百度了</p><h3 id="常见Emmet语法"><a href="#常见Emmet语法" class="headerlink" title="常见Emmet语法"></a>常见Emmet语法</h3><p>前身Zen Coding  禅</p><h3 id="子代和-兄弟"><a href="#子代和-兄弟" class="headerlink" title="+子代和+兄弟"></a>+子代和+兄弟</h3><p><img src="/./photo/image-20240118115039728.png" alt="image-20240118115039728"></p><h3 id="个数和-上一级"><a href="#个数和-上一级" class="headerlink" title="*个数和^上一级"></a>*个数和^上一级</h3><p>ul&gt;li*10</p><p><img src="/./photo/image-20240118115356816.png" alt="image-20240118115356816"></p><h3 id="分组元素"><a href="#分组元素" class="headerlink" title="()分组元素"></a>()分组元素</h3><h3 id="属性id-class-普通属性-内容"><a href="#属性id-class-普通属性-内容" class="headerlink" title="属性id , class ,普通属性{ }内容"></a>属性id , class ,普通属性{ }内容</h3><p>a[href=”http:siudhauhdiaus”]{百度}</p><p>ul&gt;li{内容}*10</p><p>div#main(这里#就是id属性)</p><h3 id="数字符号"><a href="#数字符号" class="headerlink" title="数字符号$"></a>数字符号$</h3><p>ul&gt;li{内容排列$}</p><p><img src="/./photo/image-20240118120127281.png" alt="image-20240118120127281"></p><p>ul&gt;li{内容排列$$$}</p><p><img src="/./photo/image-20240118120157935.png" alt="image-20240118120157935"></p><p>里面有几个$就有几个数字位</p><h3 id="隐式标签"><a href="#隐式标签" class="headerlink" title="隐式标签"></a>隐式标签</h3><p>.box  #main会直接生产一个div标签然后给里面的元素赋值</p><h3 id="CSS-Emmet"><a href="#CSS-Emmet" class="headerlink" title="CSS   Emmet"></a>CSS   Emmet</h3><p><img src="/./photo/image-20240118120602309.png" alt="image-20240118120602309"></p><h3 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h3><p>:nth-child(3){</p><p>}</p><p>:nth-of-type{</p><p>}</p><p>n的用法</p><p>前五个怎么取? :nth-child(-n+5)</p><p>后五个怎么取? </p><p>nth-last-child(-n+5)从后往前数的</p><p><img src="/./photo/image-20240118152151060.png" alt="image-20240118152151060"></p><p>需求: 选择box中的div元素, 并且是第三个子元素</p><pre class="line-numbers language-none"><code class="language-none">.box&gt;div nth-child(3){color: red;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需求: 选择box中的第三个div元素(排除所有的干扰项)</p><pre class="line-numbers language-none"><code class="language-none">.box &gt; div:nth-of-type(){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需求:选中box中的第三个子元素,无论是何种元素</p><pre class="line-numbers language-none"><code class="language-none">div :nth-child(2){      color: red;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="其他结构伪类"><a href="#其他结构伪类" class="headerlink" title="其他结构伪类"></a>其他结构伪类</h3><p>first-child</p><p>last-child</p><p>first-child</p><p>only-child唯一子元素</p><p>only-of-type</p><p><img src="/./photo/image-20240118162356397.png" alt="image-20240118162356397"></p><p>下面偶尔会使用</p><p>:root 根元素html</p><pre class="line-numbers language-none"><code class="language-none">:root{font-size: 30px;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>:empty代表里面完全空白的元素</p><pre class="line-numbers language-none"><code class="language-none">:empty{width: 100px;height: 100px;background-color: #fff;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="否定伪类"><a href="#否定伪类" class="headerlink" title="否定伪类"></a>否定伪类</h3><pre class="line-numbers language-none"><code class="language-none">.box :not(.why){color: blue;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="HTML-CSS-day08"><a href="#HTML-CSS-day08" class="headerlink" title="HTML+CSS day08"></a>HTML+CSS day08</h2><p><img src="/./photo/image-20240118214011931.png" alt="image-20240118214011931"></p><p>额外知识补充以及元素定位</p><h3 id="border图形"><a href="#border图形" class="headerlink" title="border图形"></a>border图形</h3><p>transparent:变成透明的</p><p>不设置颜色默认透明色</p><p>设置三角形</p><p>如何旋转?</p><p>transform: rotate(90deg); //旋转九十度</p><p>形变           旋转 </p><p>旋转是有轴心的,我们如何确定旋转的轴心?</p><p>transform-origin: center  25%;</p><pre class="line-numbers language-none"><code class="language-none">.box{width: 100px;height: 100px;border: 50px solid transparent;border-top-color: orange;box-sizing: border-box;transform-origin: center 25%;transform-rotate(180deg);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用border做出的图形参考网址</p><p><a href="https://css-tricks.com/the-shapes-of-css/#top-of-site">https://css-tricks.com/the-shapes-of-css/#top-of-site</a></p><h3 id="web字体"><a href="#web字体" class="headerlink" title="web字体"></a>web字体</h3><p>字体选择用font是有限的  是web-safe字体</p><p>web fonts工作原理</p><h3 id="fonts获取想要的字体"><a href="#fonts获取想要的字体" class="headerlink" title="fonts获取想要的字体"></a>fonts获取想要的字体</h3><p>在css中使用字体 html/css/js/img/fonts</p><p><img src="/./photo/image-20240118222727203.png" alt="image-20240118222727203"></p><p>网络字体的流程</p><p><img src="/./photo/image-20240118222810935.png" alt="image-20240118222810935"></p><pre class="line-numbers language-none"><code class="language-none">将浏览器引入到网页中@font-face{font-family:"why";src: url("./文件名");}.box{font-family: "why";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="web-fonts兼容性"><a href="#web-fonts兼容性" class="headerlink" title="web-fonts兼容性"></a>web-fonts兼容性</h3><p>浏览器可能不能解析某些字体的格式</p><p>所以要提供多个字体文件</p><p><img src="/./photo/image-20240118232744888.png" alt="image-20240118232744888"></p><p>X表示支持</p><p>ttf最多支持</p><p>提供一个网站来生产对应的字体文件</p><p><a href="https://font.qqe2.com/#">https://font.qqe2.com/#</a></p><p>ie不建议适配,但是一些国内浏览器使用ie内核</p><p>网络图标ttf</p><h3 id="字体兼容性写法-固定"><a href="#字体兼容性写法-固定" class="headerlink" title="字体兼容性写法(固定)"></a>字体兼容性写法(固定)</h3><p><img src="/./photo/image-20240118233344153.png" alt="image-20240118233344153"></p><p><img src="/./photo/image-20240118234130319.png" alt="image-20240118234130319"></p><p><img src="/./photo/image-20240118234506821.png" alt="image-20240118234506821"></p><p><img src="/./photo/image-20240118234542773.png" alt="image-20240118234542773"></p><p>直接把icon文件拖进来</p><p>注意复制过来的文件路径</p><p>可以在里面加上</p><p>font-style: normal;</p><p>font-weight: 400;</p><p>这样更规范</p><p>会有点浪费资源,只用一个最好</p><h3 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h3><p>好处</p><p>使用</p><p>文件导入项目</p><p><img src="/./photo/image-20240118235849900.png" alt="image-20240118235849900"></p><p>用字符实体的形式</p><p>网络字体图标代码实现过程</p><p><img src="/./photo/image-20240119001734724.png" alt="image-20240119001734724"></p><p>不用字符实体的方式</p><p>两种引入字符实体的方式</p><p>1.通过内容</p><ol start="2"><li><p>通过css伪类中的content</p><p>把字体引入放在一个css文件中然后用link引入到html,然后再在html中细化, 通常是用<code>&lt;i class=""&gt;&lt;/i&gt;</code></p></li></ol><h3 id="认识精灵图-CSS-Sprite"><a href="#认识精灵图-CSS-Sprite" class="headerlink" title="认识精灵图 CSS Sprite"></a>认识精灵图 CSS Sprite</h3><p>含义</p><p>好处</p><p>图片制作</p><p><img src="/./photo/image-20240119005149894.png" alt="image-20240119005149894"></p><p>制作网址</p><p>1.设计人员提供</p><p><a href="https://www.toptal.com.developers/css/sprit-generator">https://www.toptal.com.developers/css/sprit-generator</a></p><h3 id="网站引入图标方式"><a href="#网站引入图标方式" class="headerlink" title="网站引入图标方式:"></a>网站引入图标方式:</h3><p>img</p><p>bgi</p><p>border</p><p>字体图标</p><p>精灵图</p><p>svg</p><p>精灵图引入方式:</p><p>用背景图的方式引入精灵图,然后调整精灵图的位置</p><p>获取精灵图位置的网站</p><p><a href="http://www.spritecow.com/">www.spritecow.com</a></p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">&lt;style&gt;.box</span><span class="token punctuation">{</span>    <span class="token property">bg</span><span class="token punctuation">:</span> #333<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.topbar</span><span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>./images/topbar_sprite.png<span class="token punctuation">)</span></span><span class="token punctuation">;</span>    <span class="token property">background-repeat</span><span class="token punctuation">:</span> no-repeat<span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">i.hot-icon</span> <span class="token punctuation">{</span>   <span class="token property">bgp</span><span class="token punctuation">:</span> -192px<span class="token punctuation">,</span> 0<span class="token punctuation">;</span>   <span class="token property">width</span><span class="token punctuation">:</span> 26px<span class="token punctuation">;</span>   <span class="token property">height</span><span class="token punctuation">:</span> 13px<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token selector">i.logo-icon</span><span class="token punctuation">{</span>    <span class="token property">bgp</span><span class="token punctuation">:</span> 0 -19px<span class="token punctuation">;</span>    w26+h13<span class="token punctuation">}</span>&lt;/style&gt;&lt;div class=<span class="token string">"box"</span>&gt;&lt;i class=<span class="token string">"topbar hot-icon"</span>&gt;&lt;/i&gt;&lt;i class=<span class="token string">"topbar logo-icon"</span>&gt;&lt;/i&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引入一遍多次复用</p><h2 id="cursor"><a href="#cursor" class="headerlink" title="cursor"></a>cursor</h2><p>箭头 一般是 default</p><p> 光标 一条竖线: text</p><p>  小手 pointer</p><p>进去啥也不显示: none</p><p><img src="/./photo/image-20240119122656028.png" alt="image-20240119122656028"></p><p>默认是 auto,浏览器自己决定</p><h3 id="CSS元素定位"><a href="#CSS元素定位" class="headerlink" title="CSS元素定位"></a>CSS元素定位</h3><h4 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h4><p>normal-flow</p><p><strong>从左往右</strong>,<strong>从上往下</strong>,<strong>默认不会层叠</strong></p><p><img src="/./photo/image-20240119161558523.png" alt="image-20240119161558523"></p><h4 id="margn-padding位置调整"><a href="#margn-padding位置调整" class="headerlink" title="margn-padding位置调整"></a>margn-padding位置调整</h4><p>margin还可以设置负值</p><p><img src="/./photo/image-20240119162152024.png" alt="image-20240119162152024"></p><p>希望某个元素可以跳出标准流</p><p>可以通过position属性进行设置</p><p>默认情况下是static</p><p><img src="/./photo/image-20240119164534559.png" alt="image-20240119164534559"></p><h4 id="position属性定义下面这些值-就变成定位元素了"><a href="#position属性定义下面这些值-就变成定位元素了" class="headerlink" title="position属性定义下面这些值 ,就变成定位元素了"></a>position属性定义下面这些值 ,就变成定位元素了</h4><p>相对定位 relative</p><p>布局  定位</p><p><img src="/./photo/image-20240119164832180.png" alt="image-20240119164832180"></p><p><img src="/./photo/image-20240119165156981.png" alt="image-20240119165156981"></p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;body{margin: 0;padding: 0;}.box{height: 489px;background-color: #f00;background: url(../image/shuda.jpg) center;//设置图片,并让图片在缩放视窗时始终有居中效果}&lt;/style&gt;&lt;div class="box"&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样效果实现 ,用relative实现</p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;body{margin: 0;padding: 0;}.box{height: 489px;backgorund-color: #f00;overflow: hidden;}.box img{position: relative;//left: -960px;//图片一半transform: translate(-50%);//x轴平移/*translate中的百分比是相对于自己的*//*向右移动div的一半*/margin-left: 50%;}&lt;/style&gt;&lt;div class="box"&gt;&lt;img src="../images/mhxy.jpg" alt=""&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>元素按照normal布局</p><h4 id="固定定位-fixed"><a href="#固定定位-fixed" class="headerlink" title="固定定位 fixed"></a>固定定位 fixed</h4><p>脱离normal flow</p><p>定位  lrtb</p><p>参考对象: 视口(viewport)</p><p>画布滚动时,固定不动</p><img src="./photo/image-20240119181446463.png" alt="image-20240119181446463"><h3 id="视口viewport与画布canvas区别"><a href="#视口viewport与画布canvas区别" class="headerlink" title="视口viewport与画布canvas区别"></a>视口viewport与画布canvas区别</h3><img src="./photo/image-20240119181949983.png" alt="image-20240119181949983"><p>画布&gt;=视口</p><p>绝对定位 absolute</p><p>粘性定位 sticky</p><p>z-index</p><h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h3 id="邂逅JavaScript"><a href="#邂逅JavaScript" class="headerlink" title="邂逅JavaScript"></a>邂逅JavaScript</h3><p> 编程语言特点</p><p><img src="/./photo/image-20240110225125924.png" alt="image-20240110225125924"></p><p>机器语言</p><p><img src="/./photo/image-20240111000704781.png" alt="image-20240111000704781"></p><p>汇编语言</p><p><img src="/./photo/image-20240111000823961.png" alt="image-20240111000823961"></p><p>高级语言</p><p><img src="/./photo/image-20240111000948199.png" alt="image-20240111000948199"></p><p>可移植<img src="/./photo/image-20240111001248443.png" alt="image-20240111001248443"></p><h3 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h3><p><img src="/./photo/image-20240111003436704.png" alt="image-20240111003436704"></p><p><img src="/./photo/image-20240111002339083.png" alt="image-20240111002339083"></p><p><img src="/./photo/image-20240111003801744.png" alt="image-20240111003801744"></p><p><img src="/./photo/image-20240111004042041.png" alt="image-20240111004042041"></p><p>js在浏览器或者node上运行</p><p><img src="/./photo/image-20240111004633817.png" alt="image-20240111004633817"></p><p><img src="/./photo/image-20240111004745573.png" alt="image-20240111004745573"></p><h3 id="浏览器内核与JS引擎的关系"><a href="#浏览器内核与JS引擎的关系" class="headerlink" title="浏览器内核与JS引擎的关系"></a>浏览器内核与JS引擎的关系</h3><p><img src="/./photo/image-20240111004825161.png" alt="image-20240111004825161"></p><p><img src="/./photo/image-20240111004920445.png" alt="image-20240111004920445"></p><h3 id="Atwood定律"><a href="#Atwood定律" class="headerlink" title="Atwood定律"></a>Atwood定律</h3><p><img src="/./photo/image-20240111005030418.png" alt="image-20240111005030418"></p><p>JS应用场景</p><p><img src="/./photo/image-20240111005153521.png" alt="image-20240111005153521"></p><h3 id="JS编写方式"><a href="#JS编写方式" class="headerlink" title="JS编写方式"></a>JS编写方式</h3><p>1.编写在html内部</p><p>不推荐</p><pre class="line-numbers language-none"><code class="language-none">&lt;a href="javascript: alert('百度一下')" onclick="alert('百度一下')"&gt;百度&lt;/a&gt;或&lt;a href="javascript: alert('百度一下')"&gt;百度&lt;/a&gt;或&lt;a href="#" onclick="alert('百度')"&gt;百度&lt;/a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.script元素内</p><pre class="line-numbers language-none"><code class="language-none">&lt;a class="google" href="#"&gt;Google&lt;/a&gt;&lt;script&gt;const googleAE1 = document.querySelector(".google")googleAE1.onclick = function() {alert("Google一下")}&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.独立的js文件</p><pre class="line-numbers language-none"><code class="language-none">google.js文件内const googleAE1 = document.querySelector(".google")googleAE1.onclick = function() {alert("Google一下")}通过script里面的src引入文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">index.html文件内&lt;a class="google" href="#"&gt;Google&lt;/a&gt;&lt;script src="./js/bing.js"&gt; &lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="元素"><a href="#元素" class="headerlink" title="<noscript>元素"></a><code>&lt;noscript&gt;</code>元素</h3><p>浏览器不支持js时候显示</p><p>就是一个标签</p><p>优雅降级的处理方案</p><p><img src="/./photo/image-20240111015015934.png" alt="image-20240111015015934"></p><p>编写注意事项</p><p>一</p><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>script引入文件时中间不包裹东西时后面的标签也不能省略</p><p>script引入文件时,中间不能包裹任何别的东西(因为不会执行)</p><p>script中还有其他属性</p><p><img src="/./photo/image-20240111015630716.png" alt="image-20240111015630716"></p><p>三   JS加载顺序</p><p>自上而下加载</p><p>要注意选择器</p><p>一般放在body的最后(推荐)</p><p>或body外(后面)</p><p>或html外面也行(不推荐)</p><p>四    JS代码严格区分大小写</p><p>HTML与CSS属性不区分大小写,但是在JS中严格区分大小写</p><p>script元素还有feder,async属性,后续详细讲</p><h3 id="JS交互方式"><a href="#JS交互方式" class="headerlink" title="JS交互方式"></a>JS交互方式</h3><p>alert弹窗</p><pre class="line-numbers language-none"><code class="language-none">alert 接受一参数  弹窗查看console.log 接受多参数  浏览器控制台查看document.write 接受多字符串 浏览器页面查看prompt 接受一个参数 浏览器接受用户输入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/./photo/image-20240111021419979.png" alt="image-20240111021419979"></p><p>prompt有返回值</p><pre class="line-numbers language-none"><code class="language-none">var result = prompt()alert("刚才输入的内容是:" + result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Chrome调试工具"><a href="#Chrome调试工具" class="headerlink" title="Chrome调试工具"></a>Chrome调试工具</h3><p><img src="/./photo/image-20240111021850780.png" alt="image-20240111021850780"></p><p>代码报错也可以在console中查看</p><p>补充:</p><p><img src="/./photo/image-20240111022108291.png" alt="image-20240111022108291"></p><h3 id="JS语句和分号"><a href="#JS语句和分号" class="headerlink" title="JS语句和分号"></a>JS语句和分号</h3><p><img src="/./photo/image-20240111022420252.png" alt="image-20240111022420252"></p><p><img src="/./photo/image-20240111022505741.png" alt="image-20240111022505741"></p><p>JS注释</p><pre class="line-numbers language-none"><code class="language-none">//单行注释/*多行注释*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">文档注释要在单独的JS文件中编写才有效/** *和某人打招呼的函数 *@param {string} name 姓名 *@param {number} age 年龄 */  function sayHello(name, age) {  }  sayHello("why", 18);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/./photo/image-20240111023220810.png" alt="image-20240111023220810"></p><p>JS不支持注释的嵌套</p><p>console的快速编写</p><p>直接写</p><p>log+enter</p><p>或者用react插件+clg</p><p>设置明确大括号的插件</p><h3 id="设计一个新闻热度排行"><a href="#设计一个新闻热度排行" class="headerlink" title="设计一个新闻热度排行"></a>设计一个新闻热度排行</h3><p>用结构伪类实现前几名不同的颜色</p><p>注意继承问题</p><p>但是要注意权重的划分,不然会不生效</p><p>所以要注意选择的对象</p><p>伪类</p><pre class="line-numbers language-none"><code class="language-none">ul &gt; li:nth-child(1) .ranking{color: #f00;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一样的代码要抽取出来</p><h3 id="如何系统实现一个效果"><a href="#如何系统实现一个效果" class="headerlink" title="如何系统实现一个效果"></a>如何系统实现一个效果</h3><p>1.先完成结构</p><p>2.重置样式</p><p>3.先整体后局部, 从上到下,从外往里</p><p>4.去除重复的代码</p><p>相同的放到同一个class</p><p>不同的放到其他class里面</p><h3 id="变量和数据类型"><a href="#变量和数据类型" class="headerlink" title="变量和数据类型"></a>变量和数据类型</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编译原理</title>
      <link href="/2024/01/03/bian-yi-yuan-li/"/>
      <url>/2024/01/03/bian-yi-yuan-li/</url>
      
        <content type="html"><![CDATA[<p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240103204921495.png" alt="image-20240103204921495"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240103205005950.png" alt="image-20240103205005950"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240103205038135.png" alt="image-20240103205038135"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240103205120919.png" alt="image-20240103205120919"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240103210126214.png" alt="image-20240103210126214"><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240103210228094.png" alt="image-20240103210228094"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240103210613617.png" alt="image-20240103210613617"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240103210711148.png" alt="image-20240103210711148"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240103210804598.png" alt="image-20240103210804598"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240103210846777.png" alt="image-20240103210846777"></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;utility&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;const int N = 1e7;struct Node{string to;int dst;Node(string a, int b):to(a) ,dst(b){}};int i, j, n, k, num, Dst;string self ,enemy, str, str1;map&lt;string, int&gt;m, sign;map&lt;string, vector&lt;Node&gt; &gt; mid;typedef pair&lt;int, string&gt; pr;//first是最短距离， second代表城市void djstra(){map&lt;string, int&gt; dst, cityNume, enemtNum, road;priority_queue&lt;pr, vector&lt;pr&gt;, greater&lt;pr&gt; &gt;que;map&lt;string, string&gt; Path;vector&lt;string&gt; path;pr p;string v, to, pre;int i, j;for(auto it = m.begin(); it!=m.end(); it++){dst[it-&gt;first] = N;Path[it-&gt;first] = "";cityNum[it-&gt;first] = 0;enemyNum[it-&gt;first] = 0;road[it-&gt;first] = 1;}Path[self] = "";dist[self] = 0;cityNum[self] = 0;enemyNum[self] = 0;que.push(pr(0, self));int cnt = 0;while (que.size()){p = que.top();que.pop();v = p.second;if (sign[v] == 0)continue;sign[v] = 0;for (i = 0; i &lt; mid[v].size(); i++){to = mid[v][i].to;if (dst[v] + mid[v][i].dst &lt; dst[to]){dst[to] = dst[v] + mid[v][i].dist;Path[to] = v;cityNum[to] = cityNum[v] + 1;enemyNum[to] = enemyNum[v] + m[to];road[to] = road[v];que.push(pr(dst[to], to));}else if (dst[v] + mid[v][i].dst == dst[to]){road[to] += road[v];if (cityNum[v] + 1 &gt; cityNum[to]){Path[to] = v;cityNum[to] = cityNum[v] + 1;enemyNum[to] = enemyNum[v] + m[to];}else if (cityNum[v] + 1 == cityNum[to]){if (enemyNum[to] &lt; enemyNum[v] + m[to]){Path[to] = v;enemyNum[to] = enemyNum[v] + m[to];}}}}}pre = Path[enemy];path.push_back(enemy);while (pre != ""){path.push_back(pre);pre = Path[pre];}reverse(path.begin(), path.end());int flag = 0;for (i = 0; i &lt; path.size(); i++){if (flag)cout &lt;&lt; "-&gt;";cout &lt;&lt; path[i];flag = 1;}cout &lt;&lt; endl &lt;&lt; road[enemy] &lt;&lt; " " &lt;&lt; dst[enemy] &lt;&lt; " " &lt;&lt; enemyNum[enemy];} int main(){cin &gt;&gt; n &gt;&gt; k &gt;&gt; self &gt; enemy;for(i=1; i&lt;n; i++){cin &gt;&gt; str &gt;&gt; num;m[str] = num;sign[str] = 1;}m[self] = 0;sign[self] = 1;for(i=0; i&lt;k; i++){cin &gt;&gt; str &gt;&gt; str1 &gt;&gt; Dst;mid[str].push_back(Node(str1, Dst));mid[str1].push_back(Node(str, Dst));}djstra();return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vscode插件sublime快捷键的使用</title>
      <link href="/2023/12/31/vscode-cha-jian-sublime-kuai-jie-jian-de-shi-yong/"/>
      <url>/2023/12/31/vscode-cha-jian-sublime-kuai-jie-jian-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5基础语法与标签"><a href="#HTML5基础语法与标签" class="headerlink" title="HTML5基础语法与标签"></a>HTML5基础语法与标签</h1><p>快捷键扩展</p><pre class="line-numbers language-none"><code class="language-none">ctrl+shift+d 向下复制当前行ctrl+shift+上 上移当前行ctrl+shift+下 下移当前行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>多行编辑,按住鼠标滚轮然后下拉</p><p>在本地开发,在服务器共享</p><p>网址实际上就是服务器中文件的存放位置</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231231100950292.png" alt="image-20231231100950292"></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP请求</p><p>浏览器分析出请求之后就会把文件发回人的电脑里 HTTP响应</p><p>HTTP协议Hypertext Transfer Protocol超文本传输协议 是互联网数据传输的常见协议</p><p>一次http事务由http请求和http响应构成</p><p>网址前端 http://表示用http协议请求页面</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231231103004939.png" alt="image-20231231103004939"></p><h2 id="基础语法与标签"><a href="#基础语法与标签" class="headerlink" title="基础语法与标签"></a>基础语法与标签</h2><h3 id="基础语法与特性"><a href="#基础语法与特性" class="headerlink" title="基础语法与特性"></a>基础语法与特性</h3><h4 id="空白折叠现象"><a href="#空白折叠现象" class="headerlink" title="空白折叠现象"></a>空白折叠现象</h4><p>文字与文字间的多个空格换行会被折叠成一个空格</p><p>标签内壁和文字间的空格会被忽略</p><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>常见转义字符</p><pre class="line-numbers language-none"><code class="language-none">&lt;  小于号&gt;   大于号&amp;nbsp; 空格(不会被折叠)&amp;copy;  版权符号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><pre class="line-numbers language-none"><code class="language-none">&lt;!-- --&gt;ctrl+/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="div标签"><a href="#div标签" class="headerlink" title="div标签"></a>div标签</h4><p>divison分割的缩写,<code>&lt;div&gt;&lt;/div&gt;</code>标签对用来将相关的内容组合到一起以和其他内容分割</p><p>比如网页头部 </p><p>轮播图</p><p>文章内容</p><p>都要分别放到一个div标签中</p><p>div是最常见的html标签 ,可以结合css使用 ,实现网页的布局,这种布局形式叫做DIV+CSS</p><p>div像是一个容器,什么都可以容纳,因此工程师习惯称div为盒子</p><p>子标签一定要缩进</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231231105612660.png" alt="image-20231231105612660"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231231105838644.png" alt="image-20231231105838644"></p><p>没有嵌套关系的标签不能缩进</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231231110246498.png" alt="image-20231231110246498"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231231110324100.png" alt="image-20231231110324100"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231231110349720.png" alt="image-20231231110349720"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231231110439308.png" alt="image-20231231110439308"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231231110514449.png" alt="image-20231231110514449"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231231110740828.png" alt="image-20231231110740828"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231231110759509.png" alt="image-20231231110759509"></p><p>网页热更新下载插件Live Server</p><p>实现这个网页热更新对开发作用很大，但是网页一定是要放在一个文件夹里面的，不能零散的打开</p><p>认识HTML5骨架</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240106161513886.png" alt="image-20240106161513886"></p><p>head网页配置</p><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;文档类型声明DTD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240106161742646.png" alt="image-20240106161742646"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240106161928030.png" alt="image-20240106161928030"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240106162048647.png" alt="image-20240106162048647"></p><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><pre class="line-numbers language-none"><code class="language-none">&lt;meta charset="UTF-8"&gt;meta元标签，表示网页的基础配置 charset字符集UTF-8一种字符集<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240106162709136.png" alt="image-20240106162709136"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240106162918026.png" alt="image-20240106162918026"> <img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240106163515739.png" alt="image-20240106163515739"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240106163635333.png" alt="image-20240106163635333"></p><h4 id="网页关键词和页面描述"><a href="#网页关键词和页面描述" class="headerlink" title="网页关键词和页面描述"></a>网页关键词和页面描述</h4><pre class="line-numbers language-none"><code class="language-none">&lt;meta name="" content=""&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240106163923373.png" alt="image-20240106163923373"></p><h4 id="单标签"><a href="#单标签" class="headerlink" title="单标签"></a>单标签</h4><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240106164115471.png" alt="image-20240106164115471"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240106164933592.png" alt="image-20240106164933592"></p><h4 id="div标签-1"><a href="#div标签-1" class="headerlink" title="div标签"></a>div标签</h4><p>可以把网页头部标题放在一个div部分里</p><p>网页身体放在一个部分里</p><p>然后在网页主体的段落再用div包裹</p><p>使用class属性实现多种效果</p><p>可以在head中用style属性对不同标签设置不同效果</p><h4 id="标签后面的空格会被直接忽略直接到文字"><a href="#标签后面的空格会被直接忽略直接到文字" class="headerlink" title="标签后面的空格会被直接忽略直接到文字"></a>标签后面的空格会被直接忽略直接到文字</h4><h4 id="转义字符-1"><a href="#转义字符-1" class="headerlink" title="转义字符"></a>转义字符</h4><p>大于号</p><pre class="line-numbers language-none"><code class="language-none">&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>小于号</p><pre class="line-numbers language-none"><code class="language-none">&lt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>空格</p><pre class="line-numbers language-none"><code class="language-none">&amp;nbsp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>版权符号</p><pre class="line-numbers language-none"><code class="language-none">&amp;copy;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="小梦医生项目起步"><a href="#小梦医生项目起步" class="headerlink" title="小梦医生项目起步"></a>小梦医生项目起步</h4><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240106172154590.png" alt="image-20240106172154590"></p><p>网站首页index.html</p><p>绝大多数服务器默认</p><p>第一课总结</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240106172712679.png" alt="image-20240106172712679"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240106173022087.png" alt="image-20240106173022087"></p><pre class="line-numbers language-none"><code class="language-none">常见seo配置：title，两个meta标签   Keywords  DescriptionHTTP超文本传输协议向服务器发出http请求服务器发出http响应做好的网站要上传到服务器上才能被用户看见<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>软件和应用程序开发区别</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20240106193215674.png" alt="image-20240106193215674"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大前端学习</title>
      <link href="/2023/12/23/da-qian-duan-xue-xi/"/>
      <url>/2023/12/23/da-qian-duan-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机常识"><a href="#计算机常识" class="headerlink" title="计算机常识"></a>计算机常识</h1><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>4个字节= 32bit 即42亿多</p><p>分成四段 每段用十进制来表示</p><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>在一个真实ip下面组建一个局域网</p><p>公网ip  子网ip </p><p>确定在同一个局域网方法: 子网掩码</p><p>将ip地址与子网掩码按位与运算就可以进行验证了</p><p>如何测试与其他人网络是否互通?</p><p>使用ping 然后对方的ip地址</p><p>能正常连通的话说明两台电脑网络是连的</p><p>如果超时则不连通的</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>通过互联网提供服务的</p><p>公网ip</p><p>云服务器</p><p>商业服务器可以装多个cpu</p><p>为啥要输入http://   ?</p><p>浏览器和服务器通信的基本协议</p><p>全称:超文本传输协议</p><p>服务器上安装tomcat apache nginx</p><p>安装软件做好配置启动它就可以把网页提供给别人使用了</p><p>http是在TCP/IP的基础上而来的</p><p>https 加密的http安全协议</p><p>ftp文件传输协议</p><p>smtp电子邮件传输协议</p><p>dhcp动态主机配置协议</p><h2 id="DNS解析服务"><a href="#DNS解析服务" class="headerlink" title="DNS解析服务"></a>DNS解析服务</h2><p>域名解析服务</p><p>计算机如何知道百度的ip呢?</p><p>C:\Windows\System32\drivers\etc</p><p>在hosts配置文件里面</p><p>域名在这里映射到ip</p><p>当计算机在这里找不到映射时就会请求DNS服务器(通常由网络运营商提供,通常能找到全球的域名和ip)</p><p>qq程序内置ip地址,所以不受DNS服务器影响</p><p>一旦运营商DNS服务器出现问题就访问不了网络了</p><p>可以手动切换DNS地址</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231224001742414.png" alt="image-20231224001742414"></p><h3 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持:"></a>DNS劫持:</h3><p>host配置被更改了 域名访问到坏人的IP上去了,这时候登录账号密码账号就会被人盗走了</p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>顶级域名 .com .cn .net</p><p>2.3级域名</p><p>注册完域名就可以管理后台进行配置将域名指向ip</p><p>一个完整的域名地址包括网络协议 三级域名 二级域名 顶级域名和端口号</p><p>三级域名最常见www</p><p>world wide web 万维网联盟</p><p>通常把带www和不带的都指向同一个ip</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口:"></a>端口:</h3><p>用来分辨发送过来的数据</p><p>需要多个端口才能确保多个程序同时通信</p><p>计算机端口一共有6万多个</p><p>4000及以下的不要使用 很多系统程序会占用</p><p>为啥平时上网不用写端口号呢?</p><p>http上网默认协议就是80</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>command line 命令行</p><p>又叫DOS窗口 ,DOS也是一个操作系统</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231224003051598.png" alt="image-20231224003051598"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231224003128058.png" alt="image-20231224003128058"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231224003219440.png" alt="image-20231224003219440"></p><p>命令行先在当前文件夹中寻找文件,然后去path中的路径寻找文件</p><p>环境变量分两种</p><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量:"></a>系统变量:</h3><p>系统内置好的一些程序路径, 这些内容是所有登录用户共享的</p><h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><h2 id="字符乱码"><a href="#字符乱码" class="headerlink" title="字符乱码"></a>字符乱码</h2><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231224003741292.png" alt="image-20231224003741292"></p><p>unicode全球统一字符集编码</p><p>notepad++可以切换字符集 </p><h2 id="linux系统"><a href="#linux系统" class="headerlink" title="linux系统"></a>linux系统</h2><p>linux是操作系统的内核</p><p>git分布式代码管理软件</p><h2 id="计算机英语"><a href="#计算机英语" class="headerlink" title="计算机英语"></a>计算机英语</h2><p>优先读原版</p><p>back up备份</p><p>bin  binary二进制</p><p>admin</p><p>setup程序安装包</p><h2 id="什么是多线程和多进程"><a href="#什么是多线程和多进程" class="headerlink" title="什么是多线程和多进程"></a>什么是多线程和多进程</h2><p>多进程</p><p>windows系统中有很多个程序都开着, 通过轮循切换来实现的每个程序间切换的非常快,用户感受不到, 其实没有实际提升运行效率</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多个cpu可以开出多个线程</p><p>浏览器同时干多个事情</p><p>同一个进程里面同时发生的多个动作:喝水 - 很多个人同时喝一瓶水</p><p>程序一个一个执行的叫做同步</p><p>程序多个分支同时执行的叫做异步</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231224010509364.png" alt="image-20231224010509364"></p><p>右键 检查 console</p><h2 id="CMD命令"><a href="#CMD命令" class="headerlink" title="CMD命令"></a>CMD命令</h2><p>内部命令</p><p>外部命令</p><h3 id="切换盘符"><a href="#切换盘符" class="headerlink" title="切换盘符"></a>切换盘符</h3><p>输入d: 就可以切换到d盘了</p><h3 id="返回到上一目录"><a href="#返回到上一目录" class="headerlink" title="返回到上一目录"></a>返回到上一目录</h3><p>cd..</p><h3 id="直接返回到根目录"><a href="#直接返回到根目录" class="headerlink" title="直接返回到根目录"></a>直接返回到根目录</h3><p>cd\</p><h3 id="进入当前文件夹某个文件"><a href="#进入当前文件夹某个文件" class="headerlink" title="进入当前文件夹某个文件"></a>进入当前文件夹某个文件</h3><p>cd 文件名</p><h3 id="查看当前文件夹所有文件"><a href="#查看当前文件夹所有文件" class="headerlink" title="查看当前文件夹所有文件"></a>查看当前文件夹所有文件</h3><p>dir</p><p>查看当前文件夹所有可执行程序</p><p>输入dir *.exe *可为任意内容</p><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><p>md c:\abc</p><h3 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h3><p>del <em>.</em></p><h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><p>rd 目录名字</p><h3 id="查看所有命令及其作用"><a href="#查看所有命令及其作用" class="headerlink" title="查看所有命令及其作用"></a>查看所有命令及其作用</h3><p>help</p><p>help+命令 可以看到某个命令的详细说明</p><p>输入网址 ,向服务器发送请求,服务器返回文件</p><p>html内容</p><p>css布局和样式</p><p>js交互效果</p><p>图片压缩格式</p><p>图片文件格式</p><p>gif ()</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-28 235004.png)</p><p>无损压缩8-256色</p><p>  jpg   jpeg</p><p>支持最高级别压缩</p><p>支持上百万种颜色</p><p>有损压缩</p><p>png </p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-28 235205.png)</p><p>压缩到极限利于网络传输却不失真</p><p>bmp</p><p>网站中验证码,通常不压缩</p><p>  webg</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-28 235513.png)</p><p>有损压缩牺牲饱和度和色相   减少图像在内存和磁盘中占用的空间,不会发现对图像的外观产生很大不利影响</p><p>无损压缩压缩率低</p><h2 id="hypertext"><a href="#hypertext" class="headerlink" title="hypertext"></a>hypertext</h2><h3 id="超链接之页面跳转"><a href="#超链接之页面跳转" class="headerlink" title="超链接之页面跳转"></a>超链接之页面跳转</h3><p><code>&lt;a href="目标页面地址" target=""&gt; &lt;/a&gt;</code></p><p>_self代表当前页面打开</p><p>_blank在空白页面打开</p><p>anchor  hypertext </p><p>需要加上在网址前加上http://否则不能实现跳转</p><h3 id="超链接之锚点"><a href="#超链接之锚点" class="headerlink" title="超链接之锚点"></a>超链接之锚点</h3><pre class="line-numbers language-none"><code class="language-none">&lt;a href="#box" id="box1"&gt; 目标一&lt;/a&gt;&lt;p id = "box"&gt;&lt;a href="#box1"&gt;回到顶部&lt;/a&gt;&lt;/p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文本修饰之常用标签"><a href="#文本修饰之常用标签" class="headerlink" title="文本修饰之常用标签"></a>文本修饰之常用标签</h2><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129001119285.png" alt="image-20231129001119285"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129001844432.png" alt="image-20231129001844432"></p><p>strong盲人使用时会重读,b标签则没有</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129001228551.png" alt="image-20231129001228551"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129001252395.png" alt="image-20231129001252395"></p><p>em优先曝光</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129001346192.png" alt="image-20231129001346192"></p><p>html5已经不支持s标签,建议使用del</p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><pre class="line-numbers language-none"><code class="language-none">underline&lt;u&gt;&lt;/u&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="角标"><a href="#角标" class="headerlink" title="角标"></a>角标</h3><pre class="line-numbers language-none"><code class="language-none">上角标&lt;sup&gt;&lt;/sup&gt;&lt;sub&gt;&lt;/sub&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129003021442.png" alt="image-20231129003021442"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129003054071.png" alt="image-20231129003054071"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129003158565.png" alt="image-20231129003158565"></p><h3 id="标签"><a href="#标签" class="headerlink" title="标签:"></a>标签:</h3><p>单标签, 双标签</p><h3 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h3><p>放在标签里面, 属性名=属性值 不同属性间要用空格分开</p><h3 id="鼠标悬停显示文字"><a href="#鼠标悬停显示文字" class="headerlink" title="鼠标悬停显示文字"></a>鼠标悬停显示文字</h3><p>利用标签的title属性</p><pre class="line-numbers language-none"><code class="language-none">&lt;div title="我是鼠标悬停展示的内容"&gt;文字内容&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h2><pre class="line-numbers language-none"><code class="language-none">&lt;img src = "文件名"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="标准的HTML"><a href="#标准的HTML" class="headerlink" title="标准的HTML"></a>标准的HTML</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE heml&gt;//告诉浏览器后面书写的是HTML5规范的语法&lt;html&gt;    &lt;head&gt;&lt;meta charset="UTF-8"&gt;//设置字符集&lt;title&gt;HTML基本格式&lt;/title&gt;    &lt;/head&gt;&lt;body&gt;&lt;h1&gt;学习测试&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="网页标题"><a href="#网页标题" class="headerlink" title="网页标题<title>"></a>网页标题<code>&lt;title&gt;</code></h2><p>如何实现网页悬浮小标签上的文字?(同时也是收藏时候默认显示的文字)?</p><p>双标签</p><pre class="line-numbers language-none"><code class="language-none">&lt;title&gt;网页标题&lt;/title&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>只有h1到h6六个标签使用</p><h3 id="标题居中"><a href="#标题居中" class="headerlink" title="标题居中"></a>标题居中</h3><pre class="line-numbers language-none"><code class="language-none">&lt;h1 align="center"&gt; &lt;/h1&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><pre class="line-numbers language-none"><code class="language-none">&lt;p&gt;&lt;/p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>段落加空格</p><p>直接按空格键多个空格也只显示一个空格</p><p>使用<code>&amp;nbsp;</code></p><h2 id="使用标题和段落标签实现一个简单的网页"><a href="#使用标题和段落标签实现一个简单的网页" class="headerlink" title="使用标题和段落标签实现一个简单的网页"></a>使用标题和段落标签实现一个简单的网页</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1 align = "center"&gt;学习测试&lt;/h1&gt;    &lt;h4 align = "center"&gt;学习测试&lt;/h4&gt;    &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;学习测试&lt;/p&gt;    &lt;h3&gt;&amp;nbsp;学习测试&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图片和标签初探"><a href="#图片和标签初探" class="headerlink" title="图片和标签初探"></a>图片和标签初探</h2><pre class="line-numbers language-none"><code class="language-none">&lt;img src=""&gt; 单标签<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="三种引入图片路径情况"><a href="#三种引入图片路径情况" class="headerlink" title="三种引入图片路径情况"></a>三种引入图片路径情况</h3><h4 id="1-图片文件与html同文件夹下"><a href="#1-图片文件与html同文件夹下" class="headerlink" title="1.图片文件与html同文件夹下"></a>1.图片文件与html同文件夹下</h4><pre class="line-numbers language-none"><code class="language-none">&lt;img src="test.jpg"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-pic在与html同文件夹内的文件夹里"><a href="#2-pic在与html同文件夹内的文件夹里" class="headerlink" title="2.pic在与html同文件夹内的文件夹里"></a>2.pic在与html同文件夹内的文件夹里</h4><pre class="line-numbers language-none"><code class="language-none">&lt;img src="img/pic2.png"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-pic所在文件夹与html所在文件夹是同级关系"><a href="#3-pic所在文件夹与html所在文件夹是同级关系" class="headerlink" title="3.pic所在文件夹与html所在文件夹是同级关系"></a>3.pic所在文件夹与html所在文件夹是同级关系</h4><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231224140517192.png" alt="image-20231224140517192"></p><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><h4 id="1-引用互联网资源"><a href="#1-引用互联网资源" class="headerlink" title="1.引用互联网资源"></a>1.引用互联网资源</h4><pre class="line-numbers language-none"><code class="language-none">&lt;img src="图片所在的互联网地址"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-引用本地文件夹里的图片"><a href="#2-引用本地文件夹里的图片" class="headerlink" title="2.引用本地文件夹里的图片"></a>2.引用本地文件夹里的图片</h4><pre class="line-numbers language-none"><code class="language-none">&lt;img src="C:\qianfeng.png"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="图片标签进阶"><a href="#图片标签进阶" class="headerlink" title="图片标签进阶"></a>图片标签进阶</h2><p>有的图片由于某种原因无法显示(服务器响应过慢, 视力障碍阅读), 可以用文本来提示读者</p><p>如何操作?</p><pre class="line-numbers language-none"><code class="language-none">&lt;img src="路径" alt="替换文字"&gt;//alt显示会占用页面空间<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>鼠标悬停在图片上,如何显示悬停文本?</p><pre class="line-numbers language-none"><code class="language-none">&lt;img src="" alt="" title=""&gt; //title显示不占用页面空间, 只有鼠标划入时才会显示<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>标签名和属性名并不冲突</p><h2 id="图片标签拓展"><a href="#图片标签拓展" class="headerlink" title="图片标签拓展"></a>图片标签拓展</h2><pre class="line-numbers language-none"><code class="language-none">图片 格式bmp , jpg, jpeg, png, tif, gif, svg, psd, wmf, webp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最重要区别:图片存储时是否进行压缩 有损压缩还是无损压缩</p><pre class="line-numbers language-none"><code class="language-none">gif jpg jpegpng bmp webp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>有损压缩(保留亮度信息 将色相和饱和度的信息和周围像素进行合并)     </p><p>无损压缩 对文件本身压缩 不能减少图像在内存和磁盘中占用的空间压缩率也低</p><h3 id="gif支持透明-压缩-交错-多图像"><a href="#gif支持透明-压缩-交错-多图像" class="headerlink" title="gif支持透明 压缩 交错  多图像"></a>gif支持透明 压缩 交错  多图像</h3><h3 id="jpg-jpeg-有损压缩"><a href="#jpg-jpeg-有损压缩" class="headerlink" title="jpg/jpeg 有损压缩"></a>jpg/jpeg 有损压缩</h3><h3 id="png-兼具gif和jpg的格式"><a href="#png-兼具gif和jpg的格式" class="headerlink" title="png 兼具gif和jpg的格式"></a>png 兼具gif和jpg的格式</h3><h3 id="bmp-验证码常用"><a href="#bmp-验证码常用" class="headerlink" title="bmp 验证码常用"></a>bmp 验证码常用</h3><h3 id="webp有两种压缩格式-无损和有损-专为google研发"><a href="#webp有两种压缩格式-无损和有损-专为google研发" class="headerlink" title="webp有两种压缩格式 无损和有损  专为google研发"></a>webp有两种压缩格式 无损和有损  专为google研发</h3><h2 id="超链接之页面跳转-1"><a href="#超链接之页面跳转-1" class="headerlink" title="超链接之页面跳转"></a>超链接之页面跳转</h2><p>HyperText</p><p>超文本</p><pre class="line-numbers language-none"><code class="language-none">&lt;a href="页面地址"&gt; &lt;/a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>anchor  HyperText reference</p><h4 id="如果页面地址是一个网址-可以直接打开吗"><a href="#如果页面地址是一个网址-可以直接打开吗" class="headerlink" title="如果页面地址是一个网址,可以直接打开吗?"></a>如果页面地址是一个网址,可以直接打开吗?</h4><p> 需要加上http://</p><h4 id="页面跳转有哪两种方式-如何实现"><a href="#页面跳转有哪两种方式-如何实现" class="headerlink" title="页面跳转有哪两种方式?如何实现?"></a>页面跳转有哪两种方式?如何实现?</h4><p>1.在当前页面打开<code>&lt;a href="http://www.baidu.com/" target="_self"&gt;</code></p><p>2.在新页面打开<code>&lt;a href="http://www.baidu.com/" target="_blank"&gt;</code></p><h2 id="超链接之锚点id"><a href="#超链接之锚点id" class="headerlink" title="超链接之锚点id"></a>超链接之锚点id</h2><p>锚点又叫什么?</p><p>命名标记id</p><h3 id="如何实现页面内不同区域的跳转"><a href="#如何实现页面内不同区域的跳转" class="headerlink" title="如何实现页面内不同区域的跳转?"></a>如何实现页面内不同区域的跳转?</h3><p>锚点</p><p>可以实现目录等功能</p><p>具体实现</p><pre class="line-numbers language-none"><code class="language-none">&lt;a href="#box1"&gt;目标一&lt;/a&gt;&lt;a href="#box2"&gt;目标二&lt;/a&gt;&lt;p id="box1"&gt; 1&lt;/p&gt;&lt;p id="box2"&gt; 2&lt;/p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1 align = "center"&gt;学习测试&lt;/h1&gt;    &lt;h4 align = "center"&gt;        &lt;a href="#b1"&gt;第一&lt;/a&gt;        &lt;a href="#b2"&gt;第二&lt;/a&gt;    &lt;/h4&gt;    &lt;p align = "center" id = "b1"&gt;        &lt;img src="test.jpg" alt="测试"&gt;    &lt;/p&gt;    &lt;p align = "center" id = "b2"&gt;        &lt;img src="test.jpg" alt=""&gt;    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文本修饰之常用标签-1"><a href="#文本修饰之常用标签-1" class="headerlink" title="文本修饰之常用标签"></a>文本修饰之常用标签</h2><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p>bold    strong</p><pre class="line-numbers language-none"><code class="language-none">&lt;b&gt;b&lt;/b&gt;//仅仅为了加粗显示文本&lt;strong&gt;s&lt;/strong&gt;//strong标签语义化更强, 表示该文本比较重要, 同时视障阅读这个有重读, 上面那个则没有<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="倾斜"><a href="#倾斜" class="headerlink" title="倾斜"></a>倾斜</h3><pre class="line-numbers language-none"><code class="language-none">&lt;i&gt; &lt;/i&gt; //italic字体倾斜 无强调语气&lt;em&gt; &lt;em&gt; //emphasize字体倾斜 有加强语气 百度等搜索引擎的爬虫可以收录这个东西<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>如何实现字体上的删除线效果?</p><pre class="line-numbers language-none"><code class="language-none">&lt;s&gt;s&lt;/s&gt;strike //html5已经不支持s标签&lt;del&gt;s&lt;/d&gt;//delete<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="文本修饰之其他标签"><a href="#文本修饰之其他标签" class="headerlink" title="文本修饰之其他标签"></a>文本修饰之其他标签</h2><h3 id="下划线-1"><a href="#下划线-1" class="headerlink" title="下划线"></a>下划线</h3><pre class="line-numbers language-none"><code class="language-none">&lt;u&gt; &lt;/u&gt; //underline<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="特殊角标"><a href="#特殊角标" class="headerlink" title="特殊角标"></a>特殊角标</h3><p>如何实现一个化学式?</p><pre class="line-numbers language-none"><code class="language-none">&lt;sup&gt; &lt;/sup&gt; superscript上角标&lt;sub&gt; &lt;/sub&gt; subscript下角标<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>要整个标签嵌套 万万不可交叉嵌套</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231224191006169.png" alt="image-20231224191006169"></p><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>orderlist</p><p>ol<br>    li<br>    li</p><pre class="line-numbers language-none"><code class="language-none">&lt;ol&gt;&lt;li&gt;列表&lt;/li&gt;&lt;/ol&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ol中只能嵌套li, 其他的标签要放在li里面 </p><p>有序列表中项目符号是可以设置的</p><pre class="line-numbers language-none"><code class="language-none">&lt;ol type="__"&gt;&lt;/ol&gt; //A a I i 1 英文 罗马 阿拉伯<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>能否更改起始序号?</p><pre class="line-numbers language-none"><code class="language-none">&lt;ol start="1"&gt; &lt;/ol&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><pre class="line-numbers language-none"><code class="language-none">&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>unorder list</p><p>项目符号 默认三个实心原点</p><h3 id="vsc中交换两个行操作"><a href="#vsc中交换两个行操作" class="headerlink" title="vsc中交换两个行操作"></a>vsc中交换两个行操作</h3><p>alt + 上或下</p><p>如何改变项目符号?</p><pre class="line-numbers language-none"><code class="language-none">&lt;ul type = ""&gt;//disc 黑点 circle空心圆 none隐藏 square黑方&lt;/ul&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231224194721483.png" alt="image-20231224194721483"></p><p>type属性默认disc</p><h2 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h2><pre class="line-numbers language-none"><code class="language-none">&lt;dl&gt; definition list定义列表&lt;dt&gt; difinition term定义标题&lt;dd&gt; definition description定义描述<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;dl&gt;&lt;dt&gt; &lt;/dt&gt;//dt与dd两个互相不能嵌套 因为是同级别的&lt;dd&gt; &lt;/dd&gt;&lt;/dl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>dd dt不能脱离dl单独使用</p><p>在浏览器中dd会默认相对dt缩进</p><p>如何实现不缩进的呢?</p><pre class="line-numbers language-none"><code class="language-none">&lt;dl&gt;&lt;dt&gt; &lt;/dt&gt;&lt;dd&gt; &lt;/dd&gt;&lt;/dl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速创建标签小技巧"><a href="#快速创建标签小技巧" class="headerlink" title="快速创建标签小技巧"></a>快速创建标签小技巧</h2><p>快速创建h1</p><p>Emmet语法</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231224200441995.png" alt="image-20231224200441995"></p><pre class="line-numbers language-none"><code class="language-none">标签名{内容}+tab补全<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231224200709599.png" alt="image-20231224200709599"></p><pre class="line-numbers language-none"><code class="language-none">标签名{标签文本内容}*标签重复次数 然后tab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 嵌套标签</p><pre class="line-numbers language-none"><code class="language-none">父标签名 &gt; 子标签名{内容}*重复次数 tab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">ul&gt;li{文本}*5//一个ul里面放了五个liul*5&gt;li{文本}//创建五个ul 每个ul里面都有1个li<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="列表综合案例"><a href="#列表综合案例" class="headerlink" title="列表综合案例"></a>列表综合案例</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;列表案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1 align = "center"&gt;测试&lt;/h1&gt;    &lt;p&gt;        &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;测试段落    &lt;/p&gt;            &lt;p&gt;        &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;测试段落    &lt;/p&gt;    &lt;p&gt;        &lt;img src="test.jpg" alt="testa" title="title"&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;h2&gt;&lt;b&gt;测试&lt;/b&gt;&lt;/h2&gt;        &lt;ol start="1" type = "1"&gt;            &lt;li&gt;测试&lt;/li&gt;            &lt;li&gt;测试&lt;/li&gt;            &lt;li&gt;测试&lt;/li&gt;            &lt;li&gt;测试&lt;/li&gt;            &lt;li&gt;测试&lt;/li&gt;        &lt;/ol&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;h2&gt;&lt;b&gt;测试&lt;/b&gt;&lt;/h2&gt;        &lt;ul type="square"&gt;            &lt;li&gt;测试&lt;/li&gt;            &lt;li&gt;测试&lt;/li&gt;            &lt;li&gt;测试&lt;/li&gt;            &lt;li&gt;测试&lt;/li&gt;            &lt;li&gt;测试&lt;/li&gt;        &lt;/ul&gt;    &lt;/p&gt;    &lt;p&gt;        &lt;h2&gt;&lt;b&gt;测试&lt;/b&gt;&lt;/h2&gt;        &lt;dl&gt;            &lt;dt&gt;                &lt;img src="test.jpg" alt="test" title="title"&gt;            &lt;/dt&gt;            &lt;dd&gt;测试 &lt;/dd&gt;            &lt;dd&gt;测试&lt;/dd&gt;        &lt;/dl&gt;            &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="表格基础"><a href="#表格基础" class="headerlink" title="表格基础"></a>表格基础</h2><p>双标签</p><p>table </p><p>table row   tr</p><p>table data cell   td</p><p>不要在table和tr中包裹其他标签</p><p>一个tr表示一行</p><p>一个td表示一个单元格</p><pre class="line-numbers language-none"><code class="language-none">&lt;table&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基础表格实现</p><pre class="line-numbers language-none"><code class="language-none">table&gt;tr*4&gt;td*5//这样实现的表无框无表头突出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h2><p>如何加强表头显示呢?加粗?是否有对table的专门方法?</p><pre class="line-numbers language-none"><code class="language-none">&lt;th&gt;&lt;/th&gt;&lt;table header cell&gt;表头单元格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="alt-鼠标左键进行批量选择进行修改"><a href="#alt-鼠标左键进行批量选择进行修改" class="headerlink" title="alt+鼠标左键进行批量选择进行修改"></a>alt+鼠标左键进行批量选择进行修改</h3><p>如何定义表格框架线条粗细?</p><pre class="line-numbers language-none"><code class="language-none">&lt;table border="1"&gt;//数字定义线条粗细<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何定义表格的宽度与高度</p><pre class="line-numbers language-none"><code class="language-none">&lt;table border="" width="" height=""&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>定义出来的框架是有空格的,如何将空格取消掉呢</p><h3 id="cellspacing-单元格间距离"><a href="#cellspacing-单元格间距离" class="headerlink" title="cellspacing 单元格间距离"></a>cellspacing 单元格间距离</h3><h3 id="cellpadding-单元格边框和文本之间的距离"><a href="#cellpadding-单元格边框和文本之间的距离" class="headerlink" title="cellpadding 单元格边框和文本之间的距离"></a>cellpadding 单元格边框和文本之间的距离</h3><p>如何实现一个表格的对齐呢</p><pre class="line-numbers language-none"><code class="language-none">&lt;table align="属性"&gt;&lt;/tabke&gt; //这里的属性可以为left right center<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何更改表格背景颜色呢?</p><pre class="line-numbers language-none"><code class="language-none">&lt;table bgcolor="" bordercolor=""&gt;//背景颜色bgcolor   边框颜色 bordercolor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更加美观得看css了</p><h2 id="表格行属性"><a href="#表格行属性" class="headerlink" title="表格行属性"></a>表格行属性</h2><p>若未规定某一行的具体高度 那么每行会均分表高</p><p>若规定某一行表高则其他行将剩下来的平均分配</p><pre class="line-numbers language-none"><code class="language-none">&lt;tr height="数字"&gt;&lt;/tr&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>官方公布的tr属性中是没有宽度属性的</p><p>表格行高在没有设定值的情况下</p><p>有数据的一行会挤压无数据行的空间</p><p>设置行颜色</p><pre class="line-numbers language-none"><code class="language-none">&lt;tr bgcolor=""&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何实现一行内的单元格的水平对齐方式和垂直对齐方式呢</p><pre class="line-numbers language-none"><code class="language-none">&lt;tr align="" valign=""&gt;//align的几种方式  left center right//valign的几种方式  top middle bottom<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="单元格属性"><a href="#单元格属性" class="headerlink" title="单元格属性"></a>单元格属性</h2><p>如何实现只修饰一个单元格?</p><p>调整单元格的宽度</p><p>调整任何单元格的属性都会影响一列的宽度</p><p>​高度则会影响所在行</p><p>颜色则是单独颜色</p><pre class="line-numbers language-none"><code class="language-none">&lt;td width="" height=""  bgcolor=""&gt;&lt;/td&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何实现单个单元格的上下左右对齐方式呢?</p><pre class="line-numbers language-none"><code class="language-none">&lt;td align="" valign""&gt; &lt;/td&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="单元格合并"><a href="#单元格合并" class="headerlink" title="单元格合并"></a>单元格合并</h2><p>列合并(垂直)</p><p> 行合并(水平)</p><p>单元格跨行或跨列</p><p>只要保留第一个然后其他的删除,浏览器自动拉伸</p><p>那么具体如何实现呢?</p><p>用到span</p><p>rowspan跨行 再把其他的删掉(一定要记得删掉)  从某种意义上就实现了行合并</p><p>列的colspan同理</p><h2 id="表头属性"><a href="#表头属性" class="headerlink" title="表头属性"></a>表头属性</h2><p>将第一行的td 用alt+b逐个选中改为th 加强语义属性加粗同时居中的</p><p>可以加空格撑开表格</p><p>不然没数据的会被挤扁很丑</p><h2 id="表格标题和结构分组"><a href="#表格标题和结构分组" class="headerlink" title="表格标题和结构分组"></a>表格标题和结构分组</h2><p>如何实现一个表格标题</p><pre class="line-numbers language-none"><code class="language-none">&lt;caption&gt; &lt;/caption&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当表格变大 需要对行进行分组设计该如何做呢?</p><p>加入标签的设计</p><p>thead表格头</p><p>tbody表格体</p><p>tfoot表格尾</p><p>提醒:</p><p>如果未加入标签设计,浏览器渲染会把所有的tr放到tbody里面渲染</p><p>一个表格只允许一个thead和一个tfoot  但是允许多个tbody</p><p>列分为一组</p><pre class="line-numbers language-none"><code class="language-none">&lt;colgroup span="1"&gt; &lt;/colgroup&gt;//这里实现的是选择第一列<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方便设置一列的颜色</p><h2 id="颜色名称和长度单位"><a href="#颜色名称和长度单位" class="headerlink" title="颜色名称和长度单位"></a>颜色名称和长度单位</h2><p>颜色名称   必须使用140个标准名称之一 不能用中文</p><p>十六进制值 #RR GG BB 颜色强度</p><p>RGB值 RGB(R, G, B); R(0, 0 ,255)</p><h3 id="绝对单位长度"><a href="#绝对单位长度" class="headerlink" title="绝对单位长度"></a>绝对单位长度</h3><p>n  px </p><h3 id="相对单位长度"><a href="#相对单位长度" class="headerlink" title="相对单位长度"></a>相对单位长度</h3><p>适用于不同设备时使用</p><pre class="line-numbers language-none"><code class="language-none">&lt;table width="100%"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="块级元素-内联元素"><a href="#块级元素-内联元素" class="headerlink" title="块级元素 内联元素"></a>块级元素 内联元素</h2><p>HTML元素有默认显示值</p><p>block  -level 块级元素    </p><p>block元素自动占据一行, 上下有一定距离 占据可用的全部宽度</p><p>inline 内联元素</p><h3 id="当有好多个标签要实现相同的效果时应该怎么办-一个一个重选吗-显然不行-引入div标签"><a href="#当有好多个标签要实现相同的效果时应该怎么办-一个一个重选吗-显然不行-引入div标签" class="headerlink" title="当有好多个标签要实现相同的效果时应该怎么办?一个一个重选吗,显然不行,引入div标签"></a>当有好多个标签要实现相同的效果时应该怎么办?一个一个重选吗,显然不行,引入div标签</h3><p>div  分块   引申为盒子,容器</p><h3 id="块级元素一览"><a href="#块级元素一览" class="headerlink" title="块级元素一览"></a>块级元素一览</h3><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231227110103264.png" alt="image-20231227110103264"></p><p>内联元素不会独占一行,只占用必要的宽度</p><p>典型内联元素</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231227110239006.png" alt="image-20231227110239006"></p><p>内联元素里面不能嵌套块级元素</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231227122827362.png" alt="image-20231227122827362"></p><h2 id="初识表单"><a href="#初识表单" class="headerlink" title="初识表单"></a>初识表单</h2><p>如何采集用户信息?</p><p>表单</p><p>采集用户信息通过表单控件来完成</p><h3 id="分组控件"><a href="#分组控件" class="headerlink" title="分组控件"></a>分组控件</h3><h3 id="单行文本框控件"><a href="#单行文本框控件" class="headerlink" title="单行文本框控件"></a>单行文本框控件</h3><h3 id="多行文本框控件"><a href="#多行文本框控件" class="headerlink" title="多行文本框控件"></a>多行文本框控件</h3><h3 id="单选框控件"><a href="#单选框控件" class="headerlink" title="单选框控件"></a>单选框控件</h3><h3 id="多选框控件"><a href="#多选框控件" class="headerlink" title="多选框控件"></a>多选框控件</h3><h3 id="下拉框控件"><a href="#下拉框控件" class="headerlink" title="下拉框控件"></a>下拉框控件</h3><h3 id="文件选择控件"><a href="#文件选择控件" class="headerlink" title="文件选择控件"></a>文件选择控件</h3><h3 id="普通按钮控件"><a href="#普通按钮控件" class="headerlink" title="普通按钮控件"></a>普通按钮控件</h3><h3 id="自定义按钮控件"><a href="#自定义按钮控件" class="headerlink" title="自定义按钮控件"></a>自定义按钮控件</h3><p>具体实现?</p><pre class="line-numbers language-none"><code class="language-none">&lt;form&gt; &lt;/form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="文本框和密码框"><a href="#文本框和密码框" class="headerlink" title="文本框和密码框"></a>文本框和密码框</h2><p>form<br>      input</p><pre class="line-numbers language-none"><code class="language-none">&lt;input type="text"&gt; &lt;input type="password"&gt;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231227124801638.png" alt="image-20231227124801638"></p><p>input控件的type属性,默认是单行普通文本框</p><pre class="line-numbers language-none"><code class="language-none">&lt;form&gt;//换行温习请输入文本:&lt;input&gt;&lt;br&gt;密码:&lt;input type="password"&gt;&lt;/form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观点看法评论框的这些实现?</p><p>自动换行 多了会有滚轮</p><p>实现</p><pre class="line-numbers language-none"><code class="language-none">&lt;form&gt;&lt;textarea&gt; &lt;/textarea&gt;&lt;/form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如何设置宽度高度?</p><pre class="line-numbers language-none"><code class="language-none">&lt;textarea cols="" rows=""&gt; &lt;/textarea&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>滚动条会占位置的</p><p>一般用css来实现样式</p><pre class="line-numbers language-none"><code class="language-none">//单选radio//多选checkbox<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>单选框控件必须成组使用才有意义, 每组至少需要两个单选框</p><p>组是通过name属性来建立的,凡是name相同的就是一组</p><p>同组的单选框只有一个会处于选中状态 其他未选中</p><p>如何设置选中的默认值?</p><pre class="line-numbers language-none"><code class="language-none">&lt;intput type="radio" checked="checked"&gt; // 也可以直接写成checked<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="下拉框选中"><a href="#下拉框选中" class="headerlink" title="下拉框选中"></a>下拉框选中</h2><pre class="line-numbers language-none"><code class="language-none">&lt;select&gt;&lt;option&gt; &lt;/option&gt;&lt;/select&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>选中默认情况selected</p><p>下拉框如何选中多个?</p><p><code>&lt;select multiple size="数字"&gt;</code> 这里size是默认值</p><h2 id="选择文件"><a href="#选择文件" class="headerlink" title="选择文件"></a>选择文件</h2><pre class="line-numbers language-none"><code class="language-none">&lt;input type="file"&gt;//选择文件后文件名字显示在选择文件按钮的后面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不同的浏览器显示是不一样的,但是都可以实现文件的选择功能</p><h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单<label>标签"></a>表单<code>&lt;label&gt;</code>标签</h2><p>如何实现一个范围内都有一个功能选择的焦点?</p><p>例如点击文件名也能算是点击文本框</p><pre class="line-numbers language-none"><code class="language-none">&lt;label for="username"&gt;测试&lt;/label&gt;&lt;input type="text" id="username"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>id属性值具有唯一性,一个页面不能出现两相同的</p><p>只读输入框</p><p>只读输入框虽然内容不能输入和修改,但是可以复制</p><p>多行文本框也可以设置成只读的</p><p>那么如何实现呢?</p><pre class="line-numbers language-none"><code class="language-none">//给控件添加一个只读属性&lt;input type="text" readonly&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如何给文本框加上显示默认值?</p><p>多个表单控件开发的快速实现</p><pre class="line-numbers language-none"><code class="language-none">input[type="radio" name="gender"]*3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何让一个选项出现但是不给你选呢?</p><p>添加一个属性readonly</p><pre class="line-numbers language-none"><code class="language-none">&lt;input type="radio" name="gender"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认选中是checked</p><h2 id="表单分组"><a href="#表单分组" class="headerlink" title="表单分组"></a>表单分组</h2><p>如何实现带有边框和标题的表单?</p><p>fieldset字段集 引申为表单</p><p>legend 说明的意思 能够给fieldset定义标题</p><pre class="line-numbers language-none"><code class="language-none">&lt;filedset&gt;&lt;legend&gt;标题&lt;/legend&gt;&lt;/fieldset&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="表单按钮"><a href="#表单按钮" class="headerlink" title="表单按钮"></a>表单按钮</h2><p>提交</p><p>重置</p><p>普通</p><p>图像按钮</p><p>双标签button</p><p>具有收集信息发送到后台的功能</p><p>页面刷新<br>闪烁<br>地址后面多了问号</p><p>一个表单数据如何传给服务器?</p><p>使用action</p><pre class="line-numbers language-none"><code class="language-none">&lt;form action="http://www.baidu.com"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不写action数据会提交给自己的页面</p><p>然后重新进入自己的页面也就出现了页面闪烁一下,然后里面的内容消失</p><p>我们如何让这个内容不消失呢?</p><pre class="line-numbers language-none"><code class="language-none">&lt;form target="_blank"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何重置表单?</p><pre class="line-numbers language-none"><code class="language-none">&lt;input type="reset"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何定义一个普通按钮呢?</p><pre class="line-numbers language-none"><code class="language-none">&lt;input type="button" value="默认文字"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提交按钮</p><pre class="line-numbers language-none"><code class="language-none">&lt;input type="submit"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="表单按钮-下"><a href="#表单按钮-下" class="headerlink" title="表单按钮(下)"></a>表单按钮(下)</h2><p>图像按钮</p><p>按了之后会提交</p><pre class="line-numbers language-none"><code class="language-none">&lt;input type="imag" src="logo.png"&gt; //要有种类来源单独设置宽高 width  height<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>有没有其他的可以实现表单提交的功能</p><p>双标签button按钮</p><pre class="line-numbers language-none"><code class="language-none">&lt;button&gt; &lt;/button&gt;//如果加上type="button"这个按钮就又变成了普通按钮<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如何实现段首空两格功能?</p><pre class="line-numbers language-none"><code class="language-none">&amp;emsp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何实现多行文本的默认文字?</p><p>要通过textarea中添加文字实现,不能通过添加value实现</p><pre class="line-numbers language-none"><code class="language-none">[input type=radio name=ismilitary]*2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="表单数据采集和提交"><a href="#表单数据采集和提交" class="headerlink" title="表单数据采集和提交"></a>表单数据采集和提交</h2><p>前后端协作流程</p><p>要让浏览器自动收集表单控件数据</p><p>要在提交的表单控件属性里面添加上name属性</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231229183527911.png" alt="image-20231229183527911"></p><p>要在form标签的action属性里面写上网址 </p><p>提交信息直接现实中在网址中不安全</p><p>我们该怎么办呢?</p><p>涉及到提交方法method</p><p>默认方法:get 浏览器会把收集好的表单数据加到服务器地址的后面提交给服务器</p><p>post不但能收集数据,而且不会在地址栏里暴露隐私数据</p><pre class="line-numbers language-none"><code class="language-none">表单提交&lt;form action="" method="POST"&gt;        名字:&lt;input type="text" name="getname"&gt;&lt;br&gt;        密码: &lt;input type="password" name="password"&gt;&lt;br&gt;        &lt;input type="submit" value="登录"&gt;    &lt;/form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>浏览器收集表单提交的查看</p><pre class="line-numbers language-none"><code class="language-none">f12-&gt;network-&gt;点击事件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="其他使用标签"><a href="#其他使用标签" class="headerlink" title="其他使用标签"></a>其他使用标签</h2><pre class="line-numbers language-none"><code class="language-none">&lt;horizontal&gt;&lt;hr&gt; 在网页上画出一条水平分隔线<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>hr标签的五个属性</p><p>width/size 宽度和高度</p><p>noshade 用来去掉水平阴影</p><p>color 用来定义水平线的颜色</p><p>align  调整水平线水平对齐方式</p><pre class="line-numbers language-none"><code class="language-none">&lt;hr with="300" size="10px" align="left" noshade color="red"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="pre预格式化文本"><a href="#pre预格式化文本" class="headerlink" title="pre预格式化文本"></a>pre预格式化文本</h3><pre class="line-numbers language-none"><code class="language-none">&lt;pre&gt;&lt;/pre&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内容物将完整按照html源码中来实现</p><h3 id="map定义一个图像映射"><a href="#map定义一个图像映射" class="headerlink" title="map定义一个图像映射"></a>map定义一个图像映射</h3><p>点击图片不同区域实现链接页面的跳转</p><pre class="line-numbers language-none"><code class="language-none">&lt;map name=""&gt;&lt;area&gt;//定义图片上的热点区域&lt;/map&gt;name属性与img标签的usemap属性相关联<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>area设置位置的大小及形状,单标签</p><p>area三个属性:</p><p>href定义热点区域链接的目标地址</p><p>shape用来定义区域的形状</p><p>default 所有区域<br>rect 矩形<br>circle 圆形<br>ploy 多边形</p><p>coords用来定义可点击区域的坐标</p><pre class="line-numbers language-none"><code class="language-none">&lt;map&gt;&lt;area href="" shape="circle" coords="x,y,z"&gt;&lt;/map&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231229192148145.png" alt="image-20231229192148145"></p><p>多边形poly</p><pre class="line-numbers language-none"><code class="language-none">&lt;area shape="poly" coords="x1,y1,x2,y2,,,,xn,yn"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231229192332491.png" alt="image-20231229192332491"></p><p>不需要重新定义第一个坐标来闭合整个区域</p><p>定义矩形</p><pre class="line-numbers language-none"><code class="language-none">&lt;area shape="rect" coords="x1,y1,x2,y2"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何实现在图片中跳转呢</p><pre class="line-numbers language-none"><code class="language-none">//源图片&lt;img src="a.jpg" alt="" usemap="#planemap"&gt;//链接跳转的id也是要加#//但是label的for不需要#&lt;map name="planetmap"&gt;&lt;area shape="rect" coords="0,0,110,260" href="test.gif" alt=""&gt;&lt;area circle="circle" coords="129,161,10" href="test.gif" alt=""&gt;&lt;/map&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h2><p>如何实现在一个页面中塞入三个官网呢?</p><p>使用iframe标签</p><pre class="line-numbers language-none"><code class="language-none">&lt;iframe src="页面路径" width="数字" height="数字" frameborder="0" scrolling="属性"&gt;&lt;/iframe&gt;//scrolling属性auto yes no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(a[href target=iframe_a]&gt;b)*3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>a链接可以是互联网的网站地址也可以是自己制作的本地页面地址,这些页面都可以在iframe中显示</p><p>就是可以指向iframed的name</p><pre class="line-numbers language-none"><code class="language-none">&lt;div&gt;(a[href target=iframe_a]&gt;b)*3&lt;/div&gt;&lt;iframe src="http://www.baidu.com" frameborder="0" width="800" height="600" name="iframe_a"&gt; &lt;/iframe&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="SVG-XML语法的图像格式"><a href="#SVG-XML语法的图像格式" class="headerlink" title="SVG:XML语法的图像格式"></a>SVG:XML语法的图像格式</h2><p>不管缩放多少都不会模糊</p><p>png图片是基于像素处理的</p><p>svg标签是svg图形的一个容器</p><p>可以绘制各种图像</p><p>width  height</p><pre class="line-numbers language-none"><code class="language-none">&lt;svg width="" height=""&gt; &lt;/svg&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="SVG绘制矩形圆形和椭圆形"><a href="#SVG绘制矩形圆形和椭圆形" class="headerlink" title="SVG绘制矩形圆形和椭圆形"></a>SVG绘制矩形圆形和椭圆形</h2><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231229213720461.png" alt="image-20231229213720461"></p><p>rect(angle)矩形</p><p>任何html单标签都可以在第二个尖角号前写一个斜杠</p><p>表示标签闭合了</p><p><code>&lt;rect&gt;</code></p><p>width:定义矩形的宽度     height:定义矩形的高度   fill:定义矩形填充颜色      stroke-width:定义矩形的边框宽度    stroke:定义矩形边框的颜色</p><p>透明度的值越小,透明度越高</p><p>x是距离左边的你数字,y是距离右边的数字</p><p>fill-opacity填充颜色的透明度</p><p>stroke-opacity</p><p>透明的数值范围是0到1</p><p>左右和宽高都是直接的数字</p><pre class="line-numbers language-none"><code class="language-none">&lt;svg width="400" height="110"&gt;&lt;rect width="300" height="100" fill="blue" stroke-width="3" stroke="black"/&gt;&lt;/svg&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们也可以去掉fill-opacity和stroke-opaciry</p><pre class="line-numbers language-none"><code class="language-none">&lt;svg width="400" height="180"&gt;&lt;rect x="50" y="20" width="150" height="150" fill="blue" stroke="tomao"stroke-width="5" opacity="0.5" /&gt;&lt;/svg&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何实现矩形的圆角-椭圆角"><a href="#如何实现矩形的圆角-椭圆角" class="headerlink" title="如何实现矩形的圆角.椭圆角?"></a>如何实现矩形的圆角.椭圆角?</h3><pre class="line-numbers language-none"><code class="language-none">&lt;svg width="400" height="180"&gt;&lt;rect x="50" t="20" width="150" height="150" fill="red" stroke="black"stroke-width="5" opacity="0.5" rx="20" ry="30" /&gt;&lt;/svg&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何实现圆形的图形绘制"><a href="#如何实现圆形的图形绘制" class="headerlink" title="如何实现圆形的图形绘制?"></a>如何实现圆形的图形绘制?</h3><pre class="line-numbers language-none"><code class="language-none">&lt;circle cx="" cy="" r="" stroke="" 边框颜色stroke-width=""边框宽度 fill=""背景色填充/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>cx cy定义原中心的x,y坐标</p><p>r定义圆半径</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231230003349280.png" alt="image-20231230003349280"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231230003712256.png" alt="image-20231230003712256"></p><p>椭圆堆叠</p><p>按y轴 的那个顺序堆叠</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231230003909623.png" alt="image-20231230003909623"></p><p>如何绘制一个视觉上空心椭圆?</p><p>ellipse</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231230004025230.png" alt="image-20231230004025230"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231230004046850.png" alt="image-20231230004046850"></p><h2 id="SVG绘制线条-多边形-多线条"><a href="#SVG绘制线条-多边形-多线条" class="headerlink" title="SVG绘制线条 多边形 多线条"></a>SVG绘制线条 多边形 多线条</h2><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231230004228330.png" alt="image-20231230004228330"></p><p>line具体实现</p><pre class="line-numbers language-none"><code class="language-none">&lt;svg width="500" height="210"&gt;&lt;line x1="0" y1="0" x2="200" y2="200" stroke="red" stroke-width="2"&gt;&lt;/svg&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>绘制多边形</p><pre class="line-numbers language-none"><code class="language-none">polygan&lt;polygon points="x1,y1 x2,y2"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231230005611991.png" alt="image-20231230005611991"></p><p>绘制五角星</p><pre class="line-numbers language-none"><code class="language-none">&lt;svg width="500" height="210"&gt;&lt;polygon points="100,10 20,198 198,78 160,198" fill="lime" stroke="purple" stroke-width="5"/&gt;&lt;/svg&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231230010327449.png" alt="image-20231230010327449"></p><p>绘制多线条</p><pre class="line-numbers language-none"><code class="language-none">&lt;svg width="500" height="400"&gt;&lt;polyline points="点坐标集" stroke="black"stroke-width="3" fill="none" 不填充任何颜色/&gt;&lt;/svg&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="SVG绘制文本"><a href="#SVG绘制文本" class="headerlink" title="SVG绘制文本"></a>SVG绘制文本</h2><pre class="line-numbers language-none"><code class="language-none">&lt;svg height="100" width="300"&gt;&lt;text x="" y = "15" font-size="20" text-anchor=""&gt;TEST&lt;/text&gt;//text-anchor的属性有start middle end三种对齐方式&lt;/svg&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>举个例子</p><pre class="line-numbers language-none"><code class="language-none">&lt;svg width="300" height="30"&gt;&lt;text x="0" y="15" fill="red"&gt;I love SVG!&lt;/text&gt;&lt;/svg&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>svg标签里为什么不用p标签来绘制文本?</p><p>因为svg标签可以实现文本旋转的效果</p><pre class="line-numbers language-none"><code class="language-none">&lt;text transform="rotate(30, 20 40)"&gt; &lt;/text&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>svg标签中添加tspan标签实现单独效果</p><pre class="line-numbers language-none"><code class="language-none">&lt;svg width="200" height="60"&gt;&lt;text  x="10" t="20" fill="red"&gt;Serveral lines&lt;tspan x="10" y="45"&gt;First line&lt;/tspan&gt;&lt;tspan x="10" y="70"&gt;First line&lt;/tspan&gt;&lt;/text&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>text绘制的文本可以添加超链接吗?</p><pre class="line-numbers language-none"><code class="language-none">用a标签包裹起来就行&lt;svg xmlns:xlink="http://www.w3.org/1999/xlink"&gt;&lt;a xlink:href="test2.html" target=""&gt;&lt;text&gt; &lt;/text&gt;&lt;/a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="svg绘制路径"><a href="#svg绘制路径" class="headerlink" title="svg绘制路径"></a>svg绘制路径</h2><pre class="line-numbers language-none"><code class="language-none">&lt;path d=""/&gt;d是用来绘制路径的命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>d是draw绘制的缩写</p><p>M moveto<br>L lineto</p><pre class="line-numbers language-none"><code class="language-none">&lt;path d="M150 0 l75 200"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>M大写字母表示绝对定位</p><p>l小写字母表示相对定位</p><p>绝对定位是相对于屏幕坐标原点的位置</p><p>相对定位是相对于上一个绘制点的位置</p><pre class="line-numbers language-none"><code class="language-none">&lt;body&gt;&lt;svg width="400" height="210"&gt;&lt;path d="M150 0 L75 200 L225 200"/&gt;&lt;/svg&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用polygan绘制不也行吗,为什么用path?</p><p>二次贝塞尔曲线绘制</p><pre class="line-numbers language-none"><code class="language-none">&lt;path d="M 100 350 q 150 -300 300 0"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231230111935824.png" alt="image-20231230111935824"></p><p>在svg标签中可以用g标签将子标签包裹起来来批量设置子标签的格式</p><pre class="line-numbers language-none"><code class="language-none">&lt;svg width="450" height="400"&gt;&lt;path d="M 100 350 l150 -300" stroke="red" stroke-width="3" fill="none"&gt;    &lt;path d="M 250 50 l150 300" stroke="red" stroke-width="3" fill="none"&gt;    &lt;path d="M 175 200 l150 0" stroke="green" stroke-width="3" fill="none"&gt;    &lt;path d="M 100 350 l150 -300 300 0" stroke="red" stroke-width="3" fill="none"&gt;&lt;g fill="black"&gt;&lt;circle cx="100" cy="350" r="3" /&gt;&lt;circle cx="250" cy="50" r="3" /&gt;&lt;circle cx="400" cy="350" r="3" /&gt;&lt;/g&gt;&lt;g font-size="30" fill="black" text-anchor="middle"&gt;&lt;text x="100" y="350" dx="-30"&gt;A&lt;/text&gt;&lt;text x="250" y="50" dx="-10"&gt;B&lt;/text&gt;&lt;text x="400" y="350" dx="30"&gt;C&lt;/text&gt;&lt;/g&gt;&lt;/svg&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="SVG描边属性"><a href="#SVG描边属性" class="headerlink" title="SVG描边属性"></a>SVG描边属性</h2><pre class="line-numbers language-none"><code class="language-none">&lt;path stroke/&gt;//笔画属性&lt;path stroke-width/&gt;//笔画宽度属性&lt;path stroke-linecap/&gt;//笔画笔帽属性&lt;path stroke-dasharray/&gt;//虚线笔画属性//大小是直接用数字的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可用于线条 文本 图片 图形绘制</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231230115554581.png" alt="image-20231230115554581"></p><p>stroke-linecap的几种属性</p><p>butt没线帽  round圆形线帽   square方线帽</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231230120406928.png" alt="image-20231230120406928"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录刷题记录</title>
      <link href="/2023/12/23/dai-ma-sui-xiang-lu-shua-ti-ji-lu/"/>
      <url>/2023/12/23/dai-ma-sui-xiang-lu-shua-ti-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977 有序数组的平方"></a>977 有序数组的平方</h1><h2 id="空间换时间双指针算法"><a href="#空间换时间双指针算法" class="headerlink" title="空间换时间双指针算法"></a>空间换时间双指针算法</h2><ol><li></li></ol><p>学到的内容, 处理一个vector报错</p><pre class="line-numbers language-none"><code class="language-none">class Solution {public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) {        //用空间换时间        vector&lt;int&gt; t;        int i = 0;        while(i&lt;nums.size() &amp;&amp; nums[i] &lt;0){            i++;        }        for(int k = 0; k&lt;nums.size(); k++){            nums[k]=nums[k] * nums[k];         }        int l = i-1;        int r = i;        while(l&gt;=0 &amp;&amp;r&lt;nums.size()){            if(nums[l] &gt; nums[r]){                t.push_back(nums[r]);                r++;            }             else if(nums[l] &lt;= nums[r]){                t.push_back(nums[l]);                l--;            }        }        while(l&gt;=0){            t.push_back(nums[l]);                l--;        }        while(r&lt;nums.size()){             t.push_back(nums[r]);                r++;        }    return t;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遇到了一个内存访问越界的报错</p><p>int i = 0;<br>        while( nums[i] &lt;0){<br>            i++;<br>        }</p><p>​    我当成数组来处理了,忽略了此时的越界情况<br>​    只需要加上<br>   <code> i&lt;nums.size() &amp;&amp;</code></p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>学到的内容:</p><p>vector开辟一个定长数组</p><p>从开头到结尾,将较大的数放进去就行了</p><pre class="line-numbers language-none"><code class="language-none">class Solution {public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        vector&lt;int&gt; ans(n);        int l = 0, r = nums.size()-1;        int beg = r;        while(l&lt;=r &amp;&amp; beg&gt;=0){            int nl = nums[l]*nums[l];            int nr = nums[r]*nums[r];            if(nl&lt;nr){                ans[beg] = nr;                beg--;r--;            }            else if(nl &gt;= nr){                ans[beg] = nl;                beg--;                l++;            }        }        return ans;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二分法防止爆栈小技巧"><a href="#二分法防止爆栈小技巧" class="headerlink" title="二分法防止爆栈小技巧"></a>二分法防止爆栈小技巧</h1><pre class="line-numbers language-none"><code class="language-none">int mid = left + (right-left)/2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="快速排序模板"><a href="#快速排序模板" class="headerlink" title="快速排序模板"></a>快速排序模板</h1><pre class="line-numbers language-none"><code class="language-none">void <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习路线</title>
      <link href="/2023/12/22/xue-xi-lu-xian/"/>
      <url>/2023/12/22/xue-xi-lu-xian/</url>
      
        <content type="html"><![CDATA[<p>九曲阑干看基础</p><p>之后去读一年制网安</p><p>之后去警察局面试专技岗</p><h2 id="指向常量的指针"><a href="#指向常量的指针" class="headerlink" title="指向常量的指针"></a>指向常量的指针</h2><p>不能给指向常量的指针赋值</p><p>不可以用普通指针指向常量</p><p>用常量指针指向常量</p><p>可以给指向常量的指针赋一个指向变量的地址值</p><pre class="line-numbers language-none"><code class="language-none">void pconst_func(){    //指向常量的指针    const double pi = 3.14;    //不可以用普通指针指向常量    // double *ptr = &amp;pi;    //用常量指针指向常量    const double *cptr = &amp;pi;    //不能给*cptr赋值因为cptr指向的是常量    // *cptr = 42;    //指向常量的指针指向非常量    double dval = 3.14;    cptr = &amp;dval;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h2><pre class="line-numbers language-none"><code class="language-none">//常量指针//常量指针的值初始化后就不允许修改int errNumb = 0;// curErr将一直指向errNumbint *const curErr = &amp;errNumb;//不允许修改curErr的指向int rightNumb = 1;//编译报错，提示=左侧必须为可修改的左值// curErr = &amp;rightNumb;const double pi = 3.14159;// pip是一个指向常量对象的常量指针const double *const pip = &amp;pi;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="恋恋风辰官方博客-llfc-club"><a href="#恋恋风辰官方博客-llfc-club" class="headerlink" title="恋恋风辰官方博客 (llfc.club)"></a><a href="https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/22Dri4LSyomegdATe1xzpRJ49nW">恋恋风辰官方博客 (llfc.club)</a></h1><p>constexper变量</p><p>C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：</p><pre class="line-numbers language-none"><code class="language-none">void constexpr_func(){constexpr int mf = 20;const int limit = mf+1;constexpr int sizen = size();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="指针和constexpr"><a href="#指针和constexpr" class="headerlink" title="指针和constexpr"></a>指针和constexpr</h2><pre class="line-numbers language-none"><code class="language-none">void pointer_constexpr(){const int *p = nullptr;constexpr int *q = nummptr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为了顶层const</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><pre class="line-numbers language-none"><code class="language-none">void typedef_fuc(){ // wages是double的同义词typedef double wages;// base是double的同义词， p 是double*的同义词typedef wags base, *p;//c11用法using newd = double ;newd dd = 3.14;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">```新标准规定了一种新的方法，使用别名声明（aliasdeclaration）来定义类型的别名, using newd = double就是通过using定义newd类型和double是相同的。如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是类型char＊的别名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>void typedef_func()<br>{<br>    typedef char *pstring;<br>    //pstring 是一个指向char的常量指针<br>    const pstring cstr = 0;<br>    //ps是一个指针, 其对象是指向char的常量指针<br>    const pstring <em>ps;<br>    char b = ‘H’;<br>    //不可修改<br>    //cstr = &amp;b;<br>    ps = &amp;cstr;<br>    const pstring cstr2 = &amp;b;<br>    ps = &amp;cstr2;<br>    //不可修改</em>ps的值<br>}</p><pre class="line-numbers language-none"><code class="language-none">## auto推导<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>void auto_func()<br>{<br>    int a = 100;<br>    int b = 1024;</p><pre><code>auto c = a+b;auto i = 0, *p = &amp;i;//一条声明语句只能有一个基本数据类型//不同类型编译器会报错//auto sz = 0, pi = 3.14;const int ma = 1;//auto 会忽略顶层const //可以通过const明确指出, 此时f为const int 类型const auto f = ma;</code></pre><p>}</p><pre class="line-numbers language-none"><code class="language-none">auto 一般会忽略顶层const , 同时底层const则会保留下来要在一条语句中定义多个变量 , 切记, 符号&amp;和*只从属某个声明符, 而非基本数据类型的一部分, 因此初始值必须是同一种类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>auto k = ci, &amp;l = i;<br>auto &amp;m = ci, *p = &amp;ci;</p><pre class="line-numbers language-none"><code class="language-none">## 顶层const指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const（top-levelconst）表示指针本身是个常量，而用名词底层const（low-level const）表示指针所指的对象是一个常量。顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const## decltype类型提示符有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：```c++decltype(size()) sum;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">/*编译器并不实际调用函数size，而是使用当调用发生时size的返回值类型作为sum的类型。换句话说，编译器为sum指定的类型是什么呢？就是假如size被调用的话将会返回的那个类型。decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：*/void decltype_func(){decltype(size()) sum;const int ci = 0, &amp;cj = ci//x的类型是const intdecltype(ci) x = 0;//y的类型是const int&amp;, y绑定到xdecltype(cj) y = x;//错误, z是一个引用, 必须初始化//decltype(cj) z;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为cj是一个引用，decltype（cj）的结果就是引用类型，因此作为引用的z必须被初始化。需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型.</p><pre class="line-numbers language-none"><code class="language-none">int i = 42, *p = &amp;i, &amp;r= i;//这里的r返回int型的引用decltype(r) b1 = i;//r+0通过decltype返回int型decltype(r+0) b2;//错误, 必须初始化, c是int&amp;类型//decltype(*p) c;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><pre class="line-numbers language-none"><code class="language-none">void const_func(){    // 常量定义一定要初始化赋值，否则编译报错    const int bufSize = 512;    //修改bufSize的值会报错    //编译器提示表达式必须是可修改的左值    // bufSize = 222;    //运行时初始化    const int i = get_size();    //编译时初始化    const int j = 43;    //如果定义const变量不初始化也会报错    // const int k;    //利用一个常量初始化另一个常量    const int cj = j;    // const引用,引用及其对应的对象都是const    const int &amp;r1 = cj;    //不可以修改r1的值    // r1 = 42;    //不可以用非常量引用指向一个常量对象    // int &amp;r2 = ci;    int iv = 42;    //允许将const int&amp;绑定到一个普通int对象上    const int &amp;r1 = iv;    //正确, r2是一个常量引用    const int &amp;r2 = 42;    //正确, r3是一个常量引用    const int &amp;r3 = r1 * 2;    //错误, r4 是一个普通非常量的引用    // int &amp;r4 = r1 * 2;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="图书馆管理系统Sales-data类实现"><a href="#图书馆管理系统Sales-data类实现" class="headerlink" title="图书馆管理系统Sales_data类实现"></a>图书馆管理系统Sales_data类实现</h1><pre class="line-numbers language-none"><code class="language-none">#ifndef __CLASS_H__#define __CLASS_H__class Sales_data{public://通过default实现默认构造//Sales_data() = default;//显示实现默认构造Sales_data() : book(""), units_sold(0), revenue(0.0){}//copy构造, 根据Sales_data类型对象构造一个新对象Sales_data(const Sales_data &amp;sa);//返回图书号std::string isbn() const { return bookNo;}//获取平均单价double avg_price() const;//将一个Sales_data对象合并到当前类对象Sales_data &amp;combine(const Sales_data &amp;);private://图书编号std::string bookNo;//销量usigned units_sold = 0;//收入double revenue = 0.0;};//Sales_data的非成员接口extern Sales_data add(const Sales_data &amp;, const Sales_data &amp;);extern std::ostream &amp;print(std::ostream &amp;, const Sales_data &amp;);extern void dealSales();#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>isbn就是Sales_data类的成员函数，该函数返回类对象的bookNo，因为成员函数内部有一个隐藏的this指针形参, this指向了Sales_data对象，所以返回的是this-&gt;bookNo，this具体指向哪个Sales_data对象要看是谁调用的isbn，比如a.isbn()，那么this就指向&amp;a。<br>对于普通成员函数，this的类型为Sales_data <code>*</code> const，因为编译器不允许我们在成员函数内部修改this的值。默认情况下，this的类型是指向类类型非常量版本的常量指针。例如在Sales_data成员函数中，this的类型是Sales_data <code>*</code>const。尽管this是隐式的，但它仍然需要遵循初始化规则。<br>对于const成员函数，如isbn，this为const Sales_data <code>*</code> const类型，不允许通过*this修改其指向的对象。this是隐式的并且不会出现在参数列表中，所以在哪儿将this声明成指向常量的指针就成为我们必须面对的问题。C++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数（const member function）。<br>所以常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</p><p>编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。所以isbn可以访问bookNo不会报错。<br>当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。也就是说，返回类型、参数列表和函数名都得与类内部的声明保持一致。如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同时，类外部定义的成员的名字必须包含它所属的类名。</p><pre class="line-numbers language-none"><code class="language-none">double Sales_data::avg_price() const{    if (units_sold)        return revenue / units_sold;    else        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义返回this对象的combine函数</p><pre class="line-numbers language-none"><code class="language-none">Sales_data &amp;Sales::combine(const Sales_data &amp;sa){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>离散数学复习</title>
      <link href="/2023/12/17/chi-san-shu-xue-fu-xi/"/>
      <url>/2023/12/17/chi-san-shu-xue-fu-xi/</url>
      
        <content type="html"><![CDATA[<p> 判断公式类型</p><p>重言式 /永真式</p><p>矛盾式/永假式</p><p>可满足式</p><p>消去公式量词</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>物理光学复习</title>
      <link href="/2023/12/16/wu-li-guang-xue-fu-xi/"/>
      <url>/2023/12/16/wu-li-guang-xue-fu-xi/</url>
      
        <content type="html"><![CDATA[<p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231216185435525.png" alt="image-20231216185435525"></p><p>经过一个偏正片光强减弱一半</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231216193949384.png" alt="image-20231216193949384"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231216194915544.png" alt="image-20231216194915544"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231216230059245.png" alt="image-20231216230059245"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231216235507308.png" alt="image-20231216235507308"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231217002638245.png" alt="image-20231217002638245"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231217002730855.png" alt="image-20231217002730855"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/26/yuan-hua/"/>
      <url>/2023/11/26/yuan-hua/</url>
      
        <content type="html"><![CDATA[<p>AVG冒险游戏</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-28 162028.png)</p><p>笔刷中间是使劲画的情况</p><p>不透明度抖动和流量抖动都要开钢笔压感</p><p>喷枪给大的光影用的</p><p>36笔刷 粉笔</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端重学版</title>
      <link href="/2023/11/25/qian-duan-chong-xue-ban/"/>
      <url>/2023/11/25/qian-duan-chong-xue-ban/</url>
      
        <content type="html"><![CDATA[<p>​     </p><p>输入网址 ,向服务器发送请求,服务器返回文件</p><p>html内容</p><p>css布局和样式</p><p>js交互效果</p><p>图片压缩格式</p><p>图片文件格式</p><p>gif ()</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-28 235004.png)</p><p>无损压缩8-256色</p><p>  jpg   jpeg</p><p>支持最高级别压缩</p><p>支持上百万种颜色</p><p>有损压缩</p><p>png </p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-28 235205.png)</p><p>压缩到极限利于网络传输却不失真</p><p>bmp</p><p>网站中验证码,通常不压缩</p><p>  webg</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-28 235513.png)</p><p>有损压缩牺牲饱和度和色相   减少图像在内存和磁盘中占用的空间,不会发现对图像的外观产生很大不利影响</p><p>无损压缩压缩率低</p><h2 id="hypertext"><a href="#hypertext" class="headerlink" title="hypertext"></a>hypertext</h2><h3 id="超链接之页面跳转"><a href="#超链接之页面跳转" class="headerlink" title="超链接之页面跳转"></a>超链接之页面跳转</h3><p><code>&lt;a href="目标页面地址" target=""&gt; &lt;/a&gt;</code></p><p>_self代表当前页面打开</p><p>_blank在空白页面打开</p><p>anchor  hypertext </p><p>需要加上在网址前加上http://否则不能实现跳转</p><h3 id="超链接之锚点"><a href="#超链接之锚点" class="headerlink" title="超链接之锚点"></a>超链接之锚点</h3><pre class="line-numbers language-none"><code class="language-none">&lt;a href="#box" id="box1"&gt; 目标一&lt;/a&gt;&lt;p id = "box"&gt;&lt;a href="#box1"&gt;回到顶部&lt;/a&gt;&lt;/p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文本修饰之常用标签"><a href="#文本修饰之常用标签" class="headerlink" title="文本修饰之常用标签"></a>文本修饰之常用标签</h2><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129001119285.png" alt="image-20231129001119285"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129001844432.png" alt="image-20231129001844432"></p><p>strong盲人使用时会重读,b标签则没有</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129001228551.png" alt="image-20231129001228551"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129001252395.png" alt="image-20231129001252395"></p><p>em优先曝光</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129001346192.png" alt="image-20231129001346192"></p><p>html5已经不支持s标签,建议使用del</p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><pre class="line-numbers language-none"><code class="language-none">underline&lt;u&gt;&lt;/u&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="角标"><a href="#角标" class="headerlink" title="角标"></a>角标</h3><pre class="line-numbers language-none"><code class="language-none">上角标&lt;sup&gt;&lt;/sup&gt;&lt;sub&gt;&lt;/sub&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129003021442.png" alt="image-20231129003021442"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129003054071.png" alt="image-20231129003054071"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129003158565.png" alt="image-20231129003158565"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2023/11/25/shu-ju-jie-gou-2/"/>
      <url>/2023/11/25/shu-ju-jie-gou-2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu下载安装</title>
      <link href="/2023/11/25/ubuntu-xia-zai-an-zhuang/"/>
      <url>/2023/11/25/ubuntu-xia-zai-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>​<a href="https://www.releases.ubuntu.com/22.04/">Ubuntu 22.04.3 LTS (Jammy Jellyfish)</a></p><p>直接到上面的官网下载</p><p><img src="C:\Users\10482\Pictures\Screenshots\Snipaste_2023-11-25_11-07-41.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>思感</title>
      <link href="/2023/11/17/si-gan/"/>
      <url>/2023/11/17/si-gan/</url>
      
        <content type="html"><![CDATA[<p>​    我写一道算法题耗费老半天时间,但是在这个过程中我的逻辑能力和抽象能力都有被锻炼到啊!貌似刷题就是要锻炼这样的能力,而不是我之前理解的那样把题目熟悉理解套路!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/11/16/ji-suan-ji-wang-luo/"/>
      <url>/2023/11/16/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="1-1信息时代的计算机网络"><a href="#1-1信息时代的计算机网络" class="headerlink" title="1.1信息时代的计算机网络"></a>1.1信息时代的计算机网络</h2><p>各种各样的地方 :各种应用,通信,请列举你所使用过的网络应用。可从以下分类列举出具体的应用：即时通信，搜索殷勤，网络新闻，网络视频，网络购物，网上支付，网络音乐，网络游戏，网络文学，网上银行，旅行预订，网上订外卖，网络直播，微博，网约专车或快车，网约出租车，在线教育，互联网理财，短视频。</p><p>物联网,服务器,桌面计算机,笔记本电脑,手机,家用电器,环境传感器</p><p>网络攻击</p><h2 id="1-2因特网概述"><a href="#1-2因特网概述" class="headerlink" title="1.2因特网概述"></a>1.2因特网概述</h2><h3 id="网络-互联网-因特网的区别与关系"><a href="#网络-互联网-因特网的区别与关系" class="headerlink" title="网络,互联网,因特网的区别与关系"></a>网络,互联网,因特网的区别与关系</h3><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 001541.png)</p><p>网络之间用路由进行链接,形成互联网</p><p>世界上最大的互联网:因特网(Internet)</p><p>若干节点和链路互联形成网络</p><p>若干网络通过路由器形成互联网</p><p>因特网是当今世界上最大的互联网</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 002012.png)</p><p>任意通信协议                                                    VS                           TCP/IP协议族</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 002425.png)</p><p>因特网服务提供者(ISP   Intenet Service Provider)</p><p>互联网已经发展成为基于ISP的多层次结构的互联网络</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 003205.png)</p><h2 id="因特网-的标准化工作"><a href="#因特网-的标准化工作" class="headerlink" title="因特网 的标准化工作"></a>因特网 的标准化工作</h2><p>面向公众, 称为因特网标准之前都以一份RFC技术文档的形式在因特网上发表</p><p>RFC(Request For Comments) </p><p>下载RFC文档:<br><a href="http://www.ietf.org/rfc.html">www.ietf.org/rfc.html</a></p><h3 id="因特网管理结构"><a href="#因特网管理结构" class="headerlink" title="因特网管理结构"></a>因特网管理结构</h3><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 003604.png)</p><p>因特网组成:</p><p>核心:一块块的网络连结而成</p><h2 id="1-2电路交换-分组交换-报文交换"><a href="#1-2电路交换-分组交换-报文交换" class="headerlink" title="1.2电路交换,分组交换,报文交换"></a>1.2电路交换,分组交换,报文交换</h2><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 004137.png)</p><p>计算机之间数据传输方式是突发式的,如果使用电路交换的话效率会很低,例如qq的即时通讯</p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>报文通过交换节点传输,报文体积会大,增加交换节点性能负荷,所以切割报文 然后添加首部,分批次到达后合并报文去掉首部</p><p>发送方:构造分组,发送分组<br>交换节点:缓存分组,转发分组<br>接收方:接收分组,还原报文</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><p>没有建立连接和释放连接的过程<br>分组传输过程中逐段占用通信链路,有较高的通信线路利用率<br>交换节点可以为每一个分组独立选择转发路由,使得网络有很好的生存性</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h4><p>分组首部带来额外的传输开销<br>交换节点存储转发分组会造成一定的时延<br>无法却道通信时端到端全部可用,在通信量较大时可能造成网络拥塞<br>分组可能出现失序和丢失等问题</p><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 010744.png)</p><h2 id="三种方式对比"><a href="#三种方式对比" class="headerlink" title="三种方式对比"></a>三种方式对比</h2><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 010937.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 011028.png)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2023/11/16/shu-ju-jie-gou-1/"/>
      <url>/2023/11/16/shu-ju-jie-gou-1/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="3-4特殊矩阵的压缩存储"><a href="#3-4特殊矩阵的压缩存储" class="headerlink" title="3.4特殊矩阵的压缩存储"></a>3.4特殊矩阵的压缩存储</h2><p>存储结构:一维数组 ,二维数组<br>特殊矩阵:对称矩阵,三角矩阵 ,三对角矩阵,稀疏矩阵</p><p>二维数组存储的两种方法:行优先,列优先</p><p>非线性拉成线性</p><pre class="line-numbers language-none"><code class="language-none">b[i][j]存储地址=LOC+(i*N+j)*sizeof(ElemType)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>描述矩阵时从1开始,数组0开始,注意审题</p><h3 id="对称矩阵压缩存储"><a href="#对称矩阵压缩存储" class="headerlink" title="对称矩阵压缩存储"></a>对称矩阵压缩存储</h3><p>n阶方阵 aij=aji</p><p>策略:只存储主对角线+下三角区<br>行优先存储到一维数组中</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-16 131619.png)</p><p>？= n*(n+1)/2-1</p><p>对称矩阵压缩后怎样才能方便使用？</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h2 id="为什么n0-n2-1"><a href="#为什么n0-n2-1" class="headerlink" title="为什么n0 =n2+1;"></a>为什么n0 =n2+1;</h2><p>不用方程组的方法</p><p>用字母代表的抽象含义来看,</p><p>一个n2是代表两个路径 ,有一个根节点含两个路径时就意味着又要多出两个分支 多出这两个节点意味着多出了两个n0,与此同时,一旦这两个分支继续分支的话,n2就要继承上面的n2(?),</p><p>n2与上面的数要进行匹配来满足每个对应的n0</p><p>还是用等价的方式吧,抽象的想法太困难了 </p><h2 id="高度为h的m叉树至少有h个结点"><a href="#高度为h的m叉树至少有h个结点" class="headerlink" title="高度为h的m叉树至少有h个结点"></a>高度为h的m叉树至少有h个结点</h2><p>高度为h,度为m的数至少有h+m-1个结点</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 142147.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 142640.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 142732.png)</p><h2 id="5-2二叉树常考性质"><a href="#5-2二叉树常考性质" class="headerlink" title="5.2二叉树常考性质"></a>5.2二叉树常考性质</h2><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 143700.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 144106.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 144322.png)</p><h2 id="二叉树存储结构"><a href="#二叉树存储结构" class="headerlink" title="二叉树存储结构"></a>二叉树存储结构</h2><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 145006.png)</p><p>按照层序遍历的方式逐个存入数组中，从1开始</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 145826.png)</p><p>二叉树的结点(链式存储)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 154531.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 154636.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 154749.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 154815.png)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span><span class="token punctuation">{</span>    ElemType data<span class="token punctuation">;</span> <span class="token comment">//数据域</span>    <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span><span class="token punctuation">}</span>BiTNode<span class="token punctuation">,</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span>n个结点的二叉链表有n<span class="token operator">+</span><span class="token number">1</span>个空链表 <span class="token comment">//n个结点意味着2n个链表,除去根节点,就占用了n-1个链表</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-3-1二叉树的先中后序遍历"><a href="#5-3-1二叉树的先中后序遍历" class="headerlink" title="5.3.1二叉树的先中后序遍历"></a>5.3.1二叉树的先中后序遍历</h2><p>遍历:按照某次序把所有结点都访问一遍</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 200946.png)</p><p>二叉树的递归特性<br>1.空二叉树<br>2.根结点+左子树+右子树</p><p>先序遍历:根左右 NLR<br>中序遍历:左根右 LNR<br>后序遍历:左右根 LRN</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 201534.png)</p><p>前中后序三种递归</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span><span class="token punctuation">{</span>    ElemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span><span class="token punctuation">}</span>BiTNode<span class="token punctuation">,</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">void PostOrder(BiTree T){if(T!=NULL){//先序遍历visit(T);PostOrder(T-&gt;lchild);PostOrder(T-&gt;rchild);}} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">void PostOrder(BiTree T){if(T!=NULL){//中序遍历PostOrder(T-&gt;lchild);visti(T);PostOrder(T-&gt;rchild);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">void PostOrder(BiTree){if(T!=NULL){//后序遍历PostOrder(T-&gt;lchild);PostOrder(T-&gt;rchild);visit(T);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-17 222128.png)</p><p>空间复杂度O(h+1)即O(h)</p><p>求树的深度</p><pre class="line-numbers language-none"><code class="language-none">int treeDepth(BiTree T){if(T==NULL){return 0;}else{int l = treeDepth(T-&gt;lchild);int r = treeDepth(T-&gt;rchild);//树的深度return l&gt;r ? l+1 : r+1;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><p>算法思想:</p><p>初始化一个辅助队列<br>根结点入队<br>若队列非空  则队头结点出队 访问该结点 并将其左右孩子插入队尾(如果有的话)<br>重复<br>直到队列为空</p><p>存储结构:链表模拟队列</p><pre class="line-numbers language-none"><code class="language-none">void LevelOrder(BiTree T){LinkQueue Q;InitQueue(Q); //初始化辅助队列BiTree p;   EnQueue(Q, T);//根结点入队 ,有了初始条件才好写循环条件,有结束条件才好从循环条件里面跳出来while(!IsEmpty(Q)){ //队列不空则循环DeQueue(Q, p);visit(p);   if(p-&gt;lchild != NULL)EnQueue(Q, p-&gt;lchild); //左孩子入队if(p-&gt;rchild != NULL);EnQueue(Q, p-&gt;rchild);//右孩子入队}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h2><h3 id="next数组实现"><a href="#next数组实现" class="headerlink" title="next数组实现"></a>next数组实现</h3><pre class="line-numbers language-none"><code class="language-none">void initNext(string &amp;T, int next[]){int i = 0;int m = T.size();int t = next[0] = -1;while(i &lt; m-1){if(t&lt;0 )}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>kmp实现</p><pre class="line-numbers language-none"><code class="language-none">int KMP(char S[], char T[]){int i=1, j = 1;int next[10];initNext(T, next);while(i&lt;=S.size() &amp;&amp; j&lt;=T.size()){if(j==0 ||  s[i-1] == T[j-1]){i++;j++;}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231201192503151.png" alt="image-20231201192503151"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231201192534622.png" alt="image-20231201192534622"></p><pre class="line-numbers language-none"><code class="language-none">```![image-20231201204744213](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231201204744213.png)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>typedef struct BiThrNode{<br>    int data;<br>    int ltag,rtag;<br>    struct BiThrNode *lchild, *rchild;<br>}BiThrNode, *BiThrTree;</p><pre class="line-numbers language-none"><code class="language-none">![image-20231201205524970](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231201205524970.png)![image-20231201214215513](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231201214215513.png)![image-20231201221734771](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231201221734771.png)## 邻接矩阵![image-20231204143543894](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231204143543894.png)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>typedef char VerTexType;<br>#define MVNum 100<br>#define MaxNum 32767<br>typedef int ArcType;<br>typedef struct{<br>    VerTexType vexs[MVNum];<br>    ArcType arcs[MVNum][MVNum];<br>    int vexnum, arcnum;<br>}AMGraph; // Adjacency Matrix Graph</p><pre class="line-numbers language-none"><code class="language-none">![image-20231204145343616](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231204145343616.png)![image-20231204150057390](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231204150057390.png)![image-20231204151135910](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231204151135910.png)![image-20231204151507080](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231204151507080.png)![image-20231204152638817](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231204152638817.png)![image-20231204152813336](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231204152813336.png)![image-20231204172918460](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231204172918460.png)![image-20231204214642392](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231204214642392.png)![image-20231204215215895](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231204215215895.png)无向图中顶点Vi的度为第i个单链表中的节点数![image-20231204234321473](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231204234321473.png)![image-20231204234331564](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231204234331564.png)哈夫曼树<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#include<iostream><br>#include<algorithm><br>#include<iomanip><br>using namespace std;<br>typedef struct HFT<br>{<br>    int weight;<br>    int parent, LTree, RTree;<br>} *PHFT;</iomanip></algorithm></iostream></p><p>void select(PHFT HFT, int n, int &amp;s1, int &amp;s2)<br>{<br>    for(int i=1; i&lt;n; i++){<br>    if(HFT[i].parent == 0){<br>    s1 = i;<br>    break;<br>    }<br>    }</p><pre><code>for(int i=1; i&lt;n; i++){if(HFT[i].parent == 0){s1 = i;break;}}for(int i=1; i&lt;n; i++){if(HFT[i].parent == 0){    s1 = i;    break;}}for(int i=1; i&lt;n; i++){if(HFT[i].parent == 0 &amp;&amp; HFT[s1].weight &gt; HFT[i].weight)s1 =  i;}for(int j = 1; j&lt;n; j++){if(HFT[j].parent == 0 &amp;&amp; j!=s1){s2 = j;}}for(int j = 1; j&lt;n; j++){if(HFT[j].parent == 0 &amp;&amp; HFT[s2].weight &gt; HFT[j].weight)}</code></pre><p>}<br>void initHFT(PHFT &amp;H, int n){<br>    int m = 2<em>n-1;<br>    H = newHFT[m+1];<br>    for(int i=1; i&lt;=m; i++){<br>    H[i].parent = 0;<br>    H[i].LTree = 0;<br>    H[i].RTree = 0;<br>    }<br>    for(int i=1; i&lt;=n; i++){<br>    cin &gt;&gt; H[i].weight;<br>    }<br>    for(int i=n+1; i&lt;=m; i++){<br>    int s1, s2;<br>    select(H, i, s1, s2);<br>    H[s1].parent = i;<br>    H[s2].parent = i;<br>    H[i].LTree = s1;<br>    H[i].RTree = s2;<br>    H[i].weight = H[s1].weight+H[s2].weight;<br>    }<br>}<br>int main(){<br>    PHFT HFT;<br>    int n = 0;<br>    cin &gt;&gt; n;<br>    initHFT(HFT, n);<br>    int sum = 0;<br>    for(int i=1; i&lt;2</em>n-1; i++){<br>    sum+=H[i].weight;<br>    }<br>    cout &lt;&lt; sum;<br>}</p><pre class="line-numbers language-none"><code class="language-none">![image-20231207212629628](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231207212629628.png)![image-20231207213010829](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231207213010829.png)![image-20231208152352079](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231208152352079.png)![image-20231208204414966](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231208204414966.png)![image-20231208204429737](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231208204429737.png)图的遍历![image-20231210131556630](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210131556630.png)![image-20231210143242021](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210143242021.png)![image-20231210144725130](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210144725130.png)![image-20231210144736500](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210144736500.png)![image-20231210145428212](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210145428212.png)![image-20231210150148251](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210150148251.png)![image-20231210152049985](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210152049985.png)![image-20231210152207027](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210152207027.png)![image-20231210153421234](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210153421234.png)![image-20231210153905906](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210153905906.png)![image-20231210153944232](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210153944232.png)![image-20231210154655375](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210154655375.png)![image-20231210161020323](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210161020323.png) ![image-20231210214125605](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210214125605.png)![image-20231210214331116](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210214331116.png)![image-20231210215025479](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210215025479.png)![image-20231210215942900](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210215942900.png)![image-20231210232559749](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210232559749.png)![image-20231210234120563](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231210234120563.png)![image-20231211190332359](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231211190332359.png)利用镖局运输题目学习kruskal最小生成树算法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#include<iostream><br>#include<br>using namespace std;<br>int n, m;<br>struct road{<br>    int a, b, cost;<br>}r[1001];<br>int f[1001];<br>int Find(int n)<br>{<br>    if(f[n] ==n) return n;<br>    else<br>    return  Find(f[n]);<br>}<br>bool cmp(road&amp; i, road &amp;j){<br>    return i.cost &lt; j.cost;<br>}<br>void kruskal()<br>{<br>    int i;<br>    for(i=  1; i&lt;=n; i++){<br>    f[i] = i;<br>    }<br>    for(i=0; i&lt;m; i++){<br>    cin &gt;&gt; r[i].a &gt;&gt; r[i].b &gt;&gt; r[i].cost;</iostream></p><pre><code>}sort(r, r+m, cmp);int sum = 0, t = 0;for(int i=0; i&lt;m; i++){if(t == n-1) break;int x = Find(r[i].a);int y = Find(r[i].b);if(x!= y){f[x] = y;t++;sum = sum+r[i].cost;}}if(t == n-1) printf("%d", sum);else printf("impossible");</code></pre><p>}</p><p>int main(){<br>    scanf(“%d %d”, &amp;n, &amp;m);<br>    kruskal();<br>    return 0;<br>}</p><pre class="line-numbers language-none"><code class="language-none">最短路径算法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>#include<queue><br>#include<algorithm><br>#include<vector><br>using namespace std;<br>int INF = 999999;<br>int maps[11][11];<br>int N, M;<br>int bestw = INF;<br>int cnt = 0<br>int vis2[11] = {0};<br>struct Node{<br>    int x[100];<br>    int layer;<br>    int c1;<br>};</vector></algorithm></queue></p><p>bool operator&lt;(const Node&amp; a, const Node&amp; b){<br>    return a.c1 &gt; b.c1;//升序处理,使小的在前面<br>}<br>void bfs(int a, int b){<br>    priority_queue<node> q;<br>    Node node1;<br>    node1.c1 = 0;<br>    node1.layer = 0 ;<br>    for(int i = 0; i&lt;N; i++){<br>    node1.x[i] = i;<br>    }<br>    node1.x[0] = a;<br>    q.push(node1);<br>    while(!q.empty()){<br>    int vis[11] = {0};<br>    vis[a] = 1;<br>    Node newnode;<br>    newnode =  q.top();<br>    q.pop();<br>    int t1 = newnode.lawer;<br>    int t2 = newnode.x[t1];<br>    if(t2 == b){<br>        if(newnode.c1 &lt; bestw){<br>        bestw = newcode.c1;<br>    }else{<br>        continue;<br>    }<br>    }<br>    if(newnode.c1 &gt;= bestw) continue;</node></p><pre><code>for(int j = 0; j&lt;N; j++){if(vis[j] != 1 &amp; newcode.c1 + maps[t2][j] &lt; bestw){int flag = 1;for(int k = 0; k &lt; t1; k++){if(newnode.x[k] == j){    flag = 0;    }}if(flag == 0)continue;vis[j] = 1;Node node2;node2.c1 = newcode.c1+maps[t2][j];node2.layer = t1+1;for(int i = 0; i&lt;N; i++){node2.x[i] = newnode.x[i];}swap(node2.x[t1+1], j);//t1代表层数, node.x[t1]代表该层数对应图中的节点号}}</code></pre><p>}<br>void dfs(int a, int b){<br>    if(a == b){<br>    cnt = 1;<br>    return ;<br>    }<br>    vis2[a] = 1;<br>    for(int i = 0; i&lt;N; i++){<br>    if(vis2[i] !=1 &amp;&amp; maps[a][i] == 1){<br>    dfs(i, b);<br>    }<br>    }<br>}<br>int main()<br>{<br>    int target1, target2;<br>    cin &gt;&gt; N &gt;&gt; M;<br>    for(int i = 0; i&lt;N; i++){<br>    for(int j = 0; j&lt;N; j++){<br>        if(i == j) maps[i][j] = 0;<br>        maps[i][j] = INF;<br>    }<br>    }<br>    for(int i=0; i&lt;M; i++){<br>    int side1, side2;<br>    cin &gt;&gt; side1 &gt;&gt; side2;<br>    maps[side1][side2] = 1;<br>    maps[side2][side1] = 1;<br>    }<br>    cin &gt;&gt; target1 &gt;&gt; target2;<br>    dfs(target1, target2);<br>    if(cnt== 0){<br>    cout &lt;&lt; “There is no path between” &lt;&lt; target1 &lt;&lt; “ and “ &lt;&lt; target2 &lt;&lt; “.”;<br>    } else{<br>    bfs(target1, target2);<br>    cout &lt;&lt; “The lenth of the shortest path between “ &lt;&lt; target1 &lt;&lt; “ and “ &lt;&lt; target2 &lt;&lt; “ is “ &lt;&lt; bestw &lt;&lt;”.”;</p><pre><code>}</code></pre><p>}</p><pre class="line-numbers language-none"><code class="language-none">考试时候哈希表只考除留余数法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>BiTree Search(BiTree T, KetType key) {<br>    if(!T || key == T-&gt;data){<br>    return T;<br>    }<br>    else if(key &lt; T-&gt;data){<br>    return SearchBST(T-&gt;lchild, key);<br>    }<br>    else{<br>    return SearchBST(T-&gt;rchild, key);<br>    }<br>}</p><pre class="line-numbers language-none"><code class="language-none">BST插入新元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Status InsertBST(BiTree &amp;T, ElemType e){<br>    if(T == NULL){<br>    T = new BiNode;<br>    T-&gt;data = e;<br>    T-&gt;lchild = NULL;<br>    T-&gt;rchild = NULL;<br>    return true;<br>    }<br>    else if(e == T-&gt;data){<br>    return false;<br>    }<br>    else if(e &lt; T-&gt;data){<br>    InsertBST(T-&gt;lchild, e);<br>    }<br>    else{<br>    InsertBST(T-&gt;rchild, e);<br>    }<br>}</p><pre class="line-numbers language-none"><code class="language-none">二叉排序树中删除某个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Status Delete(BiTree &amp;p)<br>{<br>    BiTree q = NULL, s = NULL;<br>    if(!p-&gt;lchild){<br>    q = p;<br>    p = p-&gt;rchild;<br>    free(q);<br>    }<br>    else if(!p-&gt;rchild){<br>    q = p;<br>    p = p-&gt;lchild;<br>    free(q);<br>    }<br>    else{<br>    q = p;<br>    s = p-&gt;lchild;<br>    while(s-&gt;rchild)<br>    {<br>    q = s;<br>    s = s-&gt;rchild;<br>    }</p><pre><code>}return true;</code></pre><p>}</p><p>Status DeleteBST(BiTree *T, int key)<br>{<br>    if(!(*T)){<br>    return false;<br>    }<br>    else{<br>    if(key == T-&gt;data){<br>        Delete(T);<br>        return true;<br>    }<br>    else if(key &lt; T-&gt;data){<br>    return DeleteBST(T-&gt;lchild, key);<br>    }<br>    else{<br>        //进入当前结点的左子树, 继续查找目标元素<br>        return DeleteBST(T-&gt;rchild, key);<br>    }<br>    }<br>}</p><pre class="line-numbers language-none"><code class="language-none">二叉排序树查找<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>BSTNode *Search(BSTNode *root, int x){<br>    if(root-&gt;data == x){<br>        return root;<br>    }else if(x &lt; root-&gt;data){<br>    return Search(root-&gt;left, x);<br>    }else{<br>    return Search(root-&gt;right, x);<br>    }<br>}</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>BSTNode *Search(BSTNode *root, int x){<br>    BSTNode *p = root;<br>    while(p != NULL &amp;&amp; p-&gt;data!=x){<br>        if(x &lt; p-&gt;data)<br>        p = p-&gt;left;<br>        else<br>        p = p-&gt;right;<br>    }<br>    return p;<br>}</p><pre class="line-numbers language-none"><code class="language-none">插入的递归算法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">二叉排序树的具体实现<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>#include&lt;stdio.h&gt;<br>#include&lt;stdio.h&gt;<br>#define ElemType int<br>#define KeyType int<br>typedef enum {false, true} Status;<br>typedef struct BiTNode<br>{<br>    int data ;<br>    struct BiNode* lchild, * rchild;<br>}BiTNode, *BiTree;<br>BiTree SearchBST(BiTree T, KeyType key){<br>    if(!T || K == T-&gt;data){<br>    return T;<br>    }<br>    else if(key &lt; T-&gt;data){<br>    return SearchBST(T-&gt;lchild, key);<br>    }<br>    else{<br>    return SearchBSt(T-&gt;rchild, key);<br>    }<br>}</p><p>Status InsertBST(BiTree &amp;T, ElemType e){<br>    if(T == NULL){<br>    T = new BiNode;<br>    T-&gt;data = e;<br>    T-&gt;lchild = NULL;<br>    T-&gt;rchild = NULL;<br>    return true;<br>    }<br>    //如果找到目标元素,插入失败<br>    else if(e == T-&gt;data){<br>    return false;<br>    }<br>    else if(e &lt; T-&gt;data){<br>    InsertBST(T-&gt;lchild, e);<br>    }<br>    else{<br>    InsertBST(T-&gt;rchild, e);<br>    }<br>}<br>void INOrderTraevrse(BiTree T){<br>    if(T){<br>    INOrerTraverse(T-&gt;lchild);<br>    printf(“%d”, T-&gt;data);<br>    INOrderTraverse(T-&gt;rchild);<br>    }<br>}</p><p>void DestoryBiTree(Bitree T){<br>    if(T){<br>    DestoryBiTree(T-&gt;lchild);<br>    DestoryBiTree(T-&gt;rchild);<br>    Free(T);<br>    }<br>}<br>int main(){<br>    int i;<br>    int a[10] = {41, 20, 11, 29, 32, 65, 50, 91, 72, 99};<br>    BiTree T = NULL;<br>    for(i = 0; i&lt;10; i++){<br>    InsertBST(T, a[i]);<br>    }<br>    INOrderTraverse(T);<br>    printf(“\n”);<br>    if(SearchBST(T, 20)){<br>    printf(“k二叉排序树中存有元素 20”);<br>    }<br>    DeleteBST(T , 20);<br>}</p><pre class="line-numbers language-none"><code class="language-none">散列表(哈希表)![image-20231218154125790](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218154125790.png)![image-20231218154224463](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218154224463.png)![image-20231218154402731](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218154402731.png)![image-20231218155558991](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218155558991.png)![image-20231218155703884](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218155703884.png)![image-20231218155935229](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218155935229.png)![image-20231218160110912](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218160110912.png)![image-20231218160430419](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218160430419.png)![image-20231218160916156](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218160916156.png)![image-20231218161015346](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218161015346.png)![image-20231218161503617](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218161503617.png)![image-20231218161534015](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218161534015.png)![image-20231218162238545](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218162238545.png)![image-20231218162348857](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218162348857.png)![image-20231218163224827](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218163224827.png)![image-20231218163340614](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218163340614.png)![image-20231218163814569](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218163814569.png)![image-20231218164020503](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218164020503.png)![image-20231218164130021](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218164130021.png)![image-20231218164249378](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218164249378.png)![image-20231218164753093](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218164753093.png)![image-20231218164839178](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218164839178.png)![image-20231218165022965](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218165022965.png)![image-20231218171523255](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218171523255.png)顺序查找 折半查找的平均查找长度分析ASL：平均查找长度其中n为查找表中元素个数，Pi为查找第i个元素的概率，通常假设每个元素查找概率相同，Pi=1/n，Ci是找到第i个元素的比较次数。 ![image-20231218171654210](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218171654210.png)一般顺序查找的平均查找长度：因为顺序查找就是顺序存储 一个一个比较，所以如果查找成功的话说明就和之前不相等的元素已经比较过了。所以第 n 个元素就是比较了 n 次每个元素都比较了其所在位序的次数每个元素被查找的概率都是1/n 所以![image-20231218171720458](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218171720458.png)有序顺序表的平均查找长度：查找成功的 ASL 不影响如果查找不成功的话，因为顺序表有序，所以可以提前结束，从而缩短查找失败的比较次数，需要画个简单【判定树】举个例子，在[10 20 30 40 50 60]中查找失败的一共有 n+1个结点，所以每个结点的概率就是1/(n+1)![image-20231218171746036](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218171746036.png)比较次数是 每个失败结点上一层的层数折半查找的平均查找长度：要涉及到判定树：n 个元素就有n 个【内部结点】 n+1个【外部结点】【判定树】一定是【满二叉树】根据折半算法画出初级判定树（只有内部结点），其他空位用【查找失败的方框代替】算 ASL 直接就是算 [每层结点的个数*层数]➗结点个数不成功要具体例子具体计算。![image-20231218171613906](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218171613906.png)![image-20231218172357881](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218172357881.png)![image-20231218172748421](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218172748421.png) ![image-20231218174158386](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218174158386.png)![image-20231218191214742](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218191214742.png)![image-20231218192349731](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218192349731.png)B树![image-20231218214941866](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218214941866.png)![image-20231218215203874](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218215203874.png)![image-20231218215356294](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231218215356294.png)![image-20231219123517756](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219123517756.png)![image-20231219124406890](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219124406890.png)![image-20231219130118100](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219130118100.png)![image-20231219130700658](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219130700658.png)![image-20231219141211729](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219141211729.png)![image-20231219144543484](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219144543484.png)![image-20231219144752517](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219144752517.png)![image-20231219144841296](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219144841296.png)![image-20231219144901030](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219144901030.png)![image-20231219145020948](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219145020948.png)![image-20231219145033763](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219145033763.png)![image-20231219145500161](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219145500161.png)![image-20231219145558760](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219145558760.png)![image-20231219145611007](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219145611007.png)![image-20231219145638387](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219145638387.png)存储结构  记录序列以顺序表存储<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#define MAXSIZE 20<br>typedef int KeyType;<br>Typedef struct{//定义每个记录(数据元素)<br>    KeyType key;<br>    InfoType otherinfo;<br>}RedType; </p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Typedef struct{<br>    RedType r[MAXSIZE+1];</p><pre><code>int length;</code></pre><p>}SqList;</p><pre class="line-numbers language-none"><code class="language-none">![image-20231219150425125](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219150425125.png)![image-20231219154850400](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219154850400.png)插入排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>for(int i=0; i&lt;=n; i++){<br>    int x = a[i];<br>    for(int j = i-1;j&gt;=0&amp;&amp;x&lt;a[j]; j–){<br>    a[j+1] = a[j];<br>    a[j-1] = x;<br>    }<br>}</p><pre><code>![image-20231219161545875](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219161545875.png)![image-20231219161714098](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219161714098.png)![image-20231219162133843](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231219162133843.png)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20231116</title>
      <link href="/2023/11/16/20231116/"/>
      <url>/2023/11/16/20231116/</url>
      
        <content type="html"><![CDATA[<p> 二十年后,你会因自己没做的事情而更加失望,而不是做过的事情.所以,请解开绳索,驶离安全的港湾,扬帆起航吧</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c语言复习</title>
      <link href="/2023/11/15/c-yu-yan-fu-xi/"/>
      <url>/2023/11/15/c-yu-yan-fu-xi/</url>
      
        <content type="html"><![CDATA[<p> release版本: 发布版,</p><p>debug版本:调试版</p><p>f5启动调试,直接跳到下一个断点处<br>f9打断点</p><p>f10打开调试信息窗口</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安卓的sdk和ndk下载失败</title>
      <link href="/2023/11/12/an-zhuo-de-sdk-he-ndk-xia-zai-shi-bai/"/>
      <url>/2023/11/12/an-zhuo-de-sdk-he-ndk-xia-zai-shi-bai/</url>
      
        <content type="html"><![CDATA[<p>w 我的梯子有问题 ,速度太慢,去官网手动下载都超级慢,不是配置的问题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity初级/中级</title>
      <link href="/2023/11/12/unity-chu-ji-zhong-ji/"/>
      <url>/2023/11/12/unity-chu-ji-zhong-ji/</url>
      
        <content type="html"><![CDATA[<p>Editor project Settings graphics   </p><p>urp global settings </p><p>quality</p><p>可以在已经安装好的引擎上点击添加模块</p><p>图片声音脚本统称为资源文件</p><p>unity中游戏是由场景组成的,就像拍戏一样</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>黑马前端课程学习</title>
      <link href="/2023/11/09/hei-ma-qian-duan-ke-cheng-xue-xi/"/>
      <url>/2023/11/09/hei-ma-qian-duan-ke-cheng-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-CSS从入门到精通"><a href="#HTML-CSS从入门到精通" class="headerlink" title="HTML+CSS从入门到精通"></a>HTML+CSS从入门到精通</h1><h2 id="标签语法"><a href="#标签语法" class="headerlink" title="标签语法"></a>标签语法</h2><p>HTML定义</p><p>HTML 超文本标记语言</p><p>超文本:链接</p><p>标记:也叫标签, 带尖括号的文本</p><p>成对出现, 后面那个带/</p><p>拓展:</p><p>双标签:成对出现的标签</p><p>单标签:只有开始标签,没有结束标签</p><pre class="line-numbers language-none"><code class="language-none">例如:&lt;br&gt;换行&lt;hr&gt;水平线<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> ![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 223526.png)</p><h3 id="VScode安装与插件安装"><a href="#VScode安装与插件安装" class="headerlink" title="VScode安装与插件安装"></a>VScode安装与插件安装</h3><p>下面这个链接是.zip格式的(64位电脑）<br>下载即可用，几秒搞定，直接点Code.exe<br><a href="https://vscode.cdn.azure.cn/stable/379476f0e13988d90fab105c5c19e7abc8b1dea8/VSCode-win32-x64-1.59.0.zip">https://vscode.cdn.azure.cn/stable/379476f0e13988d90fab105c5c19e7abc8b1dea8/VSCode-win32-x64-1.59.0.zip</a><br>插件:<br>最左列最下面那个图标是扩展<br>open in browser<br>Chinese (Simplified) Language Pack for Visual Studio Code</p><h3 id="缩放代码字号"><a href="#缩放代码字号" class="headerlink" title="缩放代码字号"></a>缩放代码字号</h3><p>放大 crtl + 加号<br>缩小 crtl + 减号</p><p>ctrl+B 折叠侧边栏</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 233940.png)</p><h2 id="HTML基本骨架"><a href="#HTML基本骨架" class="headerlink" title="HTML基本骨架"></a>HTML基本骨架</h2><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>网页标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>        网页主体内容    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 234800.png)</p><h2 id="标签的关系"><a href="#标签的关系" class="headerlink" title="标签的关系"></a>标签的关系</h2><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 234921.png)</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释:"></a>注释:</h2><p>VS Code 中,添加/删除注释快捷键:ctrl + /</p><!-- --><h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签:"></a>标题标签:</h2><p>标签名: h1-h6(双标签)</p><p>h1一般一个网页只用一次,用来制作新闻标题或者网页的logo</p><h2 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h2><p>成段文字或者产品描述信息</p><p>标签名 p 双标签</p><p>显示特点:</p><p>自动换到第二行来</p><p>如果有多个p ,不同p之间有空白间隙</p><h2 id="换行与水平线标签"><a href="#换行与水平线标签" class="headerlink" title="换行与水平线标签"></a>换行与水平线标签</h2><p>浏览器不识别代码中的Enter 键换行(无论按了多少个enter都默认当成一个空格)</p><p><code>&lt;br&gt;</code>换行单标签</p><p><code>&lt;hr&gt;</code>水平线标签</p><h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><p>为文本添加特殊格式  以突出重点  </p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-10 002736.png)</p><p>一般情况下开发用左边 </p><p>strong em ins del</p><h2 id="图像标签-基本使用"><a href="#图像标签-基本使用" class="headerlink" title="图像标签 -基本使用"></a>图像标签 -基本使用</h2><p>插入图片</p><p><code>&lt;img src="图片的URL"&gt;</code></p><p>src用于指定图像的位置和名称 是<code>&lt;img&gt;</code>的必须属性</p><p>alt是替换文本,用于图片无法显示时使用</p><p>title标题</p><p>./开头,VS Code有提示功能</p><h2 id="路径-相对和绝对"><a href="#路径-相对和绝对" class="headerlink" title="路径 - 相对和绝对"></a>路径 - 相对和绝对</h2><p>查找文件时,从起点到终点经历的路线</p><p>相对路径 从当前文件位置出发查找目标文件</p><p>.当前文件</p><p>/表示进入文件所在文件夹</p><p>..表示当前文件 的上一个文件夹</p><p>windows默认是\ ,其他是/, 所以统一写为/</p><p>在线网站方式的地址也是一种绝对路径</p><p>绝对路径用在线网址的方式实现友情链接的效果</p><pre class="line-numbers language-none"><code class="language-none">&lt;img src=".\示例图片.jpg"&gt;   &lt;img src="D:/Develop/Pratice/案例/示例图片.jpg"&gt;   &lt;img src="http://www.itheima.com/images/logo.png"&gt;   &lt;img src="D:/Develop/Pratice/案例/示例图片.jpg"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>作用:点击跳转到其他页面</p><p>href属性值是跳转地址,是超链接的必须属性</p><p>如果跳转后仍需原本的窗口留下,我们需要在网址后面加上target = “_blank”</p><p>开发初期不知道超链接的属性跳转地址, href属性写#表示空链接, 不会跳转</p><h2 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h2><p>音频标签</p><p><code>&lt;audio src="音频的URL"&gt;&lt;/audio&gt;</code></p><p>在html5中遇到属性名和属性值一样时, 可以简写为一个单词</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-11 205727.png)</p><p>  <code>&lt;audio src="./media/music.mp3" controls loop autoplay&gt;&lt;/audio&gt;</code></p><h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-11 221444.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-11 221447.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-11 221458.png)</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>布局内容整齐的区域</p><p>列表分类 :无序列表  有序列表 定义列表</p><pre class="line-numbers language-ht" data-language="ht"><code class="language-ht">&lt;ul&gt;//无序&lt;li&gt; &lt;/li&gt;&lt;li&gt; &lt;/li&gt;&lt;li&gt; &lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;//有序&lt;li&gt; &lt;/li&gt;&lt;/ol&gt;&lt;dl&gt;//定义列表&lt;dt&gt;  &lt;/dt&gt;&lt;dd&gt; &lt;/dd&gt;&lt;/dl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-11 225105.png)</p><pre class="line-numbers language-none"><code class="language-none">&lt;table&gt;&lt;tr&gt;&lt;th&gt; &lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表格标签结构</p><pre class="line-numbers language-none"><code class="language-none">&lt;thead&gt;&lt;tbody&gt;&lt;tfoot&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>表格合并单元格</p><p>跨行合并 跨列合并</p><p>1.明确合并目标 , 保留最左最上单元格, 添加属性(取值是数字, 表示需要合并的单元格数)</p><p>​-跨行合并 , 保留最上单元格, 添加属性 rowspan = “x”(这里写要合并的行数)</p><p>​-跨列合并 , 保留最左单元格 , 添加属性 colspan</p><p>删除其他单元格 </p><p>注意,不能跨结构标签合并</p><h2 id="表单-1"><a href="#表单-1" class="headerlink" title="表单"></a>表单</h2><p>作用:收集用户信息</p><p>登录 注册 搜索</p><h3 id="input标签基本使用"><a href="#input标签基本使用" class="headerlink" title="input标签基本使用"></a>input标签基本使用</h3><p>type属性不同 ,则功能不同</p><p><code>&lt;input type="....."&gt;</code></p><table><thead><tr><th>type属性</th><th>说明</th></tr></thead><tbody><tr><td>text</td><td>文本框,用于输入单行文本</td></tr><tr><td>password</td><td>密码框</td></tr><tr><td>radio</td><td>单选框</td></tr><tr><td>checkbox</td><td>多选框</td></tr><tr><td>file</td><td>上传文件</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">&lt;!--特点,输入什么就显示什么--&gt;文本框:&lt;input type="text"&gt;&lt;br&gt;&lt;br&gt;&lt;!--特点:无论输入什么都以.显示--&gt;密码框:&lt;input type="password"&gt;&lt;br&gt;&lt;br&gt;单选框:&lt;input type="radio"&gt;&lt;br&gt;&lt;!--例如用户同意协议那里的使用--&gt;多选框:&lt;input type="checkbox"&gt;&lt;br&gt;上传文件M&lt;input type="file"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>占位文本(框内默认显示)placeholder=”请输入用户名”</p><p>上传文件可以添加一个multiple属性实现多选</p><h3 id="多选框实现默认选项"><a href="#多选框实现默认选项" class="headerlink" title="多选框实现默认选项"></a>多选框实现默认选项</h3><p><code>&lt;input type="checkbox" checked&gt;</code>敲前端代码</p><p>标签: select嵌套option select是下拉菜单整体   option是每一项</p><h2 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h2><pre class="line-numbers language-none"><code class="language-none">城市:&lt;select&gt;    &lt;option&gt;柬埔寨&lt;/option&gt;    &lt;option selected&gt;上哈hi&lt;/option&gt;    //selected是默认选中功能    &lt;/select&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h2><p>作用:多行输入文本的表单控件</p><p>评论,朋友圈………….</p><p><code>&lt;textarea&gt;默认提示文字&lt;/textarea&gt;</code></p><p>实际开发中不用textarea中的属性设置长宽   而是用css</p><p>  <code>&lt;!--右下角有拖拽功能可以放大缩小文本框,不过未来都会禁用掉这些功能--&gt;</code></p><p> <code> &lt;textarea &gt;请输入文本&lt;/textarea&gt;</code></p><h2 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h2><p>作用:网页中 ,某个标签的说明文本</p><p>经验:用label标签绑定文字和表单控件的关系,增大表单控件的点击范围</p><p>增大点击范围</p><p>写法一:</p><p>label标签只包裹内容 ,不包裹表单控件</p><p>设置label标签的for属性和表单控件的id属性相同</p><pre class="line-numbers language-none"><code class="language-none">&lt;input type="radio" id="mam"&gt;&lt;label for="man"&gt;男&lt;/tabel&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>写法二:</p><p><code>&lt;label&gt;&lt;input type="radio" name="gender"&gt; 女&lt;/lable&gt;</code></p><p>支持label标签增大点击范围的表单控件:文本框, 密码框.上传文件,单选框 多选框 下拉菜单 文本域等</p><h2 id="button按钮"><a href="#button按钮" class="headerlink" title="button按钮"></a>button按钮</h2><p><code>&lt;button type=""&gt;按钮&lt;/button&gt;</code></p><p>type属性:</p><p>submit 提交按钮<br>reset 重置<br>button 普通按钮 按上去没反应默认无功能 配合JavaScript使用</p><pre class="line-numbers language-none"><code class="language-none">&lt;!--form表单确定按钮的控制区域 --&gt;   &lt;form action=""&gt;       用户名:&lt;input type="text"&gt;       &lt;br&gt;&lt;br&gt;       密码&lt;input type="password"&gt;       &lt;br&gt;&lt;br&gt;       &lt;!--如果省略type,功能是提交--&gt;       &lt;button type="submit"&gt;提交&lt;/button&gt;       &lt;button type="reset"&gt;重置&lt;/button&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="div和span"><a href="#div和span" class="headerlink" title="div和span"></a>div和span</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!--div是大盒子,独占一行--&gt;&lt;div&gt;aiusdhiuashd&lt;/div&gt;&lt;div&gt;asioludyhasiudhiua&lt;/div&gt;&lt;!--span是小盒子,多个可以占一行--&gt;&lt;span&gt;iaushdiusa&lt;/span&gt;&lt;span&gt;aiosdhasiuh&lt;/span&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符实体"><a href="#字符实体" class="headerlink" title="字符实体"></a>字符实体</h2><pre class="line-numbers language-none"><code class="language-none">空格 &amp;nbps&lt; &amp;lt&gt; &amp;gt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>把要一起发送的数据都放到表单form中来实现</p><h2 id="css来啦（美化）"><a href="#css来啦（美化）" class="headerlink" title="css来啦（美化）"></a>css来啦（美化）</h2><p>css层叠样式表</p><h2 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h2><p>css是一种样式表语言 ，用来描述html文档的呈现（美化内容）</p><p>书写位置 title标签下方添加style双标签 style里面写css代码</p><pre class="line-numbers language-none"><code class="language-none">&lt;title&gt;初识 CSS&lt;/title&gt;  &lt;style&gt;    /*css代码*/    /*选择器{属性名：属性值;}*/    p{      color:red      font-size: 30px    }  &lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="css引入方式"><a href="#css引入方式" class="headerlink" title="css引入方式"></a>css引入方式</h2><p>内部样式表：学习使用<br>css代码写在style标签里面</p><p>外部样式表：开发使用</p><p>css代码写在单独的css文件中（.css)<br>在html中使用link标签引入</p><pre class="line-numbers language-none"><code class="language-none">&lt;link rel="stylesheet" href="./my.css"&gt;&lt;!-- link 引入外部样式表； rel：关系=“样式表” --&gt; &lt;link rel="stylesheet" href="./my.css"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>行内样式：配合JavaScript使用</p><p>css写在标签的style属性值里面</p><p><code>&lt;div style="color:red; font-size:20px;"&gt;</code>这是div标签<code>&lt;/div&gt;</code></p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>作用：查找标签 设置样式</p><p>基础选择器<br>    1<strong>标签选择器</strong><br>使用标签名作为选择器-&gt;选中同名标签设置相同的样式</p><p>例如：p,h1,div,a,img</p><p>2<strong>类选择器</strong><br>查找标签，差异化设置标签的显示效果</p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;/*定义类选择器*/.red{color: red;}&lt;/style&gt;/*使用类选择器*/&lt;div class ="red"&gt;这是div标签&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个标签最多只能加上一个class<br>但是想要多个效果只要这样就行<br><code>&lt;div class="red size"&gt; 这是div标签&lt;/div&gt;</code><br>类名自定义，不要纯数字或中文，尽量用英文命名<br>一个类选择器可以供多个标签使用<br>一个标签可以使用多个类名，类名之间可以使用空格隔开<br>开发习惯：类名见名知意，多个单词可以使用-，例如news-hd//新闻头部<br>3<strong>id选择器</strong><br>查找标签，差异化设置标签的显示效果<br>场景：id选择器一般配合javascript使用 ，很少设置css样式<br>步骤：<br>定义id选择器 -&gt;#id名<br>使用id选择器-&gt;标签添加id=”id名”</p><p>规则：<br>同一个id选择器在一个页面只能使用一次</p><p>4<strong>通配符选择器</strong></p><p>查找页面所有标签，设置相同样式。<br>*,不需要调用，浏览器自动查找页面所有标签，设置相同的样式</p><pre class="line-numbers language-none"><code class="language-none">*{color: red;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>应用场景：许多标签都自带缩进和换行等，我们需要在开发初期将其清除掉然后重新设置</p><h2 id="画盒子"><a href="#画盒子" class="headerlink" title="画盒子"></a>画盒子</h2><p>使用合适的选择器画盒子</p><p>新属性：<br>属性名 作用<br>width   宽度<br>height 高度<br>background-color 背景色</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-14 005836.png)</p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;  .red{    background-color: red;    width: 100px;    height: 100px;  }  .orange{    background-color: orange;    width: 200px;    height:200px;  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字体修饰属性：大小和粗细和倾斜"><a href="#字体修饰属性：大小和粗细和倾斜" class="headerlink" title="字体修饰属性：大小和粗细和倾斜"></a>字体修饰属性：大小和粗细和倾斜</h2><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-14 010727.png)</p><p>字体大小：font-size</p><p>属性值：文字尺寸 ，pc端网页最常用的单位px</p><pre class="line-numbers language-none"><code class="language-none">p{font-size: 30px;}font-szie属性必须有单位，否则不生效谷歌浏览器字体大小默认16px<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字体粗细</p><p>属性名：</p><p>font-weight<br>属性值</p><p>数字（开发使用）<br>正常 400<br>加粗 700</p><p>关键字：</p><p>正常normal<br>加粗bold</p><pre class="line-numbers language-none"><code class="language-none">不加粗font-weight:400;加粗font-weight:700; &lt;div class="red"&gt;div1&lt;/div&gt;  &lt;div class="orange"&gt;div2&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是否倾斜的字体样式<br>作用：清除文字默认的倾斜效果<br>属性名：font-style<br>属性值：</p><p>正常（不倾斜）：normal</p><p>倾斜：italic</p><p>将文中倾斜的属性摆正</p><pre class="line-numbers language-none"><code class="language-none">em{font-style:normal;}div{ font-style:italic;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="行高："><a href="#行高：" class="headerlink" title="行高："></a>行高：</h2><p>作用：设置多行文本的间距</p><p>line-heigt: 10px;</p><p>line-height: 2;(表示当前font-size的2倍)</p><p>行高测量方法：从一行文字的最顶端量到下一行文字的最顶端</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-14 013246.png)</p><h2 id="css实现垂直居中"><a href="#css实现垂直居中" class="headerlink" title="css实现垂直居中"></a>css实现垂直居中</h2><p>行高属性值等于盒子高度属性值</p><p>只适用于单行标签</p><p>多行加行高拉开距离就行了</p><h2 id="字体族"><a href="#字体族" class="headerlink" title="字体族"></a>字体族</h2><p>属性名：font-family</p><p>属性值：字体名</p><pre class="line-numbers language-none"><code class="language-none">font-family:楷体;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>font-family后面跟了一堆属性该怎么办？<br>font-family属性值可以书写多个字体名 ，各个字体名用逗号隔开 ，执行顺序从左往右，哪个生效用哪个</p><p>family属性最后设置一个字体族名，网页开发建议使用无衬西安</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-14 014618.png)</p><h2 id="font复合属性"><a href="#font复合属性" class="headerlink" title="font复合属性"></a>font复合属性</h2><p>使用场景：设置网页文字公共样式</p><pre class="line-numbers language-none"><code class="language-none">div{          斜体  加粗  字号/行高 楷体font:italic 700 30px/2 楷体;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>作用场景：设置网页文字公共样式</p><pre class="line-numbers language-none"><code class="language-none">body{font:...;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>初始化整个网页</p><p>字号和字体值必须书写 否则font属性不生效</p><h2 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h2><p>属性名 :text-indent</p><p>属性值：</p><pre class="line-numbers language-none"><code class="language-none">数字+px数字+em(推荐 1em=当前字号大小  )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="文本对齐方式："><a href="#文本对齐方式：" class="headerlink" title="文本对齐方式："></a>文本对齐方式：</h2><p>作用：控制内容水平对齐方式<br>属性名：text-align</p><pre class="line-numbers language-none"><code class="language-none">属性值  效果left 左对齐（默认）center 居中对齐right 右对齐<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>text-align:center;</p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;p{  /* 本质居中的是文字内容，不是标签 */  text-align:right;}&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文本修饰线："><a href="#文本修饰线：" class="headerlink" title="文本修饰线："></a>文本修饰线：</h2><p>属性名：text-decoration</p><p>none     underline     line-through删除线           overline上划线</p><h2 id="color文字颜色"><a href="#color文字颜色" class="headerlink" title="color文字颜色"></a>color文字颜色</h2><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-14 150824.png)</p><p>网页制作思路：</p><p>从上到下，先整体后局部</p><p>重点内容加粗用strong 非重点内容加粗用font-weight</p><p>text-align是让内容居中（图片文本等</p><h1 id="复合选择器-CSS特性-背景属性-显示模式"><a href="#复合选择器-CSS特性-背景属性-显示模式" class="headerlink" title="复合选择器 CSS特性 背景属性 显示模式"></a>复合选择器 CSS特性 背景属性 显示模式</h1><h2 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h2><p>定义:</p><p>由两个或多个基础选择器,通过不同的方式组合而成</p><p>作用:更准确高效的选择目标元素 (标签)</p><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>可以为儿子,孙子等往下的都实现附魔</p><p>div span{</p><p>}</p><pre class="line-numbers language-none"><code class="language-none">&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h3><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;    div &gt; span{        color:red;    }&lt;/style&gt;&lt;div&gt;&lt;span&gt;儿子span&lt;/span&gt;&lt;p&gt;    &lt;span&gt;孙子span&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h2><p>选中多组标签设置相同的样式</p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;    div,    span,    p{        color: red;    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;iadsojao&lt;/div&gt;    &lt;span&gt;iasdhih&lt;/span&gt;    &lt;p&gt;asdkjashdkjahk&lt;/p&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h2><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;    p.box{        color:red;    }&lt;/style&gt;&lt;body&gt;    &lt;p class="box"&gt;p标签 ,使用了类选择器&lt;/p&gt;    &lt;p&gt;p标签&lt;/p&gt;    &lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>更愿称为伴随类选择器</p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;    .box:hover{        color:green;    }&lt;/style&gt;&lt;body&gt;    &lt;div class="box"&gt;鼠标悬停变色&lt;/div&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="伪类超链接"><a href="#伪类超链接" class="headerlink" title="伪类超链接"></a>伪类超链接</h2><pre class="line-numbers language-none"><code class="language-none">link 访问前visited 访问后hover 鼠标悬停active  点击时激活<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>css属性:hover 鼠标悬停</p><p>如果同时设置以上状态,要按LVHA顺序书写</p><h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p>子类默认继承父级的文字控制属性</p><pre class="line-numbers language-none"><code class="language-none">&lt;style&gt;    body{        color: red;        font-size: 60px;    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;div标签&lt;/div&gt;    &lt;p&gt;p标签&lt;/p&gt;    &lt;!-- 附近有自己属性的会默认使用自己的属性--&gt;    &lt;a href="#"&gt;dasiojdo&lt;/a&gt;&lt;/body&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h2><p>相同的css属性会覆盖 后面的css属性覆盖前面的css属性</p><p>不同的属性会叠加 不同的css属性都生效</p><p>例如写两个相同的标签选择器,后面那个标签选择器会覆盖前面的效果</p><h2 id="css选择器优先级"><a href="#css选择器优先级" class="headerlink" title="css选择器优先级"></a>css选择器优先级</h2><pre class="line-numbers language-none"><code class="language-none">```选择器选中标签范围越大,优先级越低规则:优先级高的样式生效公式: 通配符选择器&lt;标签选择器&lt;类选择器&lt;id选择器&lt;行内选择器 &lt;!important!important提权功能 提高权重/优先级级别到最高,慎用优先级:叠加原理从左到右一次比较个数 同一级个数多大优先级高,如果个数相同,则顺延行内样式 id选择器个数  类选择器个数 标签选择器个数!important权重最高继承权重最低## emmet写法![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-15 150121.png)# 背景图## 背景属性:拆分写法## 网页中,使用背景图实现装饰性的图片效果属性名/值background-image(bgi)/url(背景图URL)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>div{<br>width: 400px;<br>height: 400px;</p><p>bgi:url(./images/1.png)<br>}</p><pre class="line-numbers language-none"><code class="language-none">浏览器中默认背景图图片平铺![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-15 153109.png)## 背景图位置:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>属性名:background-position(bgp)<br>属性值:水平方向位置 垂直方向位置<br>关键字  位置<br>left<br>right<br>center<br>top<br>bottom</p><pre class="line-numbers language-none"><code class="language-none">坐标(数字+px ,正负都可以)关键字的取值写法可以颠倒顺序可以只写一个关键字,另一个方向默认为居中 数字只写一个表示水平方向 垂直方向为居中## 背景图缩放作用:设置背景图大小属性值:`background-size(bgz)`常见属性值关键字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cover 等比例缩放以完全覆盖背景区  图片部分看不见<br>contain 等比例缩放以完全填满 背景区部分空白</p><pre class="line-numbers language-none"><code class="language-none">百分比:盒子尺寸计算图片大小数字+单位(px)## 背景图固定作用:背景不随元素的内容滚动属性名:`background-attachment(bga)属性值:fixed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>body{<br>    background-imag:url(./images/bg.jpg);<br>    background-repeat:no-repeat;<br>    background-attachment:fixed;<br>    background-position:center top;<br>}</p><pre class="line-numbers language-none"><code class="language-none">![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-15 161959.png)## 背景属性:复合写法background: pink url(./images/1.png) no-repeat center bottom/cover## 设置背景图宽高或者表格独占一行之类一定要用display属性的block<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>&lt;style&gt;    a{        display: block;        width: 200px;        height: 80px;        background-color: #3064bb;                text-decoration: none;        text-align:center;        /* 行内属性要使行高和文字高度相等就能使文字属性居中 */        line-height: 80px;        font-size: 18px;    }    a:hover{        background-color: #fff;    }&lt;/style&gt;&lt;body&gt;    &lt;a href="#"&gt;HTML&lt;/a&gt;&lt;a href="#"&gt;CSS&lt;/a&gt;&lt;a href="#"&gt;javascript&lt;/a&gt;&lt;a href="#"&gt;Vue&lt;/a&gt;&lt;a href="#"&gt;React&lt;/a&gt;&lt;/body&gt;</code></pre><pre class="line-numbers language-none"><code class="language-none">制作网页布置大区域都用div## 综合作业2banner图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre><code>&lt;style&gt;    .banner{        height: 500px;        background-color: #fff;        background-image: url(./images/1.jpg);        background-repeat: no-repeat;        background-position: left bottom;        text-align: right;    }    .banner p{        color: #333;        font-size: 20px;    }    .banner h2{        height: 100px;        font-size: 30px;        color: #333;    }    .banner a{        display: inline-block;        width: 40px;        height: 125px;        background-color:red;        font-size: 20px;        /* 超链接消除下划线 */        text-decoration: none;        /* 文本对齐 */        text-align: center;            }&lt;/style&gt;&lt;body&gt;    &lt;div class="banner"&gt;    &lt;h2&gt;让创造产生价值&lt;/h2&gt;    &lt;p&gt;胡大大hi都爱德华i谁的话上帝啊会hi挨打&lt;/p&gt;    &lt;a href="#"&gt;报名&lt;/a&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><pre class="line-numbers language-none"><code class="language-none">## 结构伪类选择器作用:根据元素的结构关系查找元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>&lt;style&gt;    /* 结构伪类选择器 */    /* li:first-child{        background-color: green;    } */    li:last-child{        background-color: green;    }    li:nth-child(2){        background-color: red;    }&lt;/style&gt;&lt;body&gt;    &lt;ul&gt;        &lt;li&gt;1&lt;/li&gt;        &lt;li&gt;2&lt;/li&gt;        &lt;li&gt;3&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;</code></pre><pre class="line-numbers language-none"><code class="language-none">### :nth-child(公式)作用:根据元素的结构关系查找多个元素![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-18 154140.png)## 伪元素选择器创建虚拟元素 ,用来摆放修饰性元素![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-18 154742.png)伪元素选择器不生效要检查content因为默认是行内元素，所以要设置背景宽高时要更改display属性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>&lt;style&gt;    div{        width: 300px;        height: 300px;        background-color: pink;    }    div:before{        content: "老鼠";        display: inline;        width: 100px;        height: 100px;    }    div:after{        content: "大米";        width: 100px;        height: 100px;        display: block;    }    .ps{        display: inline-block;    }&lt;/style&gt;&lt;body&gt;    &lt;div&gt;爱&lt;/div&gt;    &lt;p class="ps"&gt;ps&lt;/p&gt;&lt;/body&gt;</code></pre><pre class="line-numbers language-none"><code class="language-none">## 学会PxCook使用## 盒子模型作用:布局网页,摆放盒子和内容内边距:padding边框线:border外边界: margin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置边框的不同<br>border-top:1px solid 色号;<br>border-right:2px dashed 色号;//dashed虚线<br>border-left:10px solid 色号;<br>border-bottom:5px dotted 色号;</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置内边距<br>padding-top: 10px;<br>padding-right: 20px;<br>padding-bottom: 40px;<br>padding-left: 80px;</p><pre class="line-numbers language-none"><code class="language-none">## padding多值写法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>padding: 10px 20px 30px 40px;//上右下左<br>padding: 10px 20px 30px;//上 左右 下<br>padding: 10px 80px;//上下 左右</p><pre class="line-numbers language-none"><code class="language-none">## 盒子模型-尺寸计算盒子尺寸 = 内容尺寸+padding+border结论：给盒子加border、padding会撑大盒子解决<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>手动做减法，减掉 border/padding的尺寸<br>內减模式：box-sizing:border-box</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>width: 200px;<br>height: 200px;<br>background-color: pink;<br>padding: 20px;<br>box-sizing: border-box;</p><pre class="line-numbers language-none"><code class="language-none">## 版心居中盒子模型 - 外边距作用:拉开两个盒子之间的距离属性名: margin与padding属性值写法.含义相同<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>maigin-left: 100px;//左边距100</p><p>margin:10px 100px;</p><pre class="line-numbers language-none"><code class="language-none">网页中左右对齐,版心居中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>margin: 0 auto;</p><pre class="line-numbers language-none"><code class="language-none">## 清除标签默认的样式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>方法一*{<br>    margin: 0;<br>    padding: 0;<br>    box-sizing: boder-box;<br>}<br>方法二:选中多个标签即使用并集选择器的方法</p><pre class="line-numbers language-none"><code class="language-none">去掉有序/无序列表的项目符号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>li{<br>    list-style: none;<br>}</p><pre><code></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端学习</title>
      <link href="/2023/11/09/qian-duan-xue-xi/"/>
      <url>/2023/11/09/qian-duan-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="1-计算机组成原理"><a href="#1-计算机组成原理" class="headerlink" title="1 计算机组成原理"></a>1 计算机组成原理</h1><h2 id="01计算机是如何计数的"><a href="#01计算机是如何计数的" class="headerlink" title="01计算机是如何计数的"></a>01计算机是如何计数的</h2><p>进制转换</p><p>0x十六进制</p><p>8bit = 1byte</p><p>1024byte = 1kb</p><p>1024kb = 1M</p><h2 id="02电控开关"><a href="#02电控开关" class="headerlink" title="02电控开关"></a>02电控开关</h2><p>一对发射和接受的电路的开闭组成两种状态 0和1</p><p>每对都是2种状态</p><p>n对组合就有2的n次方种</p><h2 id="03继电器"><a href="#03继电器" class="headerlink" title="03继电器"></a>03继电器</h2><p>发射信号的电路发给新添加的组件 新添加的组件再进行处理 中转后发射给接受电路</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 130037.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 130113.png)</p><p>上述设备实现了</p><p>a逻辑为1时 b逻辑为0</p><p>a逻辑为0时  b逻辑为1</p><h3 id="进化-nMOS管和pMOS管"><a href="#进化-nMOS管和pMOS管" class="headerlink" title="进化 nMOS管和pMOS管"></a><strong>进化</strong> nMOS管和pMOS管</h3><h4 id="nMOS管"><a href="#nMOS管" class="headerlink" title="nMOS管"></a>nMOS管</h4><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 130454.png)</p><p>吸住DS1 松开DS0</p><p>G 1  DS 1</p><p>G0 DS0</p><h4 id="pMOS管"><a href="#pMOS管" class="headerlink" title="pMOS管"></a>pMOS管</h4><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 130723.png)</p><p>吸住DS 0   松开DS1   </p><p>G0 DS1</p><p>G1 DS0</p><p> 原理不同 在G端施加相同的电压时候效果不同</p><h4 id="n管p管实现相反器"><a href="#n管p管实现相反器" class="headerlink" title="n管p管实现相反器"></a>n管p管实现相反器</h4><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 132123.png)</p><p>Vin 1  Vout 0</p><p>Vin0 Vout 1 </p><p>计算机输入多个信号返回1个信号</p><h5 id="串联"><a href="#串联" class="headerlink" title="串联"></a>串联</h5><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 132434.png)</p><h5 id="并联"><a href="#并联" class="headerlink" title="并联"></a>并联</h5><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 132514.png)</p><p>两种输入其实互不影响  只有两种都不行的时候DS才为0</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 132741.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 132748.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 132804.png)</p><h3 id="加法的运算"><a href="#加法的运算" class="headerlink" title="加法的运算"></a>加法的运算</h3><h4 id="半加器"><a href="#半加器" class="headerlink" title="半加器"></a>半加器</h4><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 134843.png)</p><p>输出进位和加法位两种 </p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 135122.png)</p><p>使用全加器(半加器多了一个进位输入)进行组合就可以得到一个加法器, </p><h2 id="8-ALU选择器"><a href="#8-ALU选择器" class="headerlink" title="8 ALU选择器"></a>8 ALU选择器</h2><h3 id="上述电路均有输出-但是每一次的输出仅与上一次的输入有关-与输出无关"><a href="#上述电路均有输出-但是每一次的输出仅与上一次的输入有关-与输出无关" class="headerlink" title="上述电路均有输出, 但是每一次的输出仅与上一次的输入有关 与输出无关"></a>上述电路均有输出, 但是每一次的输出仅与上一次的输入有关 与输出无关</h3><p>输入的值不同产出不同的状态值输出</p><p>数据选择器也叫控制信号(用信号选择器来组成二进制数字)</p><h2 id="9寄存器"><a href="#9寄存器" class="headerlink" title="9寄存器"></a>9寄存器</h2><h3 id="锁存器"><a href="#锁存器" class="headerlink" title="锁存器"></a>锁存器</h3><p>RAM</p><h2 id="10指令"><a href="#10指令" class="headerlink" title="10指令"></a>10指令</h2><p>指令RAM</p><p>数据RAM</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 164114.png)</p><p>![3](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 164713.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 164846.png)</p><h2 id="11cpu三个周期"><a href="#11cpu三个周期" class="headerlink" title="11cpu三个周期"></a>11cpu三个周期</h2><p>振荡器</p><p>计算机运行过程中,电压是不断变化的</p><p>cpu工作的支撑</p><h3 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h3><p>1GHz 1秒十亿个时钟周期</p><p>2.4GHz 1秒23亿个时钟周期![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 173706.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 173824.png)</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-09 174240.png)</p><h2 id="13-cpu密集和IO密集"><a href="#13-cpu密集和IO密集" class="headerlink" title="13 cpu密集和IO密集"></a>13 cpu密集和IO密集</h2><h2 id="14-JS异步IO"><a href="#14-JS异步IO" class="headerlink" title="14 JS异步IO"></a>14 JS异步IO</h2><p>简述浏览器怎么和后台交换数据的</p><p>Ajax   异步的javascript</p><p>Ajax包含一下几个步骤<br>1.创建Ajax对象<br>2.发出http请求<br>3.接收服务器传回的数据</p><p>1.创建Ajax对象</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token literal-property property">xhr</span><span class="token operator">:</span><span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>XMLHttpRequest<span class="token punctuation">)</span><span class="token punctuation">{</span>    xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token comment">//为确保浏览器的兼容性</span>    xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActiveXobject</span><span class="token punctuation">(</span><span class="token string">"Microsoft.XMLHTTP"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.发送HTTP请求</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span> <span class="token string">'http://127.0.0.1:4523/ml/1231959-0-default/api/douyin'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>open()第一个参数指定发送请求的方式 , 这个字符串不区分大小写 ,但是通常使用大写字母 , “GET”和”POST”广泛支持</p><p>第二个参数是URL,相对于执行代码的当前页面,且只能向同一个域中使用相同的端口和协议的URL发送请求 , 如果URL与启动请求的页面有任何差距都会引发安全错误</p><p>第三个参数是表示是否异步发送请求的布尔值, 如果不填写 , 默认为true表示异步发送 </p><p>3.接收服务器传回的数据</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token literal-property property">resonseText</span> <span class="token operator">:</span> <span class="token function">作为响应主体被返回的文本</span><span class="token punctuation">(</span>文本形式<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c#基础</title>
      <link href="/2023/11/07/c-ji-chu/"/>
      <url>/2023/11/07/c-ji-chu/</url>
      
        <content type="html"><![CDATA[<p>c#基础中的基础</p><p>在vs中创建控制台应用.net framework   </p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">Console.WriteLine("Hello World!");Console.ReadKey();int i = 56;Console.WriteLine("HelloWorld! "+ i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>函数和c++一样 都是在类里面 但是记得加上static(因为在静态函数中调用的,所以加上static)</p><p>数组定义</p><p>int[] intArray = new int[5]{1, 2 ,3, 4, 5};</p><p>列表:</p><p>List<int>  intList = new List<int>()  {1, 2, 3};</int></int></p><p>插入删除 : intList.Add(5); initList.Remove(1);</p><p>循环遍历任何集合(因此也适用于数组和列表)</p><p>foreach(int i int intList){<br>     Console.WriteLine(i);//一次写一行 自动换行<br>}</p><p><strong>等价于</strong></p><p>for(int i=0; i&lt;intList.Count; i++){</p><p>Console.WriteLine(i+ “ “+ intList[i]);</p><p>}</p><p>防止应用程序一闪而过 使用Console.ReadKey();</p><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">//This is a comment/* *sdsad *sdsdaasda **/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h4><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">enum PlayerState{    Idle,    Attacking}static PlayerState playerState;switch(playerState) {    case PlayerState.Idle:        break;    case PlayerState.Attacking:        break;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity初学</title>
      <link href="/2023/11/07/unity-chu-xue/"/>
      <url>/2023/11/07/unity-chu-xue/</url>
      
        <content type="html"><![CDATA[<p> unity的窗口可以随意拖动</p><p>从一个项目的名字那里可以创建新的东西出来</p><p>有视角切换 scene 或者 game视角</p><p>hierarchy(层次结构) 存储了游戏的对象 </p><p>可以在层次结构中直接选择对象然后按f聚焦过去</p><p>点击一个对象会出现一个inspector 显示对象和它的组件</p><p>左键单击选择对象 右键可以查看四周(世界位置不变视角变)</p><p>右键+alt 世界位置围着按住的地方变</p><p>鼠标滚轮放大缩小</p><p>平移:鼠标中键或者左上角</p><p>左上角有工具栏 :<strong>平移 轴动 旋转 放缩 矩形工具 qwert</strong> Y是组合</p><p><strong>游戏对象是游戏的核心</strong>  unity中可以添加各种组件组合游戏对象</p><p>每个游戏对象都有一个transform(存储位置 旋转和缩放)</p><p>为了能看见对象要添加视觉组件(在inspector中添加网格组件mesh filter, 再用网格渲染器mesh render进行渲染)</p><p>材质meterial 定义了对象的渲染方式</p><p><strong>我们可以进入项目文件夹 即projict中的assets资产里面创建</strong>(创建资产create material)</p><p>unity可以不断添加组件来丰富游戏对象的功能</p><p>rigid body组件会给物体物理效果</p><p>对象的组件定义了对象的外观和形状    也可以自己写脚本定义组件(在文件的asset资产中创建c#脚本)</p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本:"></a>脚本:</h3><pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">每一帧更新前调用一次start()  并且每帧调用一次update()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要注意如何扩展monobehvior(unity基类) 如果您希望使用此类作为组件 ,所有脚本必须扩展该类</p><h3 id="将3d转化成2d"><a href="#将3d转化成2d" class="headerlink" title="将3d转化成2d"></a>将3d转化成2d</h3><p>去掉mesh render 和mesh filter<br>使用sprite render</p><p>可以在相机的inspector中切换主屏幕的视角 点击projection(有透视perspective 和正交投影两种orthographic(平面2d))</p><p>我们可以在asset中创建不同的scene作为游戏的不同场景</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>游戏动画设计</title>
      <link href="/2023/11/04/you-xi-dong-hua-she-ji/"/>
      <url>/2023/11/04/you-xi-dong-hua-she-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="1-静物渲染"><a href="#1-静物渲染" class="headerlink" title="1.静物渲染"></a>1.静物渲染</h1><h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h2><p>w 移动 e旋转 r缩放</p><p>m材质编辑器的</p><p>精简模式  漫反射控制物体颜色</p><p>正视图f 顶视图t  相机视角c</p><p>渲染设置</p><p>shift+f显示相机尺寸</p><p>f9渲染 (打开时是随机挑出一个渲染的 然后自己找到相机角度进行渲染)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>整数二分与浮点数二分的不同</title>
      <link href="/2023/10/29/zheng-shu-er-fen-yu-fu-dian-shu-er-fen-de-bu-tong/"/>
      <url>/2023/10/29/zheng-shu-er-fen-yu-fu-dian-shu-er-fen-de-bu-tong/</url>
      
        <content type="html"><![CDATA[<p> 在浮点数二分中,我们左右逼近都是用</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">l = mid;r = mid;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>的方式</p><p>而在整数二分中我们往往会像这样左右逼近</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">求数的最左边时mid = l+r;r = mid;l = mid+1;求数的最右边时mid = l+r+1 &gt;&gt; 1;l = mid;r = mid-1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么是什么原因让整数二分的左右边界如此麻烦呢?</p><p>浮点数二分时,我们往往求的是某个数保留几位小数</p><p>而整数二分时我们要求满足某个性质的数,这样在二分到最后两个数时就容易出问题了<br>我们来看,不对左右边界处理的情况下是这样的</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//求数的最左边时mid = l+r;l = mid;r = mid;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在l = 0, r = 1的情况下, l永远比r小,此时二分陷入死循环中</p><p>其实此时就是精度问题,整数除法的性质决定了一定会丢失一个1,而这个1在最后两个数二分时启到了关键性作用,没有这个进位的1就永远死循环,有了这个1就可以结束循环,所以对左右边界进行特殊处理,其实说到这里,你应该已经知道了不用对边界处理的方法,那就是改变循环的条件 ,使之变为<code>r&gt;l-1;</code></p><p>而浮点数二分则没有这个问题 浮点数的循环退出的条件就是它的精度逼近到一定程度就可以了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>方向</title>
      <link href="/2023/10/25/fang-xiang/"/>
      <url>/2023/10/25/fang-xiang/</url>
      
        <content type="html"><![CDATA[<p> 3c 渲染 逻辑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>10-25日记</title>
      <link href="/2023/10/25/10-25-ri-ji/"/>
      <url>/2023/10/25/10-25-ri-ji/</url>
      
        <content type="html"><![CDATA[<p> 时间过得太快了,开学是9.1号,现在是10月25号如今我似乎长进不大</p><p>我的目标应该是gamejam竞赛和算法相关的竞赛和计算机基础知识</p><p>我学习的速度太慢了,每天还花费很多额外的时间在不必要的事情上,我觉得我完全可以把这些精力花在了解其他的游戏玩法上</p><p>还有就是每天可以来看一遍面经了解大概的方向,别的不用管</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法基础课</title>
      <link href="/2023/10/24/suan-fa-ji-chu-ke/"/>
      <url>/2023/10/24/suan-fa-ji-chu-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>主要思想:分治</p><p>1.确定分界点</p><p>2.调整范围(点左小于等于点,点右大于等于右)</p><p>3.递归左右两端</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void quick_sort(int q[], int l, int r){    if (l &gt;= r) return;    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];        while (i &lt; j)    {        do i ++ ; while (q[i] &lt; x);        do j -- ; while (q[j] &gt; x);        if (i &lt; j) swap(q[i], q[j]);    }    quick_sort(q, l, j), quick_sort(q, j + 1, r);//用j的原因是防止一边不动,另一边yi'zi    //quick_sort(q, l, i-1) quick_sort(q, i, r)    //边界点本质区别就在于你能不能在区间内部把区间掰成左右两块    定点    按点左右排序    左右递归    }//用两个辅助数组即可解决这个问题,一个存小于基准数的 一个存大于等于基准数的 ,最后遍历数组存入该存的地方,最后这里比较类似于归并排序的归并过程 ///////////////////////////////////////////////////#include&lt;iostream&gt;using namespace std;void sort(int a[], int l, int r){    if(l&gt;=r){        return ;    }    int mid = l+r &gt;&gt;1;    int i = l-1, j = r+1;    while(i&lt;j){        do i++; while(a[i] &lt; a[mid]);        do j--; while(a[i] &gt; a[mid]);        if(i&lt;j) swap(a[i], a[j]);    }    sort(a, l, j);    sort(a, j+1, r);    }const int N = 1e6+10;int a[N], n;int main(){    cin &gt;&gt; n;    for(int i=0; i&lt;n; i++){        scanf("%d", &amp;a[i]);    }    sort(a , 0, n-1);    for(int i=0; i&lt;n; i++)    printf("%d ", a[i]);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="第k个数"><a href="#第k个数" class="headerlink" title="第k个数"></a>第k个数</h1><p>给定一个长度为 n� 的整数数列，以及一个整数 k�，请用快速选择算法求出数列从小到大排序后的第 k� 个数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n� 和 k�。</p><p>第二行包含 n� 个整数（所有整数均在 1∼1091∼109 范围内），表示整数数列。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示数列的第 k� 小数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤1000001≤�≤100000,<br>1≤k≤n</p><p>10<br>49 59 88 37 98 97 68 54 31 3</p><pre class="line-numbers language-none"><code class="language-none">3 31 37 49 54 59 68 88 97 98<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="c-加速输入输出"><a href="#c-加速输入输出" class="headerlink" title="c++加速输入输出"></a>c++加速输入输出</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int main(){    ios::sync_with_stdio(flase);    cin.tie(0);    cout.tie(0);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>1.确定分界点 l+r &gt;&gt; 1;</p><p>2.递归排序左右</p><p>3.合并</p><p>快排是不稳定的(把它变成二元组就行了,没啥用) 归并是稳定 的</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge_sort(int a[], int l, int r){if(l&gt;= r) return ;    int mid = l+r&gt;&gt;1;    merge_sort(a ,l, mid);    merge_sort(a, mid+1, r);    int k = 0, i = l, j = mid+1;    while(i&lt;=mid&amp;&amp;j&lt;=r){        if(a[i] &lt;= a[j]) temp[k++] = a[i++];        else temp[k++] = a[k++];    }     while(i&lt;=mid) temp[k++] = a[i++];    while(j&lt;=r) temp[j++] = a[j++];    for(int i=l, j = 0; i&lt;=r; i++, j++) a[i] = temp[j];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int temp[N];void ms(int a[], int l, int r){    int mid = l+r &gt;&gt;1    ms(a, l, mid);    ms(a, mid+1 ,r);    int k = 0, i = l, j = mid+1;    while(i&lt;=mid &amp;&amp; j&lt;=r)         if(a[i] &lt;= a[j]) temp[k++] = a[i++];    else temp[k++] = a[j++];    while(i&lt;=mid) temp[k++] = a[i++];    while(j&lt;=r)  temp[k++] = a[j++];for(int m = 0, i=l;i&lt;=r; i++, m++) a[i] = temp[m];    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>快排整体排序逐渐优化到局部</p><p>归并局部排序优化到整体</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N = 1e6+10;int n;int a[N], temp[N];void sort(int a[], int l, int r){    if(l&gt;=r) return ;    int mid = l+r &gt;&gt; 1;    sort(a, l, mid);    sort(a, mid+1, r);    int k = 0, i = l, j = mid+1;    while(i&lt;=mid&amp;&amp;j&lt;=r){        if(a[i] &lt;= a[j]) temp[k++] = a[i++];        else temp[k++] = a[j++];            }    while(i&lt;=mid) temp[k++] = a[i++];    while(j&lt;=n) temp[k++] = a[j++];    for(int o = 0, p= l; p&lt;=r; p++, o++)    a[p] = temp[o];}int main(){    scanf("%d", &amp;n);    for(int i=0; i&lt;n; i++){        scanf("%d", &amp;a[i]);    }    sort(a, 0, n-1);    for(int i=0; i&lt; n; i++)    printf("%d ", a[i]);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="整数二分的两种模板"><a href="#整数二分的两种模板" class="headerlink" title="整数二分的两种模板"></a>整数二分的两种模板</h1><p>二分本质并不是单调性</p><p>//我把自己学习的情况太理想化了 我会发呆走神还会在难点困惑很久</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool check(int x);//检查是否具有某种性质a[mid] &gt;= x;//区间被划分成向偏小向即r = mid;即[l, mid] [mid+1, r];int bsearch_1(int l, int r){    while(l&lt;r){    int mid = l+r &gt;&gt; 1;    if(check(mid)) r = mid;    else l = mid+1;    }    return l;}int bsearch_2(int l, int r){while(l&lt;r)    {        int mid = l+r+1 &gt;&gt; 1;        if(check(mid)) l = mid;        else r = mid-1;    }    return l;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给定一个按照升序排列的长度为 n� 的整数数组，以及 q� 个查询。</p><p>对于每个查询，返回一个元素 k� 的起始位置和终止位置（位置从 00 开始计数）。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n� 和 q�，表示数组长度和询问个数。</p><p>第二行包含 n� 个整数（均在 1∼100001∼10000 范围内），表示完整数组。</p><p>接下来 q� 行，每行包含一个整数 k�，表示一个询问元素。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 q� 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p><p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤1000001≤�≤100000<br>1≤q≤100001≤�≤10000<br>1≤k≤100001≤�≤10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre class="line-numbers language-none"><code class="language-none">6 31 2 2 3 3 4345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre class="line-numbers language-none"><code class="language-none">3 45 5-1 -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>二分模板一定要保证有解,定义性质要有边界的 ,而二分一定可以找出边界</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N = 1e5+5;int n, q;int a[N];int main(){    cin &gt;&gt; n &gt;&gt; q;    for(int i=0; i&lt;n; i++) cin &gt;&gt; a[i];    while(q--){        int key;        cin &gt;&gt; key;        int l = 0, r = n-1;        while(l&lt;r){            int mid = l+r &gt;&gt; 1;            if(key &lt;= a[mid]) r = mid;            else l = mid+1;                    }        if(a[l]!=key) cout &lt;&lt; "-1 -1" &lt;&lt; endl ;        else {            cout &lt;&lt; l &lt;&lt;' ';            l = 0, r = n-1;            while(l&lt;r){                int mid = l+r+1 &gt;&gt; 1;                if(key&gt;= a[mid]) l = mid;                else r = mid-1;            }            cout &lt;&lt; r &lt;&lt;' ' &lt;&lt; endl;         }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="浮点数求平方根"><a href="#浮点数求平方根" class="headerlink" title="浮点数求平方根"></a>浮点数求平方根</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int main(){    double x;    cin &gt;&gt; x;    double l=0, r = x;    while(r-l&gt;1e-8){//这里注意保留几位小数就要在相减时多1e-2;        double mid = l+r &gt;&gt; 1;        if(x &lt;= mid*mid) r = mid;        else l = mid;   }        printf("%lf", l);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="高精度-加减乘除"><a href="#高精度-加减乘除" class="headerlink" title="高精度(加减乘除)"></a>高精度(加减乘除)</h1><pre class="line-numbers language-none"><code class="language-none">A+B 1e6 1e6A-BA*b 1e6 小的数A/b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>大整数如何存呢:</p><p>存到数组里面</p><h1 id="加"><a href="#加" class="headerlink" title="加:"></a>加:</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int plus(int num[], long long a, long long b){    int temp1[N];    int temp2[N];    int t= 0;    int i=0, j = 0;    while(1){        if(t = a%10){            temp1[i++] = t;            a/=10;        }else break;    }    while(1){        if(t = b%10){            temp1[j++] = t;            b/=10;        }else break;    }    int k=0, m=0, n=0;    int up = 0;        for(k=0, m=0, n=0; m&lt;i&amp;&amp;n&lt;j ;k++,m++, n++){                num[k] = (temp1[m] + temp2[n]+up)%10;        up = (temp1[m] + temp2[n]+up)/10;    }        while(m&lt;i){        num[k] = (temp1[m]+up) %10;            k++, m++;        up = (temp1[m]+k)/10;    }    while(n&lt;j){        num[k] = (temp1[n]+up) %10;        k++ , j++;        up = (temp1[n]+k)/10;    }    return k;}while(k--){    cout &lt;&lt; num[k];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 1e6+10;vector&lt;int&gt; add(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B){    int t = 0;    vector&lt;int&gt; num;    int i=0;    while(i&lt;A.size() || i&lt;B.size()){        if(i&lt;A.size()) t+=A[i];        if(i&lt;B.size()) t+=B[i];        num.push_back(t%10);        t/=10;        i++;    }    return num;}int main(){    string a,b;    vector&lt;int&gt; A,B;    for(int i=a.size()-1; i&gt;=0; i--) A.push_back(a[i]-'0');    for(int i=b.size()-1; i&gt;=0; i--) A.push_back(b[i]-'0');    vector&lt;int&gt; num = add(A, B);    for(auto x : num) cout &lt;&lt; x &lt;&lt; ' ';}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;ios::sync_with_stdio(false);//原理使标准输入输出不同步 提高cin/cout效率//副作用不能使用scanf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B){    if(A.size() &lt; B.size()) return add(B, A);    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i&lt;A.size(); i++){        if(i&lt;B.size()) t+=B[i];        t+=A[i];        C.push_back(t%10);        t/=10;    }    if(t) C.push_back(t);    return C;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool cmp(A, B){    if(A.size()!=B.size()) return A.size() &gt; B.size();    else{        for(int i=A.size(); i&gt;=0; i--){            if(A[i]!=B[i]) return A[i] &gt; B[i];        }    }}vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B){    vector&lt;int&gt; C;    int t = 0;    for(int i=0; i&lt;A.size(); i++){        t = A[i]-t;        if(i&lt;B.size()) t-=B[i];        C.push_back((t+10)%10);        if(t&lt;0) t = 1;        else t = 0;    }    while(C.size()&gt;1 &amp;&amp; C.back() == 0) C.pop_back();    return C;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b){    vector&lt;int&gt; C;    int t = 0;    for(int i=0; i&lt;A.size() || t; i++)    {        if(i&lt;A.size()) t+= A[i] *b;        C.push_back(t%10);        t/=10;    }    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) c.pop_back();        return C;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r){    vector&lt;int&gt; C;    r = 0;    for(int i=A.size(); i&gt;=0; i++){        r = r*10 + A[i]];        C.push_back(r/b);        r %=b;    }    reverse(C.begin(), C.end());    while(C.size()&gt;1 &amp;&amp; C.back() == 0)C.pop_back();    return C;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B){    if(A.size() != B.size()) return A.size() &gt; B.size();    else{        for(int  i = A.size()-1; i&gt;=0 ; i++){            if(A[i]!=B[i]) return A[i] &gt; B[i];         }    }    return true;}vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B){    vector&lt;int&gt; C;    int t = 0;    for(int i=0; i&lt;A.size(); i++){        t = A[i]- t;        t-=B[i];        C.push_back((t+10)%10);        if(t&lt;0) t = 1;        else t = 0;    }    while(C.size()&gt;1 &amp;&amp; C.back() == 0) C.pop_back();    return C;}int main(){    string a, b;    vector&lt;int&gt; A, B;    cin &gt;&gt; a &gt;&gt; b;    for(int i=a.size()-1;i&gt;=0; i++) A.push_back(a[i]-'0');    for(int i=B.size()-1;i&gt;=0;i++) B.push_back(b[i]-'0');    vector&lt;int&gt; C;    if(cmp(A,B)) C = sub(A, B);    else C = sub(B, A),cout &lt;&lt; '-';    for(int i=C.size()-1;i&gt;=0; i++)    cout &lt;&lt; C[i];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i = 0; i&lt;=n; i++) s[i] = s[i-1] +a[i];while(m--){    int l, r;    scanf("%d%d", &amp;l, &amp;r);    printf("%d\n", s[r]-s[l-1]);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="子矩阵的和"><a href="#子矩阵的和" class="headerlink" title="子矩阵的和"></a>子矩阵的和</h1><p>输入一个 n� 行 m� 列的整数矩阵，再输入 q� 个询问，每个询问包含四个整数 x1,y1,x2,y2�1,�1,�2,�2，表示一个子矩阵的左上角坐标和右下角坐标。</p><p>对于每个询问输出子矩阵中所有数的和。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 n，m，q</p><p>接下来 n� 行，每行包含 m� 个整数，表示整数矩阵。</p><p>接下来 q� 行，每行包含四个整数 x1,y1,x2,y2�1,�1,�2,�2，表示一组询问。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 q� 行，每行输出一个询问的结果</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N = 1e4;int a[N][N], s[N][N];int n, m, q;int main(){        cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;        for(int i=1; i&lt;=n; i++){            for(int i=1; i&lt;=m; i++){                cin&gt;&gt; a[i][j];                s[i][j] = s[i-1][j]+s[i][j-1]+a[i][j]-s[i-1][j-1];            }        }        while(q--){            int x1,y1, x2, y2;            cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;            cout &lt;&lt; s[]        }        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>构建差分数组</p><p>对差分数组进行操作,最后输出前缀和</p><p>利用等价关系,将复杂的转化成简单的</p><p>差分矩阵</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int x1, y1, x2, y2;int n, m, q;const int N = 1010;int a[N][N], b[N][N];void insert(int x1, int y1, int x2, int y2, int c){//差分数组(预设差分和前缀和一开始都是0)其实只有一种操作 插入    b[x1][y1]+=c;    b[x1][y2+1]-=c;    b[x2+1][y1]-=c;    b[x2+1][y2+1] +=c;           }int main(){    int n ,m;    cin &gt;&gt; n &gt;&gt; m;    for(int i=1; i&lt;=n; i++){        for(int j = 1; j&lt;=m; j++){            cin &gt;&gt; a[i][j];            insert(i, j, i, j, a[i][j]);        }    }        while}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="求最长连续不重复子序列"><a href="#求最长连续不重复子序列" class="headerlink" title="求最长连续不重复子序列"></a>求最长连续不重复子序列</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;//双指针算法using namespace std;int n;const int N = 1e5;int a[N], s[N];int main(){    cin &gt;&gt; n;    for(int i=0; i&lt;n; i++)cin &gt;&gt; a[i];    int res = 0;    for(int i=0, j=0; i&lt;n; i++){        s[a[i]]++;        while(s[a[i]] &gt; 1) s[a[j++]]--;//正好会停在第一个重复的数的后面 非常的巧妙        res = max(res, i-j+1);            }   cout &lt;&lt; res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 00。</p><p>现在，我们首先进行 n� 次操作，每次操作将某一位置 x� 上的数加 c�。</p><p>接下来，进行 m� 次询问，每个询问包含两个整数 l� 和 r�，你需要求出在区间 [l,r][�,�] 之间的所有数的和。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n� 和 m�。</p><p>接下来 n� 行，每行包含两个整数 x� 和 c�。</p><p>再接下来 m� 行，每行包含两个整数 l� 和 r�。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 m� 行，每行输出一个询问中所求的区间内数字和。</p><p>//这里自己实现一下unique函数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt;::iteritor unique(vector&lt;int&gt; &amp;A){    int j = 0;    for(int i=0; i&lt;A.size() ; i++){        if(!i || a[i]!=a[i-1]) a[j++] = a[i];    }            return A.begin+j;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 3e5 + 5;vector&lt;PII&gt; add, limit;vector&lt;int&gt; alls;int a[N], s[N];int find(int x) {int l = 0, r = alls.size() - 1;while (l &lt; r) {int mid = l + r &gt;&gt; 1;if (alls[mid] &gt;= x)r = mid;elsel = mid + 1;}return r + 1;}int main() {int n, m;cin &gt;&gt; n &gt;&gt; m;while (n--) {int x, c;cin &gt;&gt; x &gt;&gt; c;add.push_back({x, c});alls.push_back(x);}while (m--) {int l, r;cin &gt;&gt; l &gt;&gt; r;limit.push_back({l, r});alls.push_back(l);alls.push_back(r);}sort(alls.begin(), alls.end());alls.erase(unique(alls.begin(), alls.end()), alls.end());for (auto temp : add) {int x = find(temp.first);a[x] += temp.second;}for (int i = 1; i &lt;= alls.size(); i++) {s[i]  = a[i] + s[i - 1];}for (auto temp : limit) {int l = find(temp.first);int r = find(temp.second);cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; alls;sort(alls.begin(),alls.end());all.erase(unique(alls.begin(), alls.end()), alls.end());//二分法求出对应离散化的值int find(int x){//找到大于等于x的第一个数    int l = 0, r = alls.size()-1;    while(l&lt;r)    {int mid = l+r &gt;&gt; 1;        if(a[mid] &gt;= x) r = mid;        else l = mid+1;    }    return r;//(或者r+1 ,根据题目映射来看);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>差分/前缀和          最多有1e5,再多的就要上离散化了</p><p>离散化适合数据范围大但是数据不连续的</p><p>c++中用vector做离散化</p><h2 id="求区间和"><a href="#求区间和" class="headerlink" title="求区间和:"></a>求区间和:</h2><p>对一段很长的数轴1e9实现插入操作 然后再求某段区间数的和(起初时候所有数都是0)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实现uique去重算法</p><p>把区间合并 快速把有交集的区间进行合并</p><p>两个区间只有端点相交的话也算可以合并</p><p>(类似球球大作战里面球变大变小?)</p><p>从前往后扫描一个区间</p><p>一次维护一个区间 直到下一个区间在后面就中断维护</p><p>区间维护用pair&lt;int, int&gt;</p><h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII vector&lt;PII&gt; alls;void merge(vector&lt;PII&gt; &amp;alls){    vector&lt;PII&gt; all;    int l = -2e9, r = -2e9;    for(auto temp : alls)         if(r &lt; temp.first){            if(l!=-2e9) all.push_back({l ,r});            l = temp.first, r = temp.second;        }else r = max(r, temp.second);    if(l != -2e9 ) all.push_back({l, r});        alls = all;}int main(){    int n;    while(n--){        int l, r;        cin &gt;&gt; l &gt;&gt; r;        alls.push_back({l, r});    }    sort(alls.begin(), alls.end());    merge(alls);    cout &lt;&lt; alls.size();    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第k个数-1"><a href="#第k个数-1" class="headerlink" title="第k个数"></a>第k个数</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N = 1e5+10;int a[N];int qs(int l, int r, int k){    if(l&gt;=r) return q[l];    int i= l-1, j = r+1;    int x = a[l+r &gt;&gt; 1];    while(i&lt;j){        while(a[++i] &lt; mid);        while(a[--j] &gt; mid);        if(i&lt;j) swap(a[i], a[j]);    }    if(j-l +1&gt;= k) return qs(l, j, k);    else return qs(j+1, r, k-(j-l+1));    }int main(){    int n, k;    cin &gt;&gt; n &gt;&gt; k;    for(int i=0; i&lt;n; i++) cin &gt;&gt; a[i];    cout &lt;&lt; qs(0, n-1, k);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="归并排序的应用-求逆序数的数量"><a href="#归并排序的应用-求逆序数的数量" class="headerlink" title="归并排序的应用:求逆序数的数量"></a>归并排序的应用:求逆序数的数量</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef long long LL;LL res = 0;int a[N],temp[N];void ms(int a[], int l, int r){    if(l &gt;= r) return ;    int mid = l+r &gt;&gt; 1;    ms(a, l, mid);    ms(a, mid+1, r);    int i = l, j = mid+1, k = 0;    while(i&lt;=l&amp;&amp; j&lt;=r) {        if(a[i] &lt;= a[j]) temp[k++] = a[i++];        else{            res+=mid-i+1;            temp[k++] = a[j++];        }    }   while(i&lt;=l)    temp[k++] = a[i++];   while(j&lt;=r) temp[k++] = a[j++];    for(int i=l, j = 0; i&lt;=r; i++) a[i] = temp[j];        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二分法的应用之-数的三次方根"><a href="#二分法的应用之-数的三次方根" class="headerlink" title="二分法的应用之:数的三次方根"></a>二分法的应用之:数的三次方根</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//cout输出浮点数默认保留六位有效数字int main(){    double x;    cin &gt;&gt; x;    int l = -100, r = 100;    while(r-l&gt;=1e-8){        double mid = (l+r)/2;        if(mid*mid*mid &gt;= x) r = mid;        else  l = mid;    }    cout &lt;&lt; r;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="用数组模拟链表邻近表-栈队列"><a href="#用数组模拟链表邻近表-栈队列" class="headerlink" title="用数组模拟链表邻近表 栈队列"></a>用数组模拟链表邻近表 栈队列</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//动态链表非常慢 new Node或者直接初始化n个结点<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-单链表-邻接表-存储图和树"><a href="#1-单链表-邻接表-存储图和树" class="headerlink" title="1.单链表 : 邻接表   存储图和树"></a>1.单链表 : 邻接表   存储图和树</h3><h3 id="2-双链表-优化某些题目"><a href="#2-双链表-优化某些题目" class="headerlink" title="2.双链表 : 优化某些题目"></a>2.双链表 : 优化某些题目</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N = 100010;int head, e[N], ne[N], idx;void init(){    head = -1;    idx = 0;}int main(){    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h1><pre class="line-numbers language-none"><code class="language-none">void BInsertSort(Sqlist &amp;L){for(i = 2; i&lt;=L.length; ++i){L.r[0] = L.r[i];//当前元素存到哨兵位置low = 1; high = i-1;while(low &lt;= high){mid = (low+high)/2;if(L.r[0].key &lt; L.r[mid].key) high = mid-1;else low = mid+1;}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231220191745377.png" alt="image-20231220191745377"></p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231220191831121.png" alt="image-20231220191831121"></p><pre class="line-numbers language-none"><code class="language-none">void ShellSort(Sqlist &amp;L, int dlta[], int t){//按照增量序列dlta 0 ... t-1对顺序表做希尔排序 for(k = 0; k&lt;t; k++){ShellInsert(L, dlta[k]);//一趟增量为dlta[k]的插入排序}}void ShellInsert(Sqlist &amp;L, int dk){for(i=dk+1; i&lt;=L.length; i++){if(r[i] &lt; r[i-dk]){r[0] = r[i];for(j = i-dk; j&gt;0 &amp;&amp; (r[0] &lt; r[j]); j = j-dk){r[j+dk] = r[j];}r[j+dk] = r[0];}}} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>冒泡排序</p><pre class="line-numbers language-none"><code class="language-none">for(int i = 1; i&lt;n; i++){for(int j = 0;j&lt;n-i;j++ ){if(a[j+1] &gt; a[j]){swap(a[j], a[j+1]);}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">for(int i=0; i&lt;n-1; i++){int min = i;for(int j=i+1; j&lt;n; j++){if(a[j] &gt; a[min]) min = i; }swap(a[i], a[min]);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231220221305654.png" alt="image-20231220221305654"></p><h1 id="输出格式有要求时要注意-比如说多少位-少的补0"><a href="#输出格式有要求时要注意-比如说多少位-少的补0" class="headerlink" title="输出格式有要求时要注意,比如说多少位,少的补0"></a>输出格式有要求时要注意,比如说多少位,少的补0</h1><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><pre class="line-numbers language-none"><code class="language-none">int head, e[N], ne[N], idx;void init(){head = -1;idx = 0;}void insert(int a){e[idx] = , ne[idx] = head, head = idx++;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h1><pre class="line-numbers language-none"><code class="language-none">void Floyd(MGraph G){for(i = 0; i&lt;G.vertexNum; i++){for(j = 0; j&lt;G.vertexNum; j++){dist[i][j] = G.arc[i][j];if(dist[i][j]!=无穷)path[i][j] = G.vertex[i] + v}for(k=0; k&lt;G.vertexNum; k++)for(i=0; i&lt;G.vertexNum; i++)for(j=0; j&lt;G.vertexNum; j++)if(dist[i][k]+dist[k][j] &lt; dist[i][j]){dist[i][j] = dist[i][k]+dist[k][j];path[i][j] = path[i][k]+path[k][j];}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">for(k=0; k&lt;G.vertexNum; k++){for(i=0; i&lt;G.vertexNum; i++)for(j=0; j&lt;G.vertexNum; j++){dist[i][j] = dist[i][k] +dis[k][j];Path[i][j] = Path[k][j];}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常用库函数</title>
      <link href="/2023/10/22/chang-yong-ku-han-shu/"/>
      <url>/2023/10/22/chang-yong-ku-han-shu/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;algorithem&gt;#include&lt;vector&gt;vector&lt;int&gt; aa({1, 2, 3, 4, 5});reverse(aa.begin(), aa.end());int a[] = {1, 3, 4, 5};reverse(a, a+4);//时间复杂度O(N)unique(a, a+4);//对数组去重后返回最后元素的下一个位置,如果是容器则返回迭代器的下一个int m = unique(a, a+4) - a;int n = unique(aa.begin(), aa.end()) - a.end();    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="unique函数"><a href="#unique函数" class="headerlink" title="unique函数"></a>unique函数</h1><p>这里的去除并非真正意义上的erase,而是将重复的元素放到容器的末尾,返回值是去重之后的尾地址</p><p>unique针对的是相邻元素,所以对于顺序错乱的数组或者容器要先用sort排序</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){    int a[8] = {2, 2, 3, 4, 4, 6, 7, 8};    int c;    sort(a, a+8);//对于无序的数组需要先排序    c = (unique(a, a+8) - a);    for(int i=0; i&lt;c; i++)        cout &lt;&lt; a[i];    //对于容器操作类似    vector&lt;int&gt; m;    sort(m.begin(), m.end());    m.erase(unique(m.begin(),m.end()), m.end());    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="random-shuffle-a-begin-a-end-头文件-include"><a href="#random-shuffle-a-begin-a-end-头文件-include" class="headerlink" title="random_shuffle(a.begin(), a.end());头文件#include"></a>random_shuffle(a.begin(), a.end());头文件#include<algorithm></algorithm></h1><p>创建随机种子才能真正做到随机随机种子:<br>#include<ctime><br>srand(time(0));</ctime></p><p>random_shuffle(a.begin(), a.end());</p><h1 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h1><p>sort(a, a+4, greater);//降序,从大到小</p><p>或者:<br>sort(a, a+4, cmp);</p><p>sort(aa.begin(), aa.end(), cmp);</p><p>bool cmp(int a, int b){</p><p>return a&gt;b;//从大到小</p><p>return a&lt;b; //从小到大</p><p>}</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Rec{    int x, y;    bool operator&gt; (const struct&amp; temp) const    {        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>五</p><h1 id="lower-bound-a-a-5-最后一个元素的下一位-x-查找的值-返回的是指针"><a href="#lower-bound-a-a-5-最后一个元素的下一位-x-查找的值-返回的是指针" class="headerlink" title="lower_bound(a, a+5(最后一个元素的下一位), x(查找的值));//返回的是指针"></a>lower_bound(a, a+5(最后一个元素的下一位), x(查找的值));//返回的是指针</h1><p>查找大于等于x的值中最小的 </p><h1 id="upper-bound参数同上-返回的也是指针"><a href="#upper-bound参数同上-返回的也是指针" class="headerlink" title="upper_bound参数同上,返回的也是指针"></a>upper_bound参数同上,返回的也是指针</h1><p>查找大于x的值中最小的</p><p>除了队列都可以遍历</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2023/10/21/wei-yun-suan/"/>
      <url>/2023/10/21/wei-yun-suan/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>求二进制数某k位数</p><p>a &gt;&gt; k &amp; 1;</p><p>把一个数的二进制每一位输出出来</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i= 7; i&gt;=0; i--){    cout &lt;&lt; (a &gt;&gt; i) &amp; 1 ;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>求一个二进制数最后的1及其后所有的0</p><p>a&amp;(~a+1)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一个游戏推箱子</title>
      <link href="/2023/10/21/wo-de-di-yi-ge-you-xi-tui-xiang-zi/"/>
      <url>/2023/10/21/wo-de-di-yi-ge-you-xi-tui-xiang-zi/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// ConsoleApplication1.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include&lt;cstring&gt;using namespace std;void print(char map[][100]) {for (int i = 0; i &lt; 5; i++) {for (int j = 0; j &lt; 8; j++) {if (!map[i][j]) cout &lt;&lt; ' ';else cout &lt;&lt; map[i][j];}cout &lt;&lt; endl;}cout &lt;&lt; "w:上  a:左  s:右  z:下" &lt;&lt; endl;}int main(){char map[100][100];memset(map, 0, sizeof map);for (int i = 0; i &lt; 8; i++) {map[0][i] = '#';map[4][i] = '#';}for (int j = 1; j &lt; 4; j++) {map[j][0] = '#';map[j][7] = '#';}int x=1, y=5;int xPoint1 = 1, yPoint1 = 2;int xPoint2 = 1, yPoint2 = 3;int xBox1 = 2, yBox1 = 2, xBox2 = 2, yBox2 = 3;char move;int dx = 0, dy = 0;bool solve1 = 0;bool solve2 = 0;int solves = 0;while (true) {//getInput();//updateGame();//draw();if (solve1) {map[xBox1][yBox1] = '0';}else if (solve1 == 0) {map[xPoint1][yPoint1] = '.';map[xBox1][yBox1] = 'o';}if (solve2) {map[xBox2][yBox2] = '0';}else if (solve2 == 0) {map[xPoint2][yPoint2] = '.';map[xBox2][yBox2] = 'o';}map[x][y] = 'p';print(map);if (solves == 2) {printf("bro你已经完成了这个游戏");return 0;}cin &gt;&gt; move;switch (move) {case 'w':x -= 1;dx = -1;dy = 0;break;case 'z':x += 1;dx = 1;dy = 0;break;case 'a':y -= 1;dx = 0;dy = -1;break;case 's':y += 1;dx = 0;dy = 1;break;default:cout &lt;&lt; "非法操作,请重新输入" &lt;&lt; endl;continue;break;}if (map[x][y]==0 ||(map[x][y] =='.')) {map[x - dx][y - dy] = 0;continue;}else if(map[x][y] == '#' || map[x][y] == '0'){x-=dx;y-=dy;continue;}else {int xtemp = x+dx, ytemp = y+dy;if (map[xtemp][ytemp] == 0) {if (x == xBox1 &amp;&amp; y == yBox1) {xBox1 = xtemp;yBox1 = ytemp;}else if (x == xBox2 &amp;&amp; y == yBox2) {xBox2 = xtemp;yBox2 = ytemp;}map[x - dx][y - dy] = 0;}else if (map[xtemp][ytemp] == '.') {if (x == xBox1 &amp;&amp; y== yBox1) {xBox1 = xtemp;yBox1 = ytemp;solve1 = 1;solves++;}else if (x == xBox2 &amp;&amp; y == yBox2) {xBox2 = xtemp;yBox2 = ytemp;solve2 = 1;solves++;}map[x - dx][y - dy] = 0;}else if (map[xtemp][ytemp] == '#' || map[xtemp][ytemp] == '0' || map[xtemp][ytemp] == 'o') {x -= dx;y -= dy;continue;}}}}// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单// 调试程序: F5 或调试 &gt;“开始调试”菜单// 入门使用技巧: //   1. 使用解决方案资源管理器窗口添加/管理文件//   2. 使用团队资源管理器窗口连接到源代码管理//   3. 使用输出窗口查看生成输出和其他消息//   4. 使用错误列表窗口查看错误//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VS工具模块扩展</title>
      <link href="/2023/10/18/vs-gong-ju-mo-kuai-kuo-zhan/"/>
      <url>/2023/10/18/vs-gong-ju-mo-kuai-kuo-zhan/</url>
      
        <content type="html"><![CDATA[<p> VS visual studio 2019 获取新的工具或功能 安装新的模块</p><h4 id="点击：工具-获取工具与功能-点击打开模块安装器：installer"><a href="#点击：工具-获取工具与功能-点击打开模块安装器：installer" class="headerlink" title="点击：工具 >> 获取工具与功能 >> 点击打开模块安装器：installer"></a>点击：工具 &gt;&gt; 获取工具与功能 &gt;&gt; 点击打开模块安装器：installer</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stl库函数</title>
      <link href="/2023/10/18/stl-ku-han-shu/"/>
      <url>/2023/10/18/stl-ku-han-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="include"><a href="#include" class="headerlink" title="#include"></a>#include<vector></vector></h1><p>变长数组</p><p>面对大规模数组时</p><p>支持随机访问,但是不支持在任意位置O(1)插入</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;vector&gt;vector&lt;int&gt; a;//相当于一个长度动态变化的int数组a.size();返回包含元素的个数a.empty();//空为true,非空为falsea.clear();//把vector清空//所有的stl容器都支持这两个函数,用法相同,函数也相同vector&lt;int&gt;  b[233];//相当于第一维长233,第二维长度动态变化的int数组struct rec{...}vector&lt;rec&gt; c;自定义的结构体类型也可以保存在vector中a.resize(大小);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>可以当成指针来看</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt;::iterator it = a.begin();a.end();//a最后一个元素的后一个元素,大部分stl容器都有vector的迭代器是"随机访问迭代器",即与指针类似it+1;//即为a[1]的指针*it;//访问值*a.begin() = a[0];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>begin()</p><p>end()//基本上都是左闭右开</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; a({1, 2, 3});for(int i=0; i&lt;a.size(); i++) cout &lt;&lt; a[i] &lt;&lt;' ';等价于    auto i = a.begin();//迭代器 其实绝大多数情况下不用太麻烦for(vector&lt;int&gt;::iterator/*auto*/ i = a.begin(); i!=a.end(); i++)    cout &lt;&lt; *i &lt;&lt;' ';也有范围遍历for(int x : a) cout &lt;&lt; x &lt;&lt;' ';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等价头元素返回</p><p>a.front()     a[0]    *a.begin()</p><p>a.back() 最后一个元素等价于a[a.size()-1];</p><p>a.end() 最后一个元素后一个位置</p><p>a.push_back(4);//在数组最后加一个元素 平均意义上看是O(1)操作 比普通数组慢一倍</p><p>a.pop_back(); </p><p>a.erase()//这是O(n)的操作,没啥用</p><p>a.size();</p><p>for(auto x : a) cout &lt;&lt; x &lt;&lt;’  ‘;</p><p>vector是一个倍增思想的数组</p><h1 id="include队列"><a href="#include队列" class="headerlink" title="#include队列"></a>#include<queue>队列</queue></h1><p>普通队列和优先队列</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">queue&lt;int&gt; a;queue&lt;double&gt; q;priority_queue&lt;int&gt; a; // 大根堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; b;//小根堆struct Rec{    int a, b;    //如果用自己的结构体,一定要重载比较符号(以大根堆为例)  优先队列重载小于号    bool operator&lt; (const Rec&amp; t) const    {        return a&lt;t.a;//用a来比较    }    };struct SRec{  int a, b;    bool operator&gt; (const SRec&amp; t) const    {        return a&lt;t.a;    }};priority_queue&lt;Rec&gt; d;priority_queue&lt;SRec, vector&lt;SRec&gt;, greater&lt;SRec&gt; &gt; s;d.push({1 ,2});库函数queue&lt;int&gt; q;q.push(1);//在队尾插入一个元素q.pop();//弹出队头元素q.front(); //返回队头q.back(); //返回队尾//没有clear()函数如何清空队列?q = queue&lt;int&gt;();s.push(1);s.top();查询堆顶元素s.pop();删除堆顶元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="除了栈-队列-优先队列-其他的都有clear函数"><a href="#除了栈-队列-优先队列-其他的都有clear函数" class="headerlink" title="除了栈,队列,优先队列,其他的都有clear函数"></a>除了栈,队列,优先队列,其他的都有clear函数</h1><p>优先队列(优先弹出最大值)</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;stack&gt;栈尾插入,栈尾弹出stack&lt;int&gt; stk;stk.push(1);stk.top();stk.pop();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;deque&gt;//常数大,比vector还大deque&lt;int&gt; a;a.begin();a.end();a.front(), a.back();//这两是迭代器啊,踏马的忘了a.push_back(1), push_front(2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>queue底层实现是vector(也可以用链表,不过效率低)</p><h1 id="include-1"><a href="#include-1" class="headerlink" title="#include"></a>#include<set></set></h1><p>包含set和multiset两个容器</p><p>分别是有序集合和有序多重集合</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">set&lt;int&gt; a;//元素不能重复multiset&lt;int&gt; b;//若以结构体传参则要重载小于号struct Rec{    int x, y;    bool operator&lt; (const Rec&amp; t) const{        return x&lt; t.x;    }};size / empty / clearset&lt;int&gt;::iterator it = a.begin();it++, it--;++it, --it;迭代器:a.end();a.insert(x);将x插入到集合x中,复杂度为logn在set中若已存在该元素,则对集合的状态无影响a.find(x);在集合中查找等于x的元素,并返回指向该元素的迭代器,若不存在则返回s.end(),时间复杂度为O(logn);if(a.find(x) == a.end()) 判断x是否在a中s.lower_bound(x)//找到大于等于x的最小的迭代器  s.upper_bound(x)//找到大于x的最小的迭代器   a.erase(it);//logn   a.erase(x);//从 s中删除所有等于xlogn;复杂度为k+logn 其中k为元素x的个数a.count(x);//返回个数 没有返回0,时间复杂度k+logn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>迭代器</p><p>​set 和multiset的迭代器称为双向访问迭代器 ,不支持随机访问, 支持*解除引用,仅支持++和–两个与算数相关的操作</p><h1 id="map和set的底层实现都是红黑树"><a href="#map和set的底层实现都是红黑树" class="headerlink" title="map和set的底层实现都是红黑树"></a>map和set的底层实现都是红黑树</h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="#include"></a>#include<map></map></h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">map&lt;int, int&gt; a;a[1] = 2;a[1000000] = 3;cout &lt;&lt; a[1000000];map&lt;string, vector&lt;int&gt; &gt; a;a["whh"] = vector&lt;int&gt;({1, 2 ,3});cout &lt;&lt; a["whh"][2] &lt;&lt; endl;return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>size/empty/clear/begin/end 均与set类似</p><p>insert/erase</p><p>与set类似,但是参数均是pair&lt;key_type, value_type&gt;</p><p>a.insert({“a”, {}});</p><p>a[“whh”] = vector<int>({1, 2 ,3 ,4});</int></p><p>cout &lt;&lt; a[“whh”][2] &lt;&lt; endl;k</p><p>pair&lt;int, int&gt;</p><p>find:</p><p>​a.find(x);//在变量名为a的map中查找key为x的二元组 ,返回的是迭代器</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;unordered_map&gt;#include&lt;unordered_set&gt;unordered_set&lt;int&gt; a; // 底层实现是哈希表unordered_multiset&lt;int&gt; b;// 哈希,可存在重复元素unordered_map&lt;int, int&gt; c;//O(1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="include-3"><a href="#include-3" class="headerlink" title="#include"></a>#include<bitset></bitset></h1><p>bitset&lt;1000&gt; a, b;</p><p>a[0] = 1;</p><p>a[1] = 1;</p><p>a.set(3);//a[3] = 1;</p><p>a.reset(3); //a[3] = 0;</p><p>同样的有size/empty/</p><h1 id="pair-a-b"><a href="#pair-a-b" class="headerlink" title="pair<int, string> a,b;"></a>pair&lt;int, string&gt; a,b;</h1><p>a = {3, “hhh”};</p><p>b = make_pair(4, “abc”);</p><p>cout &lt;&lt; a.first &lt;&lt; ‘ ‘ &lt;&lt; a.second;</p><p>支持比较运算(双关键字比较, 先比较第一个再去看第二个 ,如果是字符串按字典序来比较)</p><p>AND 与</p><p>OR 或</p><p>XOR 异或</p>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp类和对象</title>
      <link href="/2023/10/14/cpp-lei-he-dui-xiang/"/>
      <url>/2023/10/14/cpp-lei-he-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="c-面向对象三大特性-封装继承-多态"><a href="#c-面向对象三大特性-封装继承-多态" class="headerlink" title="c++面向对象三大特性:封装继承,多态"></a>c++面向对象三大特性:封装继承,多态</h2><p>c++认为万事万物皆为对象,对象上有其属性和行为</p><p>学生类:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Student {public:    string name;    int num;    void setName(string name){        this.name = name;    }    void setNum(int num) {        this.name = num;    }        void showName(){        cout &lt;&lt; name &lt;&lt; endl;    }        void showNum(){        cout &lt;&lt; num  &lt;&lt; endl;    }};//记住类最后的这个分号;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>//类中的属性和行为 我们统一称为成员</p><p>//属性 成员属性 成员变量</p><p>//行为 成员函数 成员方法</p><p>封装意义二:</p><p>类在设计时,可以把属性和行为放在不同的权限下,加以控制</p><p>访问权限有三种:<br>public 公共权限 类内可 类外可</p><p>protected 保护权限  类内可以 类外不可 //子类有访问父类的权限</p><p>private 私有权限 类内可 类外不可//子类没有访问父类的权限</p><h1 id="struct-和class区别"><a href="#struct-和class区别" class="headerlink" title="struct 和class区别"></a>struct 和class区别</h1><p>c++中唯一区别在于 <strong>默认访问权限不同</strong></p><p>struct 默认公有</p><p>class 默认私有</p><p>设置成私有可以自己控制权限,并且可以对写入的数据加以限制</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>构造函数</strong>:创建对象时系统自动调用 构造函数语法: 类名() {}</p><p>构造函数可以有参数,因此可以发生重载                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </p><p><strong>析构函数</strong>:销毁对象前系统自动调用,执行清理工作 析构函数语法:~类名(){}</p><p>析构函数不可以有参数,无法重载(如在函数中创建的对象在函数结束前会调用)</p><h2 id="都没有返回值-如果不写-系统会自己调用"><a href="#都没有返回值-如果不写-系统会自己调用" class="headerlink" title="都没有返回值,如果不写,系统会自己调用"></a>都没有返回值,如果不写,系统会自己调用</h2><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数:"></a>构造函数:</h2><p>普通构造:<br>拷贝构造: Person(const Person p);</p><p>不同构造的类创建对象形式</p><p>有参构造:Person p1(10);</p><p>默认构造 Person p2;</p><p>拷贝构造: Person p3(p1);</p><h1 id="类创建对象的三种方法"><a href="#类创建对象的三种方法" class="headerlink" title="类创建对象的三种方法"></a>类创建对象的三种方法</h1><h1 id="1-括号法"><a href="#1-括号法" class="headerlink" title="1.括号法()"></a>1.括号法()</h1><p>调用默认构造时不要加上()</p><p><strong>原因</strong> 在编译器中Person p1(); 会被认为是一个函数的声明</p><h2 id="2-显示法"><a href="#2-显示法" class="headerlink" title="2.显示法"></a>2.显示法</h2><p>Person p1 = Person(10);</p><p><strong>原因</strong> Person(10);是一个匿名对象</p><h3 id="匿名对象特点"><a href="#匿名对象特点" class="headerlink" title="匿名对象特点:"></a>匿名对象特点:</h3><p>当前行结束后,系统立即回收匿名对象</p><p>注意事项</p><p>//不要用拷贝构造函数初始化匿名对象,编译器会认为Person(p3) == Person p3;</p><h2 id="3-隐式转换法"><a href="#3-隐式转换法" class="headerlink" title="3.隐式转换法"></a>3.隐式转换法</h2><p>Person p4 = 10;//相当于写了Person p4 = Person(10);</p><h1 id="拷贝函数调用时机"><a href="#拷贝函数调用时机" class="headerlink" title="拷贝函数调用时机"></a>拷贝函数调用时机</h1><p>1.使用一个已经创建完毕的对象来初始化另一个新对象</p><p>2.值传递的方式给函数参数传值//实参传给形参的时候</p><p>3.值方式返回局部对象</p><p>Person p = doWork2();</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Person dowork2(){Person p1;    return p1;//这里并不是真的返回p1,p1在函数结束后就被销毁了,而是创建一个拷贝构造的对象}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h1><p>默认情况下,c++编译器至少给一个类添加3个函数</p><p>1.默认构造参数(无参, 函数体为空)</p><p>2.默认析构函数(无参, 函数体为空)</p><p>3.默认拷贝构造函数,对属性进行值拷贝</p><h2 id="如果用户定义有参构造函数-c-不再提供默认无参构造-但是会提供默认拷贝构造"><a href="#如果用户定义有参构造函数-c-不再提供默认无参构造-但是会提供默认拷贝构造" class="headerlink" title="如果用户定义有参构造函数 c++不再提供默认无参构造  但是会提供默认拷贝构造"></a>如果用户定义有参构造函数 c++不再提供默认无参构造  但是会提供默认拷贝构造</h2><h2 id="如果用户定义拷贝构造函数-c-不会再提供其它构造函数-就是那三个默认都不行了"><a href="#如果用户定义拷贝构造函数-c-不会再提供其它构造函数-就是那三个默认都不行了" class="headerlink" title="如果用户定义拷贝构造函数,c++不会再提供其它构造函数(就是那三个默认都不行了)"></a>如果用户定义拷贝构造函数,c++不会再提供其它构造函数(就是那三个默认都不行了)</h2><h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><p>浅拷贝: 简单的赋值拷贝操作</p><p>深拷贝: 在堆区重新申请空间,进行拷贝操作</p><p>浅拷贝带来的问题:堆区的重复释放</p><p><strong>例子</strong> : p1 中定义一个指针,该指针在堆区中开辟(在析构函数中回收),然后用默认的浅拷贝操作Person p2(p1)会直接把p1中指针的地址拷贝过来,然后由于函数在栈中先进后出的特性, p2被栈自动回收之后系统自动调用析构函数回收一遍指针指向的内存,到p1之后又执行这样的一次操作,导致程序崩溃</p><p>解决方法:自己实现拷贝构造函数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Person(const Person&amp; p){    m_Age = p.m_Age;    //m_Height = p.m_Height;编译器默认实现就是这行代码    //深拷贝操作        m_Height = new int(*p.m_Height);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结-如果属性有在堆区开辟的-一定要自己提供拷贝构造函数-防止浅拷贝带来的问题"><a href="#总结-如果属性有在堆区开辟的-一定要自己提供拷贝构造函数-防止浅拷贝带来的问题" class="headerlink" title="总结:如果属性有在堆区开辟的,一定要自己提供拷贝构造函数,防止浅拷贝带来的问题"></a>总结:如果属性有在堆区开辟的,一定要自己提供拷贝构造函数,防止浅拷贝带来的问题</h2><h1 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表:"></a>初始化列表:</h1><p><strong>作用</strong></p><p>c++提供了初始化列表语法,用来初始化属性</p><p>构造函数(): 属性1(值1), 属性2(值2) … {}</p><p>示例</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Person(int a, int b, int c) : m_A(a), m_B(b), m_C(c) const{    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h2><p>c++类中的成员可以是另一个类中的对象,我们称该成员为对象成员</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A {}class B{    A a;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Phone{public:     string m_PName;}class Person{public:    //Phone m_Phone = pName 隐式转换法    Person(string name, string pName):m_Name(name), m_Phone(pName)    {            }    string m_Name;    Phone m_Phone;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题来了:先有了人的构造还是先有了手机的构造?</p><p>先有了手机的构造再有人的构造</p><p>当其他类作为本类成员,构造时候先构造类对象再构造自身,析构顺序是先本类析构再其他类析构</p><h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><p> 所有对象共享一份数据]</p><p>在编译阶段分配内存<br><strong>类内声明</strong> <strong>类外初始化</strong></p><p>(对于pubic类型的)有两种访问的方法:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">1.通过对象访问    Person p1;cout &lt;&lt; p1.a;2.通过类直接访问cout &lt;&lt; Person::a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(对于private类型的)只有通过对象访问</p><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>所有对象共享同一个函数<br>静态成员函数只能访问静态成员变量</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">1.通过对象访问    Person p;p.func();2.通过类名访问    Person::func();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="c-对象模型和this指针"><a href="#c-对象模型和this指针" class="headerlink" title="c++对象模型和this指针"></a>c++对象模型和this指针</h1><h2 id="成员变量和成员函数是分开存储的"><a href="#成员变量和成员函数是分开存储的" class="headerlink" title="成员变量和成员函数是分开存储的"></a>成员变量和成员函数是分开存储的</h2><p>空对象:</p><p>占内存空间为1<br>原因:c++编译器会给每个空对象分配一个字节空间来区分空对象占内存的位置<br>每个空对象也应该有一个独一无二的内存地址</p><h3 id="只有非静态成员变量才在类对象中占用内存"><a href="#只有非静态成员变量才在类对象中占用内存" class="headerlink" title="只有非静态成员变量才在类对象中占用内存"></a>只有非静态成员变量才在类对象中占用内存</h3><h1 id="c-内存对齐"><a href="#c-内存对齐" class="headerlink" title="c++内存对齐"></a>c++内存对齐</h1><p>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。</p><p>有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p><p>了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：</p><p>(1) 结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 offset 都是<strong>该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</p><p>(3) <strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针:"></a>this指针:</h1><p>this 指针指向被调用的成员函数所属的对象</p><p>1.解决名称冲突</p><p>2.返回对象本身*this</p><h1 id="链式编程思想"><a href="#链式编程思想" class="headerlink" title="链式编程思想"></a>链式编程思想</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Person&amp; PersonAddAge(Person &amp;p){this-&gt;age += p.age;    return *this;}p2.PersonAddAge(p).PersonAddAge(p);或者例如:cout &lt;&lt; c1 &lt;&lt; c2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="const修饰成员"><a href="#const修饰成员" class="headerlink" title="const修饰成员"></a>const修饰成员</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//在对象前加const ,变为常对象const Person p;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>this这个指针其实是指针常量</p><p>在成员函数那里加上const就变成常函数,<br>本质是 const Person* this;无法修改值</p><p>但是在变量前加上mutable 就可以修改了,常函数和</p><h2 id="常对象"><a href="#常对象" class="headerlink" title="常对象:"></a>常对象:</h2><p>声明对象前加const称该对象为常对象</p><p><strong>常对象</strong>只能调用<strong>常函数</strong></p><h1 id="空指针调用成员函数"><a href="#空指针调用成员函数" class="headerlink" title="空指针调用成员函数"></a>空指针调用成员函数</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person{    public:    void showName(){        cout &lt;&lt;"name";    }    int showAge(){        //为了代码健壮性,加上这行        if(this == NULL) return ;        return age;    }private:            int age;   };void test01(){Person* p = NULL;    p-&gt;showName;//不会崩    p-&gt;showAge;//会崩,因为用到this指针}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h1><h2 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Building{  friend void goodBoy(Building *building); };void goodBoy(Building *building){    ....}void test(){    Building build;    gooBoy(&amp;build);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Building;class GoodGay{public:    GoodGay();    void visit(); // 参观函数,访问building中的属性        Building *building;}GoodGay::GoodGay(){    building =  new Building();}void GoodGay::visit(){    cout &lt;&lt; builing-&gt;m_SittingRoom;    }class Building{friend class GoodGay;//类做友元public:    Building();public :    string m_SittingRoom;private:    string m_bedingRoom;}//类外写成员函数Building::Builing(){    m_SittingRoom = "客厅";    m_BedRoom= "卧室";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成员函数做友元</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class GoodGay(){public:    GoodGay();    void visit(); //让visit函数可以访问building中的私有成员    void visit2();//不可访问    Building *building; }class Building{    friend void GoodGay::visit();public:    Building();public:    string m_SittingRoom;private:    string m_BedRoom;}Building::building(){    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>对已有的运算符重新定义,赋予另一种功能以适应不同的数据类型</p><h2 id="通过成员函数重载加号"><a href="#通过成员函数重载加号" class="headerlink" title="通过成员函数重载加号"></a>通过成员函数重载加号</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Person operator+ (Person &amp;p){    Person temp;    temp.m_A = this-&gt;m_A + p.m_A;    temp.m_B = this-&gt;m_B + p.m_B;    return temp;}Person p3 = p1.operator+(p2);//简化为:Person p3 = p1 + p2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="通过全局函数来重载加号"><a href="#通过全局函数来重载加号" class="headerlink" title="通过全局函数来重载加号"></a>通过全局函数来重载加号</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Person operator+(Person &amp;p1, Person &amp;p2){    Person temp;    temp.m_A = p1.m_A + p2.m_A;    temp.m_b = p1.m_B + p2.m_B;    return temp;}Person p3 = operator+(p1, p2);//等价于Person p3 = p1 + p2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运算符重载也可以发生函数重载</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.对于内置的数据类型的表达式的运算符是不可能发生改变的</p><p>2.不要滥用运算符</p><h1 id="重载左移运算符"><a href="#重载左移运算符" class="headerlink" title="重载左移运算符"></a>重载左移运算符</h1><p>使用成员函数重载运算符时会出现 p.operator&lt;&lt;(cout)即p &lt;&lt; cout ;所有通常不这么用</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ostream&amp; operator(ostream &amp;cout , Person &amp;p){//本质 operator&lt;&lt;(cout , p);    cout &lt;&lt;p.ma&lt;&lt;p.mb;    return cout;}void test01(){    Person p;    p.m_A = 10;    p.m_B = 10;        cout &lt;&lt; p;//利用全局函数重载它}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="如果属性是私有的-如何利用重载之后的函数访问"><a href="#如果属性是私有的-如何利用重载之后的函数访问" class="headerlink" title="如果属性是私有的,如何利用重载之后的函数访问?"></a>如果属性是私有的,如何利用重载之后的函数访问?</h2><p>在被访问的类中加上</p><p>friend ostream&amp; operator(ostream &amp;cout , Person &amp;p);</p><h1 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a = 10;cout &lt;&lt; ++a &lt;&lt; endl;//11cout &lt;&lt; a &lt;&lt; endl ;//11int b = 10;cout &lt;&lt; b++ &lt;&lt; endl;//10cout &lt;&lt; b &lt;&lt; endl;//11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyInteger{    friend ostream&amp; operator&lt;&lt;(ostream&amp;  cout, MyInteger myint); public:    MyInteger()    {        m_Num = 0;    }//重载前置++运算符    MyInteger&amp; operator++()    {        m_Num++;        return *this;    }    //重载后置++运算符    MyInteger operator++()    {        MyInteger temp = *this;        m_Num++;        return temp;    }private:    int m_Num;}void test01(){    MyInteger myint;    cout&lt;&lt;++(++myint) &lt;&lt; endl;    cout &lt;&lt; myint &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h1><p>c++编译器至少给一个类添加至少4个函数</p><p>1.默认构造函数(无参, 函数体为空)</p><p>2.默认析构函数(无参, 函数体为空)</p><p>3.拷贝函数(默认只有浅拷贝)</p><p>4.赋值运算符operator= 对属性进行值拷贝</p><p>如果类中有属性指向堆区,做赋值操作时会出现深浅拷贝的问题</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person{public:    Person(int age)    {        m_age = new int(age);    }    ~Person(){        if(m_age!=NULL) {            delete m_age;            m_age = NULL;        }            }        //重载 赋值运算符    Person&amp; operator(Person &amp;p)    {        if(m_Age!=NULL){     delete m_age;            m_age = NULL;        }        m_age = new int(*p.m_age);        return *this;     }    int *m_age;}void test01(){    Person p1(18);    Person p2(20);    p2 = p1;//赋值操作    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="重载关系运算符"><a href="#重载关系运算符" class="headerlink" title="重载关系运算符"></a>重载关系运算符</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person{public:    Person(string name, int age)    {        this-&gt;m_name = name;        this-&gt;m_age = age;    }        bool operator==(Person &amp;p){        if(this.m_name == p.nName &amp;&amp; this-&gt;m_Age == p.m_Age)        {            return true;        }        else        {            return false;        }    }    bool operator!=(Person &amp;p){        if(this.m_name == p.nName &amp;&amp; this-&gt;m_Age == p.m_Age)        {            return false;        }        else        {            return true;        }    }}void test(Person &amp;p1, Person &amp;p2){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h1><p>即() 也可以重载</p><p>重载后使用的方式非常像函数的调用,因此被称仿函数</p><p>仿函数无固定写法,比较灵活</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//写在Person的类中void operator() (string test){    cout &lt;&lt; test &lt;&lt; endl;}Person print;print("sdiuahuda");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>匿名函数对象</p><p>Myadd()(100, 100) ;</p><h1 id="继承-减少重复的代码量"><a href="#继承-减少重复的代码量" class="headerlink" title="继承(减少重复的代码量)"></a>继承(减少重复的代码量)</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class BasePage{public:    void left();    void top();    void bottom();};//继承//语法: class 子类 : 继承方式 父类//子类  派生类//父类 基类class Java : public BasePage{public:    void content()    {        cout &lt;&lt; "java学科视频" &lt;&lt; endl;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="继承的三种方式"><a href="#继承的三种方式" class="headerlink" title="继承的三种方式"></a>继承的三种方式</h2><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-01 144331.png)</p><h2 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h2><p>在父类中所有非静态属性都会被子类继承下去<br>父类中私有成员属性 被编译器隐藏了 ,因此访问不到 但是确实被继承了</p><p>使用sizeof(Son)就可以得出结论<br>//利用开发人员命令提示工具查看对象模型</p><p>跳转盘符 F:</p><p>跳转文件路径 cd 具体路径下<br>查看命名</p><p>cl /d1 reportSingleClassLayout 文件名</p><h2 id="继承中的构造和析构顺序"><a href="#继承中的构造和析构顺序" class="headerlink" title="继承中的构造和析构顺序"></a>继承中的构造和析构顺序</h2><p>父类构造-&gt;子类构造-&gt;子类析构-&gt;父类构造</p><p>可以在类中对构造函数进行重载来检验</p><p>如果想通过子类对象访问父类同名成员变量的值,必须要加作用域 s.Base::m_A</p><p>子类对象直接调用与父类成员函数同名的成员函数,也是就近原则,如果想调用父类的要加作用域</p><p>子类同名函数会完全覆盖掉父类中的同名函数,必须加上作用域才能访问</p><h2 id="继承中同名静态成员处理"><a href="#继承中同名静态成员处理" class="headerlink" title="继承中同名静态成员处理"></a>继承中同名静态成员处理</h2><p>类内声明,类外初始化 ,所有对象共享同一块内存</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base{public :    static int m_A;};int Base::m_A = 100;class Son : public Base{public:    static int m_A;};int Son::m_A = 200;void test01(){    //第一种通过对象访问    Son s;    cout &lt;&lt; s.m_A &lt;&lt; endl;    cout &lt;&lt; s.Base::m_A&lt;&lt;endl;    //第二种访问方式 通过类名访问    cout &lt;&lt; Son::m_A&lt;&lt; endl;    //第一个:: 通过类名方式访问 第二个:: 访问父类作用域    cout &lt;&lt; Son::Base::m_A &lt;&lt; endl;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h2><p>c++允许一个类继承多个类</p><p>class 子类 : 继承方式 父类1, 继承方式 父类2 </p><p>多继承可能引发父类同名成员出现,所以要加作用域</p><p>实际开发中使用较少(不建议使用)</p><p>多继承内存: 是继承来的变量加上自己的变量</p><p>开发人员命令提示符:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">进入文件所在目录 使用如下命令    c1 /d1 reportSingleClassLayoutSon   "文件名"//最后的 Son 是类名 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当父类中出现同名成员 访问需要加上作用域</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">s.Base1::m_age;s.Base2::m_age;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><h3 id="两个类有共同的父类和共同的子类"><a href="#两个类有共同的父类和共同的子类" class="headerlink" title="两个类有共同的父类和共同的子类"></a>两个类有共同的父类和共同的子类</h3><h4 id="概念-两个派生类继承同一个基类-又有某个类同时继承这两个派生类-这种继承被称为菱形继承或钻石继承"><a href="#概念-两个派生类继承同一个基类-又有某个类同时继承这两个派生类-这种继承被称为菱形继承或钻石继承" class="headerlink" title="概念:两个派生类继承同一个基类   又有某个类同时继承这两个派生类 这种继承被称为菱形继承或钻石继承"></a>概念:两个派生类继承同一个基类   又有某个类同时继承这两个派生类 这种继承被称为菱形继承或钻石继承</h4><p>继承重复成员浪费空间,那么如何解决这个问题呢?</p><h2 id="使用虚继承的方法"><a href="#使用虚继承的方法" class="headerlink" title="使用虚继承的方法"></a>使用<strong>虚继承</strong>的方法</h2><p>两个派生类使用虚继承的方式继承基类</p><p>底层:用两个指针实现,一个vbptr(virtual base pointer)指向vbtable中记录的偏移量</p><p>这里面的两个指针加上各自偏移量后指向的成员变量地址相同</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>静态多态: 函数重载 运算符重载    复用函数名</p><p>动态多态:派生类和虚函数 实现运行时多态</p><p>区别:</p><p>​静态多态函数地址早绑定 - 编译阶段确定函数地址 早绑定</p><p>​动态多态函数地址晚绑定 - 运行阶段确定函数地址 晚绑定</p><p>父类引用可以用来接收子类的对象</p><p>动态多态满足条件 </p><p>​有继承关系         子类重写父类虚函数</p><p>空类的大小是1,类中的函数不算在对象的大小中 </p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Animal{public:    virtual void speak()    {        cout &lt;&lt; "动物在说话" &lt;&lt; endl;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vfptr(virtual function pointer)</p><p>animal类内部结构:</p><p>vfptr-&gt;vftable </p><p>重写:函数返回值 参数表 函数名 完全相同</p><p>子类重写父类的虚函数</p><p>子类中的虚函数表内部会替换成子类的虚函数地址 </p><p>这样用父类引用传递子类对象时就可以调用子类对象的重写函数,实现动态多态</p><h3 id="多态好处"><a href="#多态好处" class="headerlink" title="多态好处"></a>多态好处</h3><p>实现计算器类</p><p>真实开发中尽量遵循开闭原则 对扩展进行开放 减少对源码的修改   </p><p>实现计算器的抽象类</p><p>再分别实现加减乘除的计算器的类</p><p>结构清晰 可读性强</p><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要是调用子类重写的内容</p><p>因此可以将虚函数改成纯虚函数</p><p>纯虚函数语法：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">virtual 返回值类型 函数名 （参数列表） = 0；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base{public:   //纯虚函数    //只要有一个纯虚函数, 这个类就称为抽象类    //抽象类特点:// 1.无法实例化对象    //2.抽象类子类必须重写父类中的纯虚函数 ,否则也属于抽象类    virtual void func() = 0;//虚函数基础上写等于0    }class Son :public Base{public:     virtual void func() {         cout &lt;&lt; "函数调用" &lt;&lt; endl;     };}void test01(){    Base *base = new Son;    base-&gt;func(); //子类必须重写父类中的纯虚函数  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多态案例之制作饮品"><a href="#多态案例之制作饮品" class="headerlink" title="多态案例之制作饮品"></a>多态案例之制作饮品</h3><p>抽象制作饮品基类,提供子类制作咖啡和茶叶</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class AbstractDringking{public:    //煮水    virtual void Boil() = 0;    //冲泡    virtual void Brew() = 0;    //倒入杯中    virtual void PourInCup() = 0;    //加入辅料    virtual void PutSomething() = 0;    }class Coffee: public AbctractDringking{public:    virtual void Brew()    {        cout &lt;&lt; "冲泡咖啡" &lt;&lt; endl;    }    virtual void PourInCup()    {        cout &lt;&lt; "倒入杯中" &lt;&lt; endl;    }    virtual void PutSomething()    {        cout &lt;&lt; "加入糖和牛奶" &lt;&lt; endl;    }    }//制作函数void doWork(AbstractDringking *abs)//AbstractDringking *abs = new Coffee;{    abs-&gt;makeDrink();    delete abs;    }void test01(){    //制作咖啡    doWork(new Coffee);        cout &lt;&lt; "---" &lt;&lt; endl;    //制作茶叶    doWowk(new Tea);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h2><p>子类成员变量在堆中申请地址存放东西, 销毁指针指向的时只有父类被调用析构函数销毁了, 子类没有被调用析构析构函数就直接结束了, 导致内存泄漏</p><p>可以用虚析构解决这个情况 父类指针释放子类时不干净的问题</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Animal{public:    //纯虚函数    virtual void speak() = 0;    //可以用虚析构解决这个情况 父类指针释放子类时不干净的问题 //   virtual ~Animal()//    {//        cout &lt;&lt;"isjdia" &lt;&lt; endl;//    }    //虚析构需要代码实现 ,纯虚析构也需要代码实现    virtual ~Animal() = 0;}//有了纯虚析构之后类也属于抽象类无法实现实例化对象Animal::~Animal(){    cout &lt;&lt; "saudh"&lt;&lt; endl;    //子类纯虚析构调用完之后父类也要调用一遍纯虚析构 ,防止父类中也有在堆中开辟的内存无法释放}class Cat:public Animal{public :    Cat(string name)    {        m_Name = new string(name);    }virtual void speak()    {        cout &lt;&lt; *m_name &lt;&lt;"小猫在说话" &lt;&lt; endl;    }    virtual ~Cat()    {        if(m_Name != NULL)        {            cout &lt;&lt; "Cat析构函数调用" &lt;&lt; endl;            delete m_Name;            m_Name = NULL;        }    }        string *name;}void test01(){    Animal *animal = new Cat;    animal-&gt;speak();    delete animal;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多态案例之电脑组装"><a href="#多态案例之电脑组装" class="headerlink" title="多态案例之电脑组装"></a>多态案例之电脑组装</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//抽象出每个零件的类class CPU 抽象类{    virtual void calculate() = 0;}class VideoCard{    virtual void display() = 0;}class Memory{    virtual void storage() = 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">电脑类class Computer{    构造函数中传入三个零件指针    提供工作函数    {        调用每个零件工作的接口    }                }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">具体零件厂商Inter厂商class InterCpu: public CPU{    void calculate()    {        cout &lt;&lt; "inter的cpu开始计算了"    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对象中可以包含其他类的对象吗</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//抽象不同零件class Cpu{public:    virtual void calculate() = 0; };//抽象显卡类class VideoCard{public:    //抽象的显示函数    virtual void display() = 0;    };//抽象内存条类class Memory{public:    //抽象的存储函数    virtual void storage() = 0;    };//电脑类class Computer{public:    Computer(Cpu* cpu, vedioCard *vc, Memory* mem)    {        m_cpu = cpu;        m_vc = vc;        m_mem = mem;    }    //提供工作的函数    void work()    {        //让零件工作起来,调用接口        m_cpu-&gt;calculate();        m_vc-&gt;display();        m_mem-&gt;storage();    }    private:    Cpu* m_cpu;//cpu零件指针    VideoCard *m_vc;//显卡零件指针    Memory *m_mem;//内存条零件指针        //};//具体厂商//inter厂商class InterVideoCard: public: VideoCard{public:    virtual void display()    {        cout &lt;&lt; "Intel的显卡开始运行" &lt;&lt; endl;    }}void test01(){    CPU *intelCPU = new IntelCPU;    //父类指针指向子类    VedioCard *InterCard = new InterVideoCard;    Memort *intelMem = new IntelMemory;        //创建第一台电脑    Computer *computer1 = new Computer(intelCpu, intelCard, intelMem);    computer1-&gt;work();    delete computer1;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>程序运行时产生的数据都属于临时数据 ,程序一旦运行结束都会被释放</p><p>通过文件可以将数据持久化</p><p>c++中对文件操作需要包含头文件<fstream></fstream></p><p>文件类型两种:</p><p>文本文件 -文件以文本的ascii码形式存储在计算机中</p><p>二进制文件 以文本二进制形式存储在计算机中  用户一般不能直接读懂</p><p>操作文件三大类;<br>1.ofstream 写操作<br>2.ifstream 读操作<br>3.读写操作fstream</p><h2 id="5-1-文本文件"><a href="#5-1-文本文件" class="headerlink" title="5.1 文本文件"></a>5.1 文本文件</h2><p>1.包含头文件<br>#include<fstream></fstream></p><p>2.创建流对象<br>ofstream ofs;<br>3.打开文件<br>ofs.open(“文件操作”, 打开方式)<br>4.写数据<br>ofs &lt;&lt; “写入的数据”<br>5.关闭数据<br>ofs.close();</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-15 164848.png)</p><p>文件打开方式可以配合使用,利用|操作符</p><p>例如:用二进制方式写文件 <code>ios::binary | ios::out</code></p><pre class="line-numbers language-none"><code class="language-none">ofs.open("text.text",ios::out);文件创建在同名目录下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p>读文件步骤:</p><p>1.包含#include<fstream></fstream></p><p>2.创建流对象ifstream ifs;</p><p>3.打开文件并判断是否打开成功<br>ifs.open(“文件路径”, 打开方式)<br>4.读数据<br>四种方式获取<br>5.关闭文件<br>ifs.close();</p><p>第一种:</p><pre class="line-numbers language-none"><code class="language-none">char buf[1024] = {0};while(ifs &gt;&gt; buf){cout &lt;&lt; buf &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种</p><pre class="line-numbers language-none"><code class="language-none">char buf[1024] = {0};while(ifs.getline(buf, sizeof(buf))){cout &lt;&lt; buf &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第三种</p><pre class="line-numbers language-none"><code class="language-none">string buf;while(getline(ifs, buf)){cout &lt;&lt; buf &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第四种</p><pre class="line-numbers language-none"><code class="language-none">char c;while((c=ifs.get())!=EOF){cout &lt;&lt; c;}//一个一个读没有上面的快<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><pre class="line-numbers language-none"><code class="language-none">ofstream ofs("person.txt", ios::out | ios::binary);//使用构造函数的方法打开文件法ofs.open("person.txt", ios::out | ios::binary);写文件Person p = {"张三", 18};ofs.write((const char *)&amp;p, sizeof(Person));关闭文件ofs.close();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h4><pre class="line-numbers language-none"><code class="language-none">流对象调用成员函数readistream&amp; read(char *buffer, int len);calss Person{char m_Name[64];//姓名int m_Age;//年龄}//二进制文件 读文件void test01(){//1.包含头文件//2.创建流对象//3.打开文件  判断文件是否打开成功ifs.open("person.txt", ios::in | ios::binary);if(!ifs.is_open()){cout &lt;&lt; "文件打开失败";return;}4.读文件Person p;ifs.read((char *)&amp;p, sizeof(Person));cout &lt;&lt;p.m_Name &lt;&lt;' ' &lt;&lt; p.mAge;//5.关闭文件ifs.close;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>模板的概念<br>建立通用的模具，提高复用性</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;函数声明和定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>template -声明创建模板</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namesapce std;void swapInt(int &amp;a, int &amp;b){int temp = a;a = b;b = temp;}void swapDouble(double &amp;a, double &amp;b){double temp = a;a = b;b = temp;}//函数模板template&lt;tempname T&gt;void mySwap(T &amp;a, T &amp;b){T temp = a;a = b;b = temp;}void test01(){int a = 10;int b = 20;//两种方式使用函数模板1.自动类型推导mySwap(a, b);2.显示指定类型mySwap&lt;int&gt;(a, b);//提高复用性，类型参数化}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>//函数模板注意事项<br>//1.自动类型推导，必须推导出一致数据类型T才可以使用</p><pre class="line-numbers language-none"><code class="language-none">template&lt;calss T&gt; //typename可以替换成classvoid mySwap(T &amp;a, T &amp;b){T temp = a;a = b;b = temp;}//1.自动类型推导，必须推导出一致的数据类型T才可以使用//2.模板必须确定T的数据类型才可以使用temolate&lt;calss T&gt;void func(){}void test02(){func&lt;int&gt;();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="案例-封装排序模板"><a href="#案例-封装排序模板" class="headerlink" title="案例:封装排序模板"></a>案例:封装排序模板</h2><p>从小到大,排序算法为选择排序</p><p>分别利用char数组和int数组进行调试</p><pre class="line-numbers language-none"><code class="language-none">//交换的函数模板template&lt;class T&gt;void mySwap(T &amp;a, T &amp;b){T temp = a;a = b;b = temp;}template&lt;class T&gt;void mySort(T arr[], int len){for(int i=0; i&lt;1; i++){int max = i;for(int j = i+1; j&lt;len; j++){if(arr[max] &lt; arr[j]){max = j; // 更新最大值下标}}if(max != i) {mySwap(arr[max], arr[i]);}}}//提供打印数组模板void printArray(T arr[], int len){for(int i=0; i&lt;len; i++){cout &lt;&lt; a[i];}}void test01(){//测试char数组char charArr[] = "ahdisua";int num = sizeof(charArr) / sizeof(char);mySort(charArr, num);printArry(charArr, num);}void test02(){int intArr[] = {3, 3,3,45,5,5,6,6};int num = sizeof(intArr)/sizeof(int);mySort(intArr, num);printArray(intArr, num);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="普通函数和函数模板的区别"><a href="#普通函数和函数模板的区别" class="headerlink" title="普通函数和函数模板的区别"></a>普通函数和函数模板的区别</h2><p>普通函数调用时可以发生自动类型转换(隐式类型转换)</p><p>函数模板调用时,如果利用自动类型推导就不会发生隐式类型转换</p><p>如果利用显示指定类型的方式,可以发生隐式类型转换</p><pre class="line-numbers language-none"><code class="language-none">```## 普通函数和函数模板的调用规则如果函数模板和普通函数都可以实现,优先调用普通函数可以通过空模板参数列表来强制调用函数模板**myPrint&lt;&gt;(a, b)**函数模板也可以发生重载如果函数模板可以产生更好的匹配,优先调用函数模板<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>void myPrint(int a, int b)<br>{<br>    cout &lt;&lt; “调用的普通模板” &lt;&lt; endl;<br>}</p><p>template<class t=""><br>void myPrint(T a, T b)<br>{<br>    cout &lt;&lt; “调用的模板” &lt;&lt; endl;<br>}</class></p><p>template<class t=""><br>void myPrint(T a, T b)<br>{<br>    cout &lt;&lt; “调用的模板” &lt;&lt; endl;<br>}<br>使用两个char传入时, 会优先使用类模板而不是去类型转换</class></p><pre class="line-numbers language-none"><code class="language-none">类模板和普通函数重名的情况最好不要出现### 可以用输出值的方式验证参数匹配## 对比两个数据是否相等函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>//自定义数据类型对比</p><p>template<class t=""><br>bool myCompare(T &amp;a, T &amp;b);</class></p><p>//具体化Person的实现代码,具体化优先调用<br>template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2)<br>{<br>    if(p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)<br>    {<br>    return true;<br>    }<br>    else{<br>    return false;<br>    }<br>}</p><pre class="line-numbers language-none"><code class="language-none"># 类模板<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> template&lt;class NameType, class AgeType = int&gt;<br> class Person<br> {<br> public:<br>     Person(NameType name, AgeType age)<br>     {<br>     this-&gt;m_Name = name;<br>     this-&gt;m_Age = age;<br>     }</p><pre><code> NameType m_Name; AgeType m_Age;</code></pre><p> }</p><p> void test01()<br> {<br>     Person&lt;string, int&gt; p(“孙悟空”, 1000);//正确,只能用显示指定类型<br>     p.showPerson();<br> }</p><p> void test02()<br> {<br>     Person<string> p(“猪八戒”, 999);<br> }<br> </string></p><pre class="line-numbers language-none"><code class="language-none">## 类模板和函数模板区别类模板没有自动类型推导的使用方式类模板在模板参数列表中可以有默认参数## 类模板中成员函数创建时机类模板中成员函数和普通类成员函数创建时机是有区别的普通类成员函数一开始就可以创建类模板中的成员函数在调用时才创建可以故意写错误代码,看调用报不报错来确定调用机制![image-20231129133539877](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129133539877.png)1.具体参数模板传递````void test01(Person&lt;string, int&gt; &amp;P1);````2.参数模板化传递<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>template&lt;class T1, T2&gt;<br>void printPerson2(Person&lt;T1, T2&gt;&amp;p)<br>{<br>    p.showPerson();<br>    cout &lt;&lt; “T1的类型为: “ &lt;&lt; typid(T1).name() &lt;&lt; endl;<br>    //typid可以调用出类型<br>    cout &lt;&lt; “T2的类型为:” &lt;&lt; typid(T2).name() &lt;&lt; endl;<p></p><p>}</p><pre class="line-numbers language-none"><code class="language-none">3.整个类模板化````template&lt;class T&gt;void printPerson3(T &amp;p){p.showPerson();}test03(){Person&lt;string, int&gt;p("唐僧", 30);}````## 子类继承模板化的父类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>template<class t=""><br>class Base<br>{<br>    T m;<br>};</class></p><p>//class Son :public Base //错误,必须知道父类中的T才能继承给子类<br>classe Son :public Base<int><br>{</int></p><p>};</p><p>void test01()<br>{<br>    Son s1;<br>}</p><p>//如果灵活指定父类中T类型,子类也需要变类模板<br>但是子类创建对象时要指定父类类型和子类自己的类型<br>template&lt;class T1, class T2&gt;<br>class Son2 :public Base<t2><br>{<br>        T1 boj;<br>};</t2></p><pre class="line-numbers language-none"><code class="language-none">## 类模板成员函数类外实现<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>template&lt;class T1, class T2&gt;<br>class Person<br>{<br>public:<br>    Person(T1 name, T2 age);</p><pre><code>void showPerson();T1 m_Name;T2 m_Age;</code></pre><p>};</p><p>//构造函数类外实现<br>template&lt;class T1, class T2&gt;<br>Person&lt;T1, T2&gt;::Person(T1 name, T2 age)<br>{<br>    this-&gt;m_Name = name;<br>    this-&gt;m_Age = age<br>}<br>//使用类模板的成员函数时也要加上类模板,哪怕函数实现中用不到<br>template&lt;class T1, class T2&gt;<br>void Person&lt;T1, T2&gt;::showPerson()<br>{<br>    cout &lt;&lt; this-&gt;m_Name &lt;&lt; “年龄: “ &lt;&lt; this-&gt;m_Age &lt;&lt; endl;<br>}</p><p>void test01()<br>{<br>    Person&lt;string, int&gt; P(“Tom”, 20);<br>    P.showPerson();<br>}<br>int main()<br>{</p><p>}</p><pre class="line-numbers language-none"><code class="language-none">## 类模板分文件编写问题以及解决<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>class Person<br>{<br>public:<br>    Person(T1 name, T2 age);<br>    void showPerson();<br>    T1 m_Name;<br>    T2 m_Age;<br>};</p><p>template&lt;class T1, class T2&gt;<br>Person&lt;T1, T2&gt;::Person(T1 name, T2 age)<br>{</p><p>}</p><pre class="line-numbers language-none"><code class="language-none">类模板中成员函数在链接阶段未创建,创建时机在调用阶段第一种解决方法:直接包含源文件第二种解决方案:将.h和.cpp中的内容写到一起, 将后缀名改为.hpp直接`include"person.hpp"## 类模板与友元<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>template&lt;class T1, class T2&gt;<br>class Person<br>{<br>public:<br>    Person(T1 name, T2 age)<br>    {<br>    this-&gt;m_Name = name;<br>    this-&gt;m_Age = age;<br>    }</p><p>private:<br>    T1 m_Name;<br>    T2 m_Age;<br>}</p><pre><code>模板配合友元函数的类内和类外实现全局函数类内实现-直接在类内声明友元即可全局函数类外实现-需要提前让编译器知道全局函数的存在![image-20231129231229528](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129231229528.png)![image-20231129231245441](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231129231245441.png)</code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类和对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数重载</title>
      <link href="/2023/10/14/han-shu-chong-zai/"/>
      <url>/2023/10/14/han-shu-chong-zai/</url>
      
        <content type="html"><![CDATA[<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><p>函数名可以相同,提高复用性</p><p>函数重载满足条件:</p><p>同一个作用域下  函数名称相同 函数参数类型不同或个数不同或顺序不同</p><p><strong>注意</strong>:函数返回值不能作为函数重载的条件</p><p>函数重载的注意事项</p><p>1.引用作为重载的条件</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void fuc(int &amp;a){cout &lt;&lt; "fuc(int &amp;a)调用" &lt;&lt; endl;}void fuc(const int &amp;a){    cout &lt;&lt; "fuc(const int&amp; a)调用"  &lt;&lt; endl;}//传变量调用第一个,传不可修改的常量用第二个int a = 1;fuc(a);func(1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.函数重载碰到默认参数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func2(int a, int b=0);void func2(int a);//如果像这样调用函数就会出错:二义性出现导致冲突func2(2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp函数重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2023/10/11/mian-xiang-dui-xiang/"/>
      <url>/2023/10/11/mian-xiang-dui-xiang/</url>
      
        <content type="html"><![CDATA[<p> c++在执行时,内存分为4个区域</p><h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><p>代码区:存放函数体的二进制代码,由操作系统管理</p><p>全局区:存放全局变量和静态变量和常量</p><p>栈区: 由编译器自动分配和释放,存放函数的参数值,局部变量等</p><p>堆区:由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</p><h3 id="四个区意义"><a href="#四个区意义" class="headerlink" title="四个区意义:"></a>四个区意义:</h3><p>不同区放的数据赋予不同的生命周期,给我们更大的灵活编程</p><h2 id="1-1程序运行前"><a href="#1-1程序运行前" class="headerlink" title="1.1程序运行前"></a>1.1程序运行前</h2><p>在程序编译后,生成了exe可执行程序,未执行该程序前分为两个区域</p><p>代码区:</p><p>​存放cpu执行的机器指令</p><p>​代码区是共享的,共享的目的是对于频繁被执行的程序,,只要在内存中有一份代码即可</p><p>​代码区是只读的,使其只读的原因是防止程序意外的修改了它的指令</p><p>全局区:</p><p>​全局变量和静态变量存放在此</p><p>​全局区还包含常量区,字符串常量和其他常量也存放在此</p><p>该区域数据在程序结束后由操作系统释放</p><table><thead><tr><th><strong>不在全局区中</strong></th><th><strong>全局区</strong></th></tr></thead><tbody><tr><td>局部变量,const修饰的局部变量(局部常量)</td><td><br>全局变量<br>静态变量 static关键字<br>常量<br>字符串常量<br>const修饰的全局变量(全局常量)</td></tr></tbody></table><h1 id="栈区"><a href="#栈区" class="headerlink" title="栈区:"></a>栈区:</h1><p>栈区数据注意事项:–不要返回局部变量的地址//非法操作,不过返回之后的 第一次操作编译器会保留之前局部变量地址的内容</p><p>//栈区的数据由编译器管理开辟和释放</p><p>void fu</p><h1 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h1><p>int* p = new int(10);</p><p>delete p;</p><p>int *arr = new int[10];//开辟数组</p><p>删除数组时:delete[] arr;</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用:"></a>引用:</h1><p>引用必须初始化,且不可更改了</p><p>引用作为函数返回值</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int&amp; test02(){    static int a = 10;//静态变量,存放在全局区,全局区上的数据在程序结束后释放    return a;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数调用作为左值用法 </p><p>int &amp;ref  = test02();</p><p>test02() = 1000;//如果函数的返回值是引用,这个函数调用可以作为左值</p><h2 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质:"></a>引用的本质:</h2><p>在c++内部实现是一个指针常量</p><p>int&amp; ref = a;</p><p>发现是引用,转换为int* const ref = &amp;a;</p><p>ref = 20;内存发现引用,转换成指针*ref = 20;</p><h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><p>应用场景来修饰形参,防止误操作</p><p>const int &amp;ref = 10;//直接int&amp; ref = 10;会报错,因为引用本身需要一个合法的内存空间,因此这行错误</p><p>//加上const之后, 编译器将代码修改为int temp = 10; const int&amp; ref = temp;</p><p>加入const之后变成只读不可修改</p><p>void showValue(const int &amp;val){</p><p>​cout &lt;&lt; “val = “ &lt;&lt; val &lt;&lt; endl;</p><p>}</p><h1 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h1><p>int fuc(int a, int b = 20, int c = 30){</p><p>}</p><p>fuc(10);</p><p>如果某个位置已经有了默认参数,那么从这个位置往后,从左到右都必须有默认值</p>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opengl教程</title>
      <link href="/2023/10/07/opengl-jiao-cheng/"/>
      <url>/2023/10/07/opengl-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="头文件系列"><a href="#头文件系列" class="headerlink" title="头文件系列:"></a>头文件系列:</h3><p>#include&lt;glad/glad.h&gt;</p><p>#include&lt;GLFW/glfw3.h&gt;</p><p>//建议在自己的glcommin.h头文件里写这两行, 然后用gl和glfw就导入这个glcommon.h这样就能保证顺序不乱,其他gl库类似</p><p>glfw-跨平台的opengl窗口管理库</p><p>加上错误处理这个次要干扰项:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">初始化GLFW这个库    glfwInit(); //初始化glfw这个库if(!glfwInit()) {​throw std::runtime_error("faliled to initialize GLFW");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//使用glfw创建一个窗口:auto window = glfwCreatWindow(640, 480, "Example");创建一个宽640像素,长640像素, 标题为"Example"的窗口创建完窗口后就要开始绘制图案了, 如何让gl函数知道要在哪一个窗口上画图呢? Opengl有一个概念叫做上下文    画一个方块从哪画呢?先告诉上下文语境:glfwMakeContextCurrent(window);GLFWwindow *window = glfwCreatWindow(640, 480, "Example", NULL, NULL);if(!window) {    glfwTerminate();    throw std::runtime_error("GLFW failed to create window");    glfwMakeContextCurrent(window);} 初始化GLAD库//有了上下文之后,就可以初始化GLAD这个库了     gladLoadGL(); //处死话GLAD,加载函数指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">glfwInit();glfwMakeContextCurrent(window);gladLoadGL();while(!glfwWindowShouldClose(window)){    //画图    render();//我们决定把画图部分统一封装在另一个render函数里面       // glFlush();        //以前的窗口都是单缓冲的,现在glfw创建窗口都是双缓冲的 ,需要调用glfwSwapBuffers代替glFlush        glfwSwapBuffers(window);        glfwPollEvents();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>acwing刷题记录</title>
      <link href="/2023/10/05/acwing-shua-ti-ji-lu/"/>
      <url>/2023/10/05/acwing-shua-ti-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="753平方矩阵"><a href="#753平方矩阵" class="headerlink" title="753平方矩阵"></a>753平方矩阵</h1><p><a href="https://www.acwing.com/solution/content/71619/">AcWing 753. 平方矩阵 I（曼哈顿距离思想求解+蛇形矩阵思想求解+观察法求解） - AcWing</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main(){int n;while(cin &gt;&gt; n, n){for(int i=0; i&lt;n; i++){for(int j = 0; j&lt;n; j++){cout &lt;&lt; min(min(i+1, j+1), min(n-i, n-j)) &lt;&lt;' ';}cout &lt;&lt; endl ;}        cout &lt;&lt; endl;}}//解法二:利用蛇形矩阵偏移量解法#include&lt;iostream&gt;using namespace std;const int N = 110;int a[N][N];int n;int main(){   while(cin&gt;&gt; n, n){   int dx[] = { -1, 0, 1, 0};    int dy[] = { 0, 1, 0, -1};    int d = 1;    int num = 1, x=0, y=0;    for(int i=0; i&lt;n*n; i++){        a[x][y] = num;        int k = x + dx[d];        int j= y+ dy[d];        if(k&lt;0 || k&gt;=n || j&lt;0 ||j&gt;=n || a[k][j]){            d  = (d+1) %4;            if(d == 1){              num++;            }        }    }    for(int i=0; i&lt;n; i++){        for(int j=0; j&lt;n; j++){            cout &lt;&lt; a[i][j] &lt;&lt; ' ';        }        cout &lt;&lt; endl;    }       cout &lt;&lt; endl;   }}//曼哈顿距离法:#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main(){    int n;    while(cin &gt;&gt; n, n ){        for (int i = 0; i &lt; n; i ++){            for (int j = 0; j &lt; n; j ++){                if (n % 2)                     cout &lt;&lt; (n + 1) / 2 - max(abs(n / 2 - i), abs(n / 2 - j)) &lt;&lt; ' ';                else                    cout &lt;&lt; (n + 1) / 2.0 - max(abs((n - 1) / 2.0 - i), abs((n - 1) / 2.0 - j)) &lt;&lt; ' ';            }            cout &lt;&lt; endl;        }        cout &lt;&lt; endl;    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="756蛇形矩阵"><a href="#756蛇形矩阵" class="headerlink" title="756蛇形矩阵"></a>756蛇形矩阵</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N = 110;int  n,m;int a[N][N];int main (){    cin &gt;&gt; n &gt;&gt; m;    int dx[] = { -1, 0, 1, 0};    int dy[] = { 0, 1, 0, -1};    int d = 1, x=0, y=0;    for(int i=1; i&lt;=n * m; i++){        a[x][y] = i;        int k = x + dx[d];        int j = y + dy[d];        if(k&lt;0 ||j&lt;0 ||k&gt;=n || j &gt;=m || a[k][j]){            d = (d+1)%4;        }        x = x + dx[d];        y = y + dy[d];    }    for(int i=0, i&lt; n; i++){        for(int j=0; j&lt; m; j++){            cout &lt;&lt; a[i][j] &lt;&lt;' ';        }        cout &lt;&lt; endl;    }        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstring&gt;memset(arr, 0, n*sizeof (int)/*或者sizeof int,可以不加括号*/);memset(arr, -1, n*sizeof(int));memcpy(dest, src, sizeof(src));/拷贝数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>c语言方法</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> s<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//不能读含有空格,换行符的字符串</span><span class="token function">gets</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//能读取含空格的字符串,同时自动去掉换行符\n</span><span class="token function">fgets</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> N<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//能读空格且能读\n</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>c++方法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;string&gt;string str;cin &gt;&gt; str; //不能读取含空格,换行符的字符串getline(cin, str);//能读取含空格的字符串,同时自动去掉换行符\n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串操作</p><p>c方法</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstring&gt;</span></span><span class="token keyword">char</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">strlen</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// o(N)复杂度,使用前最好用变量保存字符串长度</span><span class="token function">strcat</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把字符串b拼接到a之后,拼接后的字符串保存在a中</span><span class="token function">strcmp</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//根据字典排序比较字符串</span><span class="token function">strcpy</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//把a中的内容拷贝到字符串b</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>c++方法:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str;string s(5, 'a');//构造重复字符的字符串str.empty(); //判空str.size(); //长度, 与strlen()不同的是这个复杂度为O(1),不用额外的变量保存str.c_str();//转换成char数组, 此时才可用printf输出str.substr(begin, end); //子串str.pop_back(); //删除最后一个字符//字符比较"&gt;" , "&lt;"//字符拼接"+"for(char ch : str) {...} //遍历(不可修改字符)for(char &amp;ch : str){...} //遍历(可修改字符)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意:使用+对字符串进行拼接时,要求两边至少有一个string对象, 即str = “a” + “b”; 会报错</p><h2 id="字符串流"><a href="#字符串流" class="headerlink" title="字符串流"></a>字符串流</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;sstream&gt;string s;stringstream ssin(s);while(ssin &gt;&gt; s){....} //按空格拆分s,例如英语句子拆分单词//可用如下代码代替:while(cin &gt;&gt; word) {    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>char数组难点:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char a[] = {'C', '+', '+'};char b[4] = {'D', '+', '+', '\0'};char c[5] = {'E', '+', '+', '\0'};// 最后一个位置会补\0cout &lt;&lt; a &lt;&lt; endl;// 输出"C++D++"，因为字符数组a不会自动添加'\0'，cout会读取到b的部分<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="循环相克令"><a href="#循环相克令" class="headerlink" title="循环相克令:"></a>循环相克令:</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;string&gt;#include&lt;iostream&gt;#incldue&lt;cstdio&gt;using namespace std;int main(){    string A;    while(getline(cin, A)){        for(int i = 0; i&lt; A.size(); i++){            if(A.find(A[i]) == A.rfind(A[i])){                cout &lt;&lt; A[i] &lt;&lt; endl;                                return 0;            }        }    }    printf("no");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;int alphabet[26];int main() {    string s;    cin &gt;&gt; s;            for(auto i : s){        alphabet[s[i] -'a']++;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="求两数的最大值"><a href="#求两数的最大值" class="headerlink" title="求两数的最大值"></a>求两数的最大值</h3><p>max(a, b) = (a+b+abs(a-b))/2;</p><p>数组处理:初始化下标类:用这个方法初始化时有点麻烦,但是后面操作时很方便</p><h3 id="规律题总结"><a href="#规律题总结" class="headerlink" title="规律题总结:"></a>规律题总结:</h3><p>先枚举情况,然后把其中一个变量用未知数表示,其他的类推</p><p>行号 起点,终点</p><p>48:字符’0’</p><h2 id="string中有用的函数"><a href="#string中有用的函数" class="headerlink" title="string中有用的函数:"></a>string中有用的函数:</h2><p>把最后一个字符删掉:s.pop_back();</p><h1 id="766局部性判断-第一类双指针算法"><a href="#766局部性判断-第一类双指针算法" class="headerlink" title="766局部性判断+第一类双指针算法"></a>766局部性判断+第一类双指针算法</h1><h1 id="计算算法时间"><a href="#计算算法时间" class="headerlink" title="计算算法时间:"></a>计算算法时间:</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;ctime&gt;int time = clock();//单位是毫秒````  cout &lt;&lt; clock() - time ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="将带空格的字符串转换成字符串流"><a href="#将带空格的字符串转换成字符串流" class="headerlink" title="将带空格的字符串转换成字符串流"></a>将带空格的字符串转换成字符串流</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;sstream&gt;getline(cin, s);stringstream ssin(s);string a,b, c, d;ssin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​<strong>或者用c语言的形式是</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdio&gt;char s[1000];fgets(s, 1000, stdin);int a, b;char str[1000];double c;sscanf(s, "%d%s%d%lf", &amp;a, str, &amp;b, &amp;c);while(~sscanf)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="771-第一类双指针法"><a href="#771-第一类双指针法" class="headerlink" title="771 第一类双指针法"></a>771 第一类双指针法</h1><h1 id="777"><a href="#777" class="headerlink" title="777"></a>777</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int main(){    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="静态变量相当于开了一个只有该函数能用的全局变量-而且开在堆里面-不会爆栈"><a href="#静态变量相当于开了一个只有该函数能用的全局变量-而且开在堆里面-不会爆栈" class="headerlink" title="静态变量相当于开了一个只有该函数能用的全局变量,而且开在堆里面,不会爆栈"></a>静态变量相当于开了一个只有该函数能用的全局变量,而且开在堆里面,不会爆栈</h1><h1 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参:"></a>函数传参:</h1><h2 id="二维数组传参时-要把第二个参数带上void-output-int-a-空格-3-或者把两个参数全带上-其他的都不行-扩展-如果是多维数组-只有第一维度的数组可以省略-其他的都不可以"><a href="#二维数组传参时-要把第二个参数带上void-output-int-a-空格-3-或者把两个参数全带上-其他的都不行-扩展-如果是多维数组-只有第一维度的数组可以省略-其他的都不可以" class="headerlink" title="二维数组传参时,要把第二个参数带上void output(int a [空格][ 3]);或者把两个参数全带上,其他的都不行//扩展:如果是多维数组,只有第一维度的数组可以省略,其他的都不可以"></a>二维数组传参时,要把第二个参数带上void output(int a [空格][ 3]);或者把两个参数全带上,其他的都不行//扩展:如果是多维数组,只有第一维度的数组可以省略,其他的都不可以</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void output(int a[][3]);//或a[3][3]或int(*a)[3];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数默认值在后面</p><p>数组指针:int a[10];//sizeof a;返回的是a的长度</p><p>指针数组int a[]; //sizeof a;返回的是指针的长度(64位系统指针长度就是八个字节)</p><p>inline内联函数,只适合调用很短小的,逻辑简单的,递归函数不支持inline</p><h2 id="递归要点"><a href="#递归要点" class="headerlink" title="递归要点:"></a>递归要点:</h2><p>中止递归值,递归的运算函数及其参数拆解成有规律的符号乘以递归函数直到中止递归,然后进行值的返回</p><h1 id="占位参数"><a href="#占位参数" class="headerlink" title="占位参数:"></a>占位参数:</h1><p>//返回值类型  函数名 (数据类型) { }</p><p>//目前阶段的占位参数,我们还用不到,后面课程会用到</p><p>void func(int a, int) {</p><p>}</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>10_1号想点事情</title>
      <link href="/2023/10/01/10-1-hao-xiang-dian-shi-qing/"/>
      <url>/2023/10/01/10-1-hao-xiang-dian-shi-qing/</url>
      
        <content type="html"><![CDATA[<p> 我要好好地把游戏程序员给做好,还得把英语学好</p><p>先想办法赚钱换一台好一点的电脑</p><p>然后攒钱去加拿大留学</p><p>以后尽可能留在加拿大</p><p>有时候想想那些既得利益者的嘴脸真够恶心的,曾经有个那样的女朋友真是不幸,唉,痛苦</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>游戏点子</title>
      <link href="/2023/09/26/you-xi-dian-zi/"/>
      <url>/2023/09/26/you-xi-dian-zi/</url>
      
        <content type="html"><![CDATA[<p> 打破次元壁式:有各种画风的人物混战,依据对手受到的伤害大小来获取积分(一般伤害高的被打时受到的伤害也高),每场积分排名,根据区间设置奖励,有排位制和娱乐制两种</p><p>擂台赛:玩家打擂的形式,决出胜负后可以在随机出现的三种buff中选一种,游戏会对连胜数进行排名,区榜,省榜,国榜.一般又系统自动匹配对手,但是若</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构习题集</title>
      <link href="/2023/09/23/shu-ju-jie-gou-xi-ti-ji/"/>
      <url>/2023/09/23/shu-ju-jie-gou-xi-ti-ji/</url>
      
        <content type="html"><![CDATA[<p>​司马习题集</p><h3 id="链表合并-排序"><a href="#链表合并-排序" class="headerlink" title="链表合并+排序"></a>链表合并+排序</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">int</span> grade<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span>node<span class="token punctuation">;</span>node<span class="token operator">*</span> <span class="token function">initList</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    node<span class="token operator">*</span> head <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token operator">*</span> temph <span class="token operator">=</span> head<span class="token punctuation">;</span>    node<span class="token operator">*</span> temp<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        temp <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token operator">-&gt;</span>num<span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token operator">-&gt;</span>grade<span class="token punctuation">)</span><span class="token punctuation">;</span>        temp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        temph<span class="token operator">-&gt;</span>next <span class="token operator">=</span> temp<span class="token punctuation">;</span>        temph <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span>node<span class="token operator">*</span> <span class="token function">mergList</span><span class="token punctuation">(</span>node<span class="token operator">*</span> a<span class="token punctuation">,</span> node<span class="token operator">*</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> all<span class="token punctuation">)</span> <span class="token punctuation">{</span>    node<span class="token operator">*</span> tempa <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tempa<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tempa <span class="token operator">=</span> tempa<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    tempa<span class="token operator">-&gt;</span>next <span class="token operator">=</span> b<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    node<span class="token operator">*</span> tempb <span class="token operator">=</span> b<span class="token punctuation">;</span>    node<span class="token operator">*</span> temp<span class="token punctuation">;</span>    node<span class="token operator">*</span> nmin<span class="token punctuation">;</span>    <span class="token keyword">int</span> imin<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> all<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        nmin <span class="token operator">=</span> a<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        imin <span class="token operator">=</span> a<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>num<span class="token punctuation">;</span>        temp <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">-&gt;</span>next<span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">-&gt;</span>num <span class="token operator">&lt;</span> imin<span class="token punctuation">)</span> <span class="token punctuation">{</span>                imin <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>num<span class="token punctuation">;</span>                nmin <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        tempb<span class="token operator">-&gt;</span>next <span class="token operator">=</span> temp<span class="token punctuation">;</span>        tempb <span class="token operator">=</span> tempb<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> m<span class="token punctuation">,</span> n<span class="token punctuation">;</span>    node <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token operator">*</span>b<span class="token punctuation">,</span> <span class="token operator">*</span>ab<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token function">initList</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token function">initList</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    ab <span class="token operator">=</span> <span class="token function">mergList</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> m<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>m<span class="token operator">+</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ab <span class="token operator">=</span> ab<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> ab<span class="token operator">-&gt;</span>num<span class="token punctuation">,</span> ab<span class="token operator">-&gt;</span>grade<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双向链表设计"><a href="#双向链表设计" class="headerlink" title="双向链表设计"></a>双向链表设计</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">line<span class="token operator">*</span> <span class="token function">initLine</span><span class="token punctuation">(</span>line<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> number<span class="token punctuation">,</span> pos<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> input_data<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入创建结点的大小\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>number <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//边界条件考虑</span>    <span class="token punctuation">}</span>    <span class="token comment">//头结点创建</span>    head <span class="token operator">=</span> <span class="token punctuation">(</span>line<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head<span class="token operator">-&gt;</span>pre <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入第%d个数据\n"</span><span class="token punctuation">,</span> pos<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>input_data<span class="token punctuation">)</span><span class="token punctuation">;</span>    head<span class="token operator">-&gt;</span>data <span class="token operator">=</span> input_data<span class="token punctuation">;</span>        line<span class="token operator">*</span> list <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>pos<span class="token operator">&lt;=</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        line<span class="token operator">*</span> body <span class="token operator">=</span> <span class="token punctuation">(</span>line<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        body<span class="token operator">-&gt;</span>pre <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        body<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入第%d个数据\n"</span><span class="token punctuation">,</span> pos<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>input_data<span class="token punctuation">)</span><span class="token punctuation">;</span>        body<span class="token operator">-&gt;</span>data <span class="token operator">=</span> input_data<span class="token punctuation">;</span>                list<span class="token operator">-&gt;</span>next <span class="token operator">=</span> body<span class="token punctuation">;</span>        body<span class="token operator">-&gt;</span>pre <span class="token operator">=</span> list<span class="token punctuation">;</span>        list <span class="token operator">=</span> list<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双向链表插入数据"><a href="#双向链表插入数据" class="headerlink" title="双向链表插入数据"></a>双向链表插入数据</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">line<span class="token operator">*</span> <span class="token function">insertLine</span><span class="token punctuation">(</span>line<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> add<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//三个参数分别为:进行此操作的双链表,插入数据,插入位置</span>    <span class="token comment">//新建数据域data的结点</span>    line<span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token punctuation">(</span>line<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    temp<span class="token operator">-&gt;</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    temp<span class="token operator">-&gt;</span>pre <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    temp<span class="token operator">-&gt;</span>enxt <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">//插入到链表头,要特殊考虑</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>add <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        temp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        head<span class="token operator">-&gt;</span>pre <span class="token operator">=</span> temp<span class="token punctuation">;</span>        head <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>        line<span class="token operator">*</span> body <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">//找到要插入位置的前一个结点</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>add<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            body <span class="token operator">=</span> body<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>body<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            body<span class="token operator">-&gt;</span>next <span class="token operator">=</span> temp<span class="token punctuation">;</span>            temp<span class="token operator">-&gt;</span>pre <span class="token operator">=</span> body<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            body<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>pre <span class="token operator">=</span> temp<span class="token punctuation">;</span>            temp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> body<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            body<span class="token operator">-&gt;</span>next <span class="token operator">=</span> temp<span class="token punctuation">;</span>            temp<span class="token operator">-&gt;</span>pre <span class="token operator">=</span> body<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双向链表实现贪吃蛇"><a href="#双向链表实现贪吃蛇" class="headerlink" title="双向链表实现贪吃蛇"></a>双向链表实现贪吃蛇</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SnakeNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span class="token comment">//记录结点所在的行和列</span>    <span class="token keyword">struct</span> <span class="token class-name">SnakeNode</span> <span class="token operator">*</span>pre<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">SnakeNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token punctuation">}</span>Node<span class="token punctuation">,</span> <span class="token operator">*</span>pNode<span class="token punctuation">;</span><span class="token comment">//贪吃蛇移动过程,即链表所有结点从尾结点开始依次遍历到头结点向前移动一个位置</span>bool <span class="token function">Move</span><span class="token punctuation">(</span>pNode pHead<span class="token punctuation">,</span> <span class="token keyword">char</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    bool game_over <span class="token operator">=</span> false<span class="token punctuation">;</span>    pNode pt <span class="token operator">=</span> pTail<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环链表-单链表"><a href="#循环链表-单链表" class="headerlink" title="循环链表(单链表)"></a>循环链表(单链表)</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span>list<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//初始化结点</span>list <span class="token operator">*</span><span class="token function">initList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    list <span class="token operator">*</span> head <span class="token operator">=</span> <span class="token punctuation">(</span>list<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"创建失败,退出程序"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>        head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>                            <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在主函数中这样调用</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">list<span class="token operator">*</span> head <span class="token operator">=</span> <span class="token function">initList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>循环链表的创建操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">insert_list</span><span class="token punctuation">(</span>list<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入要插入的元素:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token operator">*</span> node <span class="token operator">=</span> <span class="token function">initList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token operator">-&gt;</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        list<span class="token operator">*</span> p<span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment">//找到最后一个数据</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>next<span class="token operator">!=</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>            p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>        node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="栈的设计"><a href="#栈的设计" class="headerlink" title="栈的设计"></a>栈的设计</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//栈的结点设计</span><span class="token comment">//单个结点设计,数据和下一个指针</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span> Node<span class="token punctuation">;</span><span class="token comment">//利用上面的结点创建栈,分别为指向头结点的top指针和计数用的count指针</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">stack</span><span class="token punctuation">{</span>    Node<span class="token operator">*</span> top<span class="token punctuation">;</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span>Link_Stack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>入栈操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Link_Stack <span class="token operator">*</span><span class="token function">Push_stack</span><span class="token punctuation">(</span>Link_Stack <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> elem<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    Node <span class="token operator">*</span>temp<span class="token punctuation">;</span>    temp <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//temp = new Node;</span>    temp<span class="token operator">-&gt;</span>data <span class="token operator">=</span> elem<span class="token punctuation">;</span>    temp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token operator">-&gt;</span>top<span class="token punctuation">;</span>    p<span class="token operator">-&gt;</span>top <span class="token operator">=</span> temp<span class="token punctuation">;</span>    p<span class="token operator">-&gt;</span>count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="栈-的基本操作"><a href="#栈-的基本操作" class="headerlink" title="栈 的基本操作"></a>栈 的基本操作</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//遍历栈,输出所有元素</span><span class="token keyword">int</span> <span class="token function">show_stack</span><span class="token punctuation">(</span>Link_Stack <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">*</span>temp<span class="token punctuation">;</span>    temp <span class="token operator">=</span> p<span class="token operator">-&gt;</span>top<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>top <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"错误:栈为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span> temp<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        temp <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速栈实现–数组栈"><a href="#快速栈实现–数组栈" class="headerlink" title="快速栈实现–数组栈"></a>快速栈实现–数组栈</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">maxn</span> <span class="token expression"><span class="token number">10000</span></span></span><span class="token comment">//结点设计</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">stack</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top<span class="token punctuation">;</span><span class="token punctuation">}</span>stack<span class="token punctuation">;</span><span class="token comment">//创建</span>stack <span class="token operator">*</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    stack <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token punctuation">(</span>stack <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"分配内存空间失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">memset</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>data<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token operator">-&gt;</span>top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//栈的top和bottom均为0</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment">//入栈push</span><span class="token keyword">void</span> <span class="token function">push</span> <span class="token punctuation">(</span>stack <span class="token operator">*</span>s<span class="token punctuation">,</span><span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    s<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>s<span class="token operator">-&gt;</span>top<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>    s<span class="token operator">-&gt;</span>top<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//出栈pop</span><span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span>stack<span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>top<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        s<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>s<span class="token operator">-&gt;</span>top<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        s<span class="token operator">-&gt;</span>top<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//模拟打印栈中元素</span><span class="token keyword">void</span> <span class="token function">print_stack</span><span class="token punctuation">(</span>stack <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">=</span>s<span class="token operator">-&gt;</span>top<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>n<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span> s<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//习惯性换行</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    stack <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//结点定义</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span>node<span class="token punctuation">;</span><span class="token comment">//队列定义, 队首指针和队尾指针</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">queue</span> <span class="token punctuation">{</span>    node <span class="token operator">*</span>front<span class="token punctuation">;</span><span class="token comment">//头指针</span>    node <span class="token operator">*</span>rear<span class="token punctuation">;</span><span class="token comment">//尾指针</span><span class="token punctuation">}</span>queue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始化</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//初始化结点</span>node<span class="token operator">*</span> <span class="token function">init_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    node<span class="token operator">*</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//初始化队列</span>queue<span class="token operator">*</span> <span class="token function">init_queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    queue<span class="token operator">*</span> q <span class="token operator">=</span> <span class="token punctuation">(</span>queue<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//建立失败,退出</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//头尾结点均赋值NULL</span>    q<span class="token operator">-&gt;</span>front <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    q<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> q<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断队列是否为空</p><p>判断队列头指针是否为空值即可</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">empty</span><span class="token punctuation">(</span>queue <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>front <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者直接用返回值进行更简单的判断(两者效果完全一样)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">empty</span><span class="token punctuation">(</span>queue <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> q<span class="token operator">-&gt;</span>front <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>queue <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    node<span class="token operator">*</span> n <span class="token operator">=</span> <span class="token function">init_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    n<span class="token operator">-&gt;</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    n<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        q<span class="token operator">-&gt;</span>front <span class="token operator">=</span> n<span class="token punctuation">;</span>        q<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        q<span class="token operator">-&gt;</span>rear<span class="token operator">-&gt;</span>next <span class="token operator">=</span> n<span class="token punctuation">;</span>        q<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h3><p>要在队列不为空的情况下进行操作(判空处理), 如果队列只有一个元素时要对头尾两个指针制空,并释放这个结点即可</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span>queue <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    node<span class="token operator">*</span> n <span class="token operator">=</span> q<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>front <span class="token operator">==</span> q<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span><span class="token punctuation">{</span>        q<span class="token operator">-&gt;</span>front <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        q<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        q<span class="token operator">-&gt;</span>front <span class="token operator">=</span> q<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遍历队列</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">printf_queue</span><span class="token punctuation">(</span>queue <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    node<span class="token operator">*</span> n <span class="token punctuation">;</span>    n <span class="token operator">=</span> q<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span> n<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        n <span class="token operator">=</span> n<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>计算队列中含有多少元素</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">calac</span><span class="token punctuation">(</span>queue<span class="token operator">*</span> q<span class="token punctuation">)</span><span class="token punctuation">{</span>    node<span class="token operator">*</span> n<span class="token punctuation">;</span>    n <span class="token operator">=</span> q<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        n <span class="token operator">=</span> n<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cnt<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">maxsize</span> <span class="token expression"><span class="token number">10</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">cir_queue</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">[</span>maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rear<span class="token punctuation">;</span>    <span class="token keyword">int</span> front<span class="token punctuation">;</span><span class="token punctuation">}</span>cir_queue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//入队操作</span><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>cir_queue <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>maxsize <span class="token operator">==</span> q<span class="token operator">-&gt;</span>front<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"溢出,无法入队\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        q<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> <span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>maxsize<span class="token punctuation">;</span>        q<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>q<span class="token operator">-&gt;</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//出队操作</span><span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span>cir_queue <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>rear <span class="token operator">==</span> q<span class="token operator">-&gt;</span>front<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"队列为空, 无法出队\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        q<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>q<span class="token operator">-&gt;</span>front<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        q<span class="token operator">-&gt;</span>front <span class="token operator">=</span> <span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>maxsize<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遍历循环队列</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>cir_queue <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> q<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">!=</span> q<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span><span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>maxsize<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span> q<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector<容器>"></a>Vector&lt;容器&gt;</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;vector&gt;//格式为vector&lt;Data_Types&gt; name;vector&lt;int&gt; v1; // 创建一个空向量v1vector&lt;int&gt; v2(10);vector&lt;int&gt; v3(10, 5);vector&lt;int&gt; v4(v3.begin(), v3.end());vector&lt;int&gt; v5(v4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>遍历</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; v;vector&lt;int&gt;::iterator it;for(it = v.begin(); it!=v.end();it++){    cout &lt;&lt; *it &lt;&lt;' ';}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>普通遍历:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i = 0; i&lt;v.size(); i++){    cout &lt;&lt; v[i] &lt;&lt;' ';}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><p>a)在向量尾添加新元素,并自动让容器大小增加一个</p><p>函数原型:</p><p>void push_back(const value_type&amp; val);</p><pre class="line-numbers language-none"><code class="language-none">v.push_back(10);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除向量尾的最后一个,并将容器大小减一个</p><p>原型:void pop_back();</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">v<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">k</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">inert</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> k<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> k<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v.erase(v.begin());v.erase(v.begin(), v.begin()+4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="将向量中所有元素清空"><a href="#将向量中所有元素清空" class="headerlink" title="将向量中所有元素清空"></a>将向量中所有元素清空</h3><pre class="line-numbers language-c+" data-language="c+"><code class="language-c+">v.clear();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="数据元素个数"><a href="#数据元素个数" class="headerlink" title="数据元素个数"></a>数据元素个数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="已开辟最大宽度capacity"><a href="#已开辟最大宽度capacity" class="headerlink" title="已开辟最大宽度capacity()"></a>已开辟最大宽度capacity()</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span>begin<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最大支持空间max-size"><a href="#最大支持空间max-size" class="headerlink" title="最大支持空间max_size()"></a>最大支持空间max_size()</h3><p>size_type max_size() const</p><pre class="line-numbers language-none"><code class="language-none">vector&lt;int&gt; v(5, 10);cout &lt;&lt; v.max_size() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="List容器"><a href="#List容器" class="headerlink" title="List容器"></a>List容器</h1><h3 id="头文件-include"><a href="#头文件-include" class="headerlink" title="头文件#include"></a>头文件#include<list></list></h3><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>explict list (const allocator_type&amp; alloc = allocator = allocator_type());</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> l1<span class="token punctuation">;</span> <span class="token comment">// 创建一个空链表</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">l2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建一个有十个空元素的链表</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">l3</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建一个有五个元素为20的链表</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">l4</span><span class="token punctuation">(</span>l3<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> l3<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建一个内容为l3的链表</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">l5</span><span class="token punctuation">(</span>l4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建一个内容为l4的链表,效果同上</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">lits&lt;int&gt; li;for(list&lt;int&gt;::iterator it=li.begin(); it!=li.end(); it++){    cout &lt;&lt; *it &lt;&lt;' ';}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常用接口-1"><a href="#常用接口-1" class="headerlink" title="常用接口"></a>常用接口</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//判断链表是否为空,空为真,不空为假bool empty() const;if(li.empty()){    cout &lt;&lt; "is empty()" &lt;&lt; endl;}else {    cout &lt;&lt; "not empty()" &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//获取链表元素的个数函数原型:size_type size() const;cout &lt;&lt; li.size() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//链表前插入push_front() &amp;&amp; 删除pop_front()push_front()表示在链表最前端插入一个元素,pop_front()表示在链表最前端删除一个元素函数原型    void push_front(const value_type&amp; val);void pop_front;li.push_front(10);li.pop_front();//链表后插入push_back() &amp;&amp; 删除pop_back()push_back()表示在链表尾插入一个数据,pop_back()表示将链表尾删除一个数据    函数原型:void push_back(const value_type&amp; val);void pop_back();li.push_back(10);li.pop_back();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插入insert()</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">li<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>li<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>li<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>li<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">k</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>li<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>li<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> k<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> k<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除一个或一个区间的元素,自动缩减空间使用</p><p>函数原型:</p><p>li.erase(li.begin());删除第一个元素</p><p>li.erase(li.begin(), li.begin()+4);删除前四个元素</p><h3 id="排序sort"><a href="#排序sort" class="headerlink" title="排序sort()"></a>排序sort()</h3><p>将整个链表变成升序状态,或者变成自定义的排序状态</p><p>函数原型:</p><p>void sort()</p><p>template<class compare=""> void sort(Compare comp)</class></p><p>举例子:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;list&gt;</span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token operator">&gt;</span>b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> li<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        li<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    li<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    li<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">li2</span><span class="token punctuation">(</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator it <span class="token operator">=</span> li<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">!=</span>li<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//排序前3 10 9 8 7 6 20</span>    li<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//排序后:</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator it <span class="token operator">=</span> li<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">!=</span>li<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        li2<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator it <span class="token operator">=</span> li2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">!=</span>li2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment">//自定义降序排序</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="逆序reverse"><a href="#逆序reverse" class="headerlink" title="逆序reverse()"></a>逆序reverse()</h3><p>stl默认降序方法reverse(), 类似于sort一样直接使用即可</p><p>void reverse()</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">li<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="stack栈容器"><a href="#stack栈容器" class="headerlink" title="stack栈容器"></a>stack栈容器</h1><p>头文件:</p><p>#include<stack></stack></p><p>初始化:</p><p>explicit stack(const container_type&amp; ctnr = container_type());</p><p>以int类型进行创建,其方式与vector无异</p><p>stack<int> s;</int></p><p>stack<int> v(s);</int></p><p>标准栈的创建方式是直接创建空栈, ,由于栈的特殊性质,让他拥有其他容器的参数可以这样创建,这种多参数的方式可能有些复杂,一般也很少这样使用</p><p>vector<int> v(3, 100);</int></p><p>stack&lt;int, vector<int> &gt; s(v);</int></p><p>通过标准的方式创建向量数组,然后通过复制构造函数 的方式进行创建,其内容就是vector数组的全部内容</p><h3 id="迭代器-2"><a href="#迭代器-2" class="headerlink" title="迭代器"></a>迭代器</h3><p>栈和队列都属于一种特殊的数据结构, 只能通过访问顶层数据并不断剔除数据的方式进行全部访问,因此没有直接 的迭代器</p><h2 id="使用栈-的方式实现斐波那契数列"><a href="#使用栈-的方式实现斐波那契数列" class="headerlink" title="使用栈 的方式实现斐波那契数列"></a>使用栈 的方式实现斐波那契数列</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct node{    int value;    int dir;};int StackFib(int n){    node w;    stack&lt;node&gt; s;    int sum = 0;        while(1)    {        while(1){            w.value = n;            w.dir = 1;            s.push(w);            n--;            if(n&lt;0)                break;        }        while(!s.empty())        {            w=s.top();            s.pop();            if(w.value == 0)                sum += 0;            else if(w.value == 1)                sum+=1;            else if(w.value != 0 &amp;&amp; w.value != 1 &amp;&amp; w.dir == 1)            {                w.dir =  2;                s.push(w);                n = w.value-2;                break;            }        }        if(s.empty())            break;    }    return sum;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;queue&gt;//初始化explict queue (const container_type&amp; ctnr = container_type());以int类型作为参数为例进行创建queue&lt;int&gt; q;queue&lt;int&gt; qoo(q);vector&lt;int&gt; v(3, 100);queue&lt;int, vector&lt;int&gt; &gt; s(v);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常用接口:</p><p>a)大小size()</p><p>返回队列元素的个数</p><p>size_type size() const</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; q.size() &lt;&lt; endl;//直接返回队列元素个数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><pre class="line-numbers language-none"><code class="language-none">void push(const value_type&amp; val)q.push(100);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="出队pop"><a href="#出队pop" class="headerlink" title="出队pop()"></a>出队pop()</h3><p>void pop()</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">q.pop();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="访问队头元素front"><a href="#访问队头元素front" class="headerlink" title="访问队头元素front()"></a>访问队头元素front()</h3><p>value_type&amp; front();</p><p>const value_type&amp; front() const;</p><pre class="line-numbers language-none"><code class="language-none">q.front()+= 500;//对队头元素进行修改cout &lt;&lt; q.front() &lt;&lt; endl;//直接输出内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="访问队尾元素back"><a href="#访问队尾元素back" class="headerlink" title="访问队尾元素back()"></a>访问队尾元素back()</h3><p>value_type&amp; back();</p><p>const value_type&amp; back() const;</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">q.back() += 500;cout &lt;&lt; q.back() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="判空操作empty"><a href="#判空操作empty" class="headerlink" title="判空操作empty()"></a>判空操作empty()</h3><p>bool empty() const;//空为真,非空为假</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(q.empty()){    cout &lt;&lt; q.front &lt;&lt; endl;    q.pop();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="队列操作"><a href="#队列操作" class="headerlink" title="队列操作"></a>队列操作</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;int main{    int n;    scanf("%d" , &amp;n);    queue&lt;int&gt; q;    int sum = 0;    for(int i = 0; i &lt; n;i++){        int s;        scanf("%d", &amp;s);        if(s == 1){            int num;            scanf("%d", &amp;num);            q.push(num);            sum++;        }else if(s == 2){            if(q.empty()){                printf("no");                return 0;            }else {                printf("%d\n", q.front());                sum--;                q.pop();            }        }else if(s == 3){            printf("%d\n", sum);        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct cmp{//这个比较要用结构体来表示    bool operator()(int &amp;a, int &amp;b) const    {        return a &gt; b;    }};priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; q;//自定义比较方法priority_queue&lt;int&gt; pq;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="常用接口-2"><a href="#常用接口-2" class="headerlink" title="常用接口"></a>常用接口</h3><p>大小size()</p><p>原型 size_type size() const;</p><p>cout &lt;&lt; q.size() &lt;&lt; endl;//直接返回队列中的元素</p><h3 id="入队push"><a href="#入队push" class="headerlink" title="入队push()"></a>入队push()</h3><p>函数原型: void push(const value_type&amp; val);</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">q.push(100);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="出队pop-1"><a href="#出队pop-1" class="headerlink" title="出队pop()"></a>出队pop()</h3><p>void pop()</p><p>q.pop();</p><h3 id="访问队头元素top"><a href="#访问队头元素top" class="headerlink" title="访问队头元素top()"></a>访问队头元素top()</h3><p>与标准队列不同,优先队列只允许访问队头元素</p><p>原型:</p><p>reference&amp; top();</p><p>const_reference&amp; top() const;</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; q.top() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="判空empty-同前"><a href="#判空empty-同前" class="headerlink" title="判空empty(),同前"></a>判空empty(),同前</h3><h1 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h1><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件:"></a>头文件:</h3><p>#include<set></set></p><p>初始化:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt; class T, class Compare = less&lt;T&gt;, class Alloc = allocator&lt;T&gt; &gt; class set;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个是值, 第二个是比较器,用于比较内容, 默认为less<key>即降序, 负责内存的分配和销毁</key></p><p>实际使用中,仅仅为其分配值就足以满足大部分需求</p><h3 id="迭代器-3"><a href="#迭代器-3" class="headerlink" title="迭代器"></a>迭代器</h3><p>c98标准</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(set&lt;int&gt;::iterator it = s.begin(); it!=s.end(); ++it)    cout &lt;&lt; *it &lt;&lt; ' ';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>c11标准</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(auto it = s.cbegin(); it!= s.cend(); ++it)    cout &lt;&lt; *it &lt;&lt; ' ';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>常用接口:</p><p>大小size()</p><p>size_type size() const;</p><p>cout &lt;&lt; s.size() &lt;&lt; endl;//直接返回元素个数\</p><h3 id="插入元素insert"><a href="#插入元素insert" class="headerlink" title="插入元素insert()"></a>插入元素insert()</h3><p>pair&lt;ierator, bool&gt; insert(const value_type&amp; val);</p><p>s.inert(i);</p><h3 id="删除元素erase"><a href="#删除元素erase" class="headerlink" title="删除元素erase()"></a>删除元素erase()</h3><p>删除一个元素,或者一个区间的元素,将会自动缩减空间使用</p><p>iterator erase (iterator position);</p><p>iterator erase (iterator first, iterator last);</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">s.erase(s.begin()); //使用迭代器的方法删除第一个元素s.erase(s.begin(), s.end());//删除一段内容.这里是全部删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>清空元素 clear()</p><p>清空元素但是占用最大内存空间还是不会改变的</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">s.clear();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>函数原型:</p><p>iterator find(const value_type&amp; val)const;</p><p>cout &lt;&lt; *s.find(4) &lt;&lt; endl;</p><p>s.erase(s.find(4));</p><h3 id="算法头文件"><a href="#算法头文件" class="headerlink" title="算法头文件:"></a>算法头文件:</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){    int a[6] = {1, 5, 9, 4, 6, 3};    sort(a, a+6);    for(int i=0;i&lt;6 ;i++){        cout &lt;&lt; a[i] &lt;&lt; ' ';    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="集合论和stl集合"><a href="#集合论和stl集合" class="headerlink" title="集合论和stl集合"></a>集合论和stl集合</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main(){    set&lt;int&gt; a, b;    vector&lt;int&gt; c;    a.insert(2);    a.insert(4);    a.insert(6);        b.insert(1);    b.insert(2);    b.insert(3);    b.insert(4);    b.insert(5);    b.insert(6);            set_union(a.begin(), a.end(), b.begin, b.end(), back_inserter(c));    for(vector&lt;int&gt;::iterator it = c.begin(); it!=c.end(); it++){        cout &lt;&lt; *it &lt;&lt; ' ';    }    cout &lt;&lt; endl;    c.clearl                set_intersection(a.begin(), a.end(), b.begin(), back_insertser(c));    for(vector&lt;int&gt;::iterator it = c.begin(); it!=c.end(); it++){        cout &lt;&lt; *it &lt;&lt; ' ';    }    cout &lt;&lt; endl;    c.clear;                set_difference(a.begin(), a.end(), b.begin(), back_insertser(c));    for(vector&lt;int&gt;::iterator it = c.begin(); it!=c.end(); it++){        cout &lt;&lt; *it &lt;&lt; ' ';    }    cout &lt;&lt; endl;    c.clear;        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构c/cpp</title>
      <link href="/2023/09/22/shu-ju-jie-gou-c-cpp/"/>
      <url>/2023/09/22/shu-ju-jie-gou-c-cpp/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span>除上文提到的两个函数外，在C<span class="token operator">++</span>中引入的对象思维，有一个极其类似于malloc函数的方法，就是new方法，但他们还是有一些区别的：new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C<span class="token operator">++</span>基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="头插法建立单链表"><a href="#头插法建立单链表" class="headerlink" title="头插法建立单链表"></a>头插法建立单链表</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">LinkedList LinkedListCreateH() {    Node *L;    L = (Node *)malloc(sizeof(Node));    L-&gt;next = NULL;        int x;    while(scanf("%d", &amp;x) != EOF) {        Node *p;        p = (Node*)malloc(sizeof(Node));        p-&gt;data = x;        p-&gt;next = L-&gt;next;        L-&gt;next = p;    }    return L;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="尾插法建立单链表"><a href="#尾插法建立单链表" class="headerlink" title="尾插法建立单链表"></a>尾插法建立单链表</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">LinkedList <span class="token function">LinkedListCreatT</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node <span class="token operator">*</span>L<span class="token punctuation">;</span>    L <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//申请头结点空间</span>    L<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    Node <span class="token operator">*</span>r <span class="token operator">=</span> L<span class="token punctuation">;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node <span class="token operator">*</span>p<span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//申请新的结点</span>        p<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>        r<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>        r <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    r<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> L<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="next数组构建"><a href="#next数组构建" class="headerlink" title="next数组构建"></a>next数组构建</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Next</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//next[2]=1可以通过第一次循环直接得出</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> T<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>i<span class="token operator">++</span><span class="token punctuation">;</span>    j<span class="token operator">++</span><span class="token punctuation">;</span>        next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>//只要有一次i和j不一样的话,j就会回到头重新开始比对,这是构建next数组的核心</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">Next</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>    next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> T<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>            next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//回溯</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">KMP</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>S<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">Next</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//根据模式串T, 初始化next数组</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span><span class="token function">strlen</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> S<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>        <span class="token keyword">else</span>         <span class="token punctuation">{</span>            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">KMP</span><span class="token punctuation">(</span><span class="token string">"ababcabcacbab"</span><span class="token punctuation">,</span> <span class="token string">"abcac"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>//上一个情况行的话就是跟着上一个继续,上一个不行的话就继续上一个,直到最开始的那个情况j ==0;</p><p>优化后的next()函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Next</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>T<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>    next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> T<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> T<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="邻接表-存储图和树"><a href="#邻接表-存储图和树" class="headerlink" title="邻接表   存储图和树"></a>邻接表   存储图和树</h3><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>​优化某些问题</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-25 124721.png)</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N = 100010;//head表示头结点的下标//e[i]表示结点i的值//ne[i]表示结点i的next指针//idx存储当前已经用到了哪个点int head, e[N], ne[N], idx;//初始化void init(){head = -1;idx = 0;}//将x插入到头结点void add_to_head(int x){e[idx] = x;ne[idx] = head;head = idx;}int main(){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-25 141144.png)</p><pre class="line-numbers language-none"><code class="language-none">int factorial(n){if(n == 0) return 1;else return  n*factorial(n-1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> ![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-25 141144.png)</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;void print() {char a;scanf("%c", &amp;a);if (a != '#')print();if (a != '#')printf("%c", a);}int main() {print();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分治思想"><a href="#分治思想" class="headerlink" title="分治思想"></a>分治思想</h2><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-11-25 153001.png)</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><pre class="line-numbers language-none"><code class="language-none">int s(int a[], int l, int r, int x){int i = l, j = r;for(int m=l; m&lt;=r; i++){int mid =i+j &gt;&gt; 1;    if(a[mid] &gt;= x) r = mid-1;    else i = mid+1;}return a[mid] == x ? 1 : 0}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp高级函数特性</title>
      <link href="/2023/09/20/cpp-gao-ji-han-shu-te-xing/"/>
      <url>/2023/09/20/cpp-gao-ji-han-shu-te-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="c-初始化"><a href="#c-初始化" class="headerlink" title="c++初始化"></a>c++初始化</h3><p>c++ 初始化 的花括号{}初始化方式为列表初始化</p><p>较为严格:初始化时不允许信息的丢失</p><h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><p>const int p = 9;</p><p>常量表达式是编译时确定的</p><h3 id="constexpr-关键字"><a href="#constexpr-关键字" class="headerlink" title="constexpr 关键字"></a>constexpr 关键字</h3><h3 id="四种细分显示转化语法"><a href="#四种细分显示转化语法" class="headerlink" title="四种细分显示转化语法"></a>四种细分显示转化语法</h3><p>static_cast </p><p>dynamic_cast</p><p>const_cast</p><p>reinterpret_cast</p><p>简单的io流控制</p><p>dec</p><p>hex oct ws endl setprecision(int) setw(int) </p><h3 id="for-声明-表达式"><a href="#for-声明-表达式" class="headerlink" title="for(声明, 表达式)"></a>for(声明, 表达式)</h3><p>如果进行写操作</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string s = "abcd";for(auto &amp;r: s) r+=1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>返回引用的函数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream.h&gt;int a[] = {232,434,34,34};int&amp; index(int i);void main() {    index(3) = 16;    cout &lt;&lt; "index(3) is :" &lt;&lt; index(3) &lt;&lt; endl;    cout &lt;&lt; "   a[3] is :" &lt;&lt; a[3] &lt;&lt; endl;}int&amp; index(int i){    return a[i];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数可以定义默认形参值"><a href="#函数可以定义默认形参值" class="headerlink" title="函数可以定义默认形参值"></a>函数可以定义默认形参值</h3><h3 id="typedef-using"><a href="#typedef-using" class="headerlink" title="typedef           using"></a>typedef           using</h3><h3 id="auto类型与decltype类型"><a href="#auto类型与decltype类型" class="headerlink" title="auto类型与decltype类型"></a>auto类型与decltype类型</h3><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Class Location{private:    int X, Y;public:    void initial(int initX, int initY);    int GetX();    int GetY();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;ctime&gt;#incldue&lt;cstdlib&gt;#incldue&lt;iostream&gt;using namespace std;int main(){    srand(time(NULL));    int lucky = rand()%10;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="c-使用控制符指定书写格式"><a href="#c-使用控制符指定书写格式" class="headerlink" title="c++使用控制符指定书写格式"></a>c++使用控制符指定书写格式</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iomanip&gt;#include&lt;iostream&gt;using namespace std;int main(){    cout &lt;&lt; oct &lt;&lt; 1234 &lt;&lt; '\n';//八进制数    cout &lt;&lt; dec &lt;&lt; 1234 &lt;&lt; '\n';//十进制数    cout &lt;&lt; hex &lt;&lt; 1234 &lt;&lt; '\n';//十六进制数        cout &lt;&lt; showbase;//显示基数    cout &lt;&lt; oct &lt;&lt; 1234 &lt;&lt; '\n';//八进制数    cout &lt;&lt; dec &lt;&lt; 1234 &lt;&lt; '\n';//十进制数    cout &lt;&lt; hex &lt;&lt; 1234 &lt;&lt; '\n';//十六进制数        cout &lt;&lt; setw(10) &lt;&lt; internal &lt;&lt; "abc\n";    cout &lt;&lt; setw(10) &lt;&lt; left &lt;&lt; "abc\n";    cout &lt;&lt; setw(10) &lt;&lt; right &lt;&lt; "abc\n";        cout &lt;&lt; setbase(10);    cout &lt;&lt; setw(10) &lt;&lt; internal &lt;&lt; -123 &lt;&lt; '\n';    cout &lt;&lt; setw(10) &lt;&lt; left &lt;&lt; -123 &lt;&lt; '\n';    cout &lt;&lt; setw(10) &lt;&lt; right &lt;&lt; -123 &lt;&lt; '\n';        cout &lt;&lt; setfill('*');    cout &lt;&lt; setw(10) &lt;&lt; internal &lt;&lt; -123 &lt;&lt; '\n';    cout &lt;&lt; setw(10) &lt;&lt; left &lt;&lt; -123 &lt;&lt; '\n';    cout &lt;&lt; setw(10) &lt;&lt; right &lt;&lt; -123 &lt;&lt; '\n';        cout &lt;&lt; setfill(' ');        cout &lt;&lt; fixed &lt;&lt; setw(10) &lt;&lt; setprecision(2) &lt;&lt; 123.5 &lt;&lt; endl;    cout &lt;&lt; scientific &lt;&lt; setw(10) &lt;&lt; setprecision(2) &lt;&lt; 123.5 &lt;&lt; endl;        }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="class-template-模板-介绍"><a href="#class-template-模板-介绍" class="headerlink" title="class template (模板)介绍"></a>class template (模板)介绍</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;class complex{public:complex(T r = 0, T i = 0)        : re(r), im(i)    {}    complex&amp; operator += (const complex&amp;);    T real () const{ return re;}    T imag () const{ return im;}private:    re, im;    friend complex&amp; _doapl(complex*, const complex&amp;);    };{    complex&lt;double&gt; c1(2.5, 1.5);    complex&lt;int&gt; c2(2, 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class complex{public:complex (double r = 0, double i=0)        : re(r), im(i)    {}    complex&amp; operator += {const complex&amp;};    double real () const {return re;}    double imag () const {return im;} }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>constructor(构造函数)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class complex{    public:    complex (double r = 0, double i = 0/*默认参数*/)        : re(r), im(i)//初始列,初值列}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>const member functions</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">classs complex{public:    complex (double r = 0, double i = 0)        : re(r) , im(r)        {}    complex&amp; operator += (const complex&amp;);    double real () const {return re;}    double imag () const {return im;}private:    double re, im;    frie}{    complex c1(2,1);    cout &lt;&lt; c1.real();    cout &lt;&lt; c1.imag();}{    const complex c1(2,1);    cout &lt;&lt; c1.real();    cout &lt;&lt; c1.imag();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造函数可以放在private区</p><p>单例模式singleton</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A{    public:    static A&amp; getInstance();    setup(){ ...}    private:    A();    A(const A&amp; rhs);    };A&amp; A::getInstance(){    static A a;    return a;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>pass by value vs. pass by reference(to const)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class complex{public:    complex (double r = 0, double i = 0)        : re(r), im{i}    {}    complex&amp; operator += {const complex&amp;};    double real () const {return re;}    double imag () const {return im;}private:    double re, im;    friend complex&amp; _doapl (complex*, const complex&amp;);};{    complex c1(2, 1);    complex c2;    c2+= c1;    cout &lt;&lt; c2;}ostream&amp;operator &lt;&lt; (ostream&amp; os, const complex&amp; x){    retunn os &lt;&lt;'()' &lt;&lt; real(x) &lt;&lt;',' &lt;&lt; imag(x) &lt;&lt;')';    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>都尽量引用传递</p><h3 id="友元-P4-25分"><a href="#友元-P4-25分" class="headerlink" title="友元(P4 -25分)"></a>友元(P4 -25分)</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class complex{public:    complex (double r = 0, double i = 0)        : re(r), im{i}    {}    complex&amp; operator += {const complex&amp;};    double real () const {return re;}    double imag () const {return im;}private:    double re, im;    friend complex&amp; _doapl (complex*, const complex&amp;);};inline complex&amp;_doapl (complex* ths, const complex&amp; r){    rhs-&gt;re += r.re;    ths-&gt;im += r.im;    return *ths;}//自由取得friend的private成员<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="相同class的各种objects互为friends-友元"><a href="#相同class的各种objects互为friends-友元" class="headerlink" title="相同class的各种objects互为friends(友元)"></a>相同class的各种objects互为friends(友元)</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class complex{    public:    complex(double r = 0, double i= 0)        : re(r), im(i)        {}    int func(const complex&amp; param)    {        return paraml.re+ param.im;    }    private:    double re, im;};{    complex c1(2, 1);    complex c2;    c2.func(c1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="操作符重载-成员函数版-P5"><a href="#操作符重载-成员函数版-P5" class="headerlink" title="操作符重载-成员函数版(P5)"></a>操作符重载-成员函数版(P5)</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">inline</span> complex<span class="token operator">&amp;</span><span class="token function">_doapl</span><span class="token punctuation">(</span>complex<span class="token operator">*</span> ths<span class="token punctuation">,</span> <span class="token keyword">const</span> complex<span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>    ths<span class="token operator">-&gt;</span>re <span class="token operator">+=</span> r<span class="token punctuation">.</span>re<span class="token punctuation">;</span>    ths<span class="token operator">-&gt;</span>im <span class="token operator">+=</span> r<span class="token punctuation">.</span>im<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span>ths<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">inline</span> complex<span class="token operator">&amp;</span> complex<span class="token operator">::</span>operator <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> complex<span class="token operator">&amp;</span> r<span class="token punctuation">)</span><span class="token comment">//含有隐藏参数this</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">_doapl</span> <span class="token punctuation">(</span>this<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">{</span>    complex <span class="token function">c1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    complex <span class="token function">c2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c2 <span class="token operator">+=</span> c1<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="return-by-reference语法分析"><a href="#return-by-reference语法分析" class="headerlink" title="return  by reference语法分析"></a>return  by reference语法分析</h3><p>传递者无需知道接收者是以reference形式接收</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inline complex&amp;_doapl(complex* ths, const complex&amp; r){    ,,,    return *ths;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="操作符重载-非成员函数"><a href="#操作符重载-非成员函数" class="headerlink" title="操作符重载-非成员函数"></a>操作符重载-非成员函数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">{    complex c1(2, 1);    complex c2;    c2 = c1+ c2;    c2 = c1 + 5;    c2 = 7 + c1;}//为了对付client的三种可能用法,这儿对应开发三个函数, 下面这些函数绝不可return by reference, 因为, 它们返回的必定是个local objectinline complexoperator + (const complex&amp; x, const complex&amp; y){    return complex (real (x) + real(y), imag (x) + imag(y));}inline complexoperator + (const complex&amp; x, double y){    return complex (real(x)+y, imag(x));}inline complexoperator + (double x, const complex&amp; y){    return complex (x + real(y), imag (y));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="临时对象temp-object-typename"><a href="#临时对象temp-object-typename" class="headerlink" title="临时对象temp object      typename()"></a>临时对象temp object      typename()</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inline complexoperator + (const complex&amp; x){    return x;}//这个可以return by referenceinline complexoperator - (const complex&amp; x){    return complex (-real(x), -imag(x));}//这个函数绝不可能return by reference,因为其返回的必定是个local object<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inline booloperator == (const complex&amp; x, const complex&amp; y){    return real(x) == real(y) &amp;&amp; imag(x) == imag(y);}inline booloperator == (const complex&amp; x, double y){    return real(x) == y &amp;&amp; imag(x) == 0;}inline booloperator == (double x, const complex&amp; y){    return x== real(y) &amp;&amp; imag(y) == 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">{    complex c1(2, 1);    cout &lt;&lt; conj(c1);    cout &lt;&lt; c1 &lt;&lt; conj(c1);}inline complex conj(const complex&amp; x){ return complex(real(x), -imag(x));   }#include&lt;iostream.h&gt;ostream&amp;operator &lt;&lt; (ostream&amp; os, const complex&amp; x){    return os &lt;&lt; '(' &lt;&lt; real(x) &lt;&lt;',' &lt;&lt; imag(x) &lt;&lt;')';}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="c-map容器"><a href="#c-map容器" class="headerlink" title="c++map容器"></a>c++map容器</h3><p>底层会将元素自动排序</p><p>#include<map></map></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt; class Key, class T, class Compare = less&lt;Key&gt;, class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt; &gt; class map; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>map&lt;char, int&gt; s</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(map&lt;char, int&gt;::ierator it = s.begin(); it != s.end();it++){    cout &lt;&lt; it-&gt;first &lt;&lt; "---" &lt;&lt;it-&gt;second &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><p>map&lt;char, int&gt; s 创建了一个map ,命名为s</p><h3 id="大小size"><a href="#大小size" class="headerlink" title="大小size()"></a>大小size()</h3><p>size_type size() const;</p><p>cout &lt;&lt; s.size() &lt;&lt; endl;</p><h3 id="插入元素insert"><a href="#插入元素insert" class="headerlink" title="插入元素insert()"></a>插入元素insert()</h3><p> 函数原型: single element</p><p>pair&lt;iterator, bool&gt; insert (const value_type&amp; val);</p><p>template <class p=""> pair&lt;iterator, bool&gt; insert (p&amp;&amp; val);</class></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">s.inert(pair&lt;char, int&gt;('d', 4));//这里的pair表示一对的关系,相当于struct pair{char a; int b}的一对数据,在接下来会详细学pair的用法//或者用下面的这种方法s['d'] = 4; //这与上面的效果是一样的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除元素erase"><a href="#删除元素erase" class="headerlink" title="删除元素erase()"></a>删除元素erase()</h3><p>删除一个元素,或者一段区间的元素,自动缩减空间使用</p><p>函数原型:</p><p>iterator erase (iterator position);</p><p>iterator erase (iterator first, iterator last);</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">s.erase(s.begin());s.erase(s.begin(), s.end());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="清空元素"><a href="#清空元素" class="headerlink" title="清空元素"></a>清空元素</h3><p>s.clear()</p><h3 id="查找元素-find"><a href="#查找元素-find" class="headerlink" title="查找元素 find()"></a>查找元素 find()</h3><p>函数原型: iterator find (const value_type&amp; val) const;</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; s.find('d') -&gt; second &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者实现找到的删除指定元素</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">s.erase(s.find('d'));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="pair类模板"><a href="#pair类模板" class="headerlink" title="pair类模板"></a>pair类模板</h1><p>相关头文件</p><p>#include<utility></utility></p><p>但是笔者亲测在编译器可以不声明这个头文件而直接使用，貌似在C++中，pair被放入了std命名空间中了。</p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>template &lt;class T1, class T2&gt; struct pair;</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">pair&lt;int, int&gt; p;pair&lt;int, int&gt; p(10, 20);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">map&lt;char, int&gt; m;m.insert(pair&lt;char, int&gt;('a', 10));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">pair&lt;int, int&gt; p(10, 20);cout &lt;&lt; p.first &lt;&lt; " " &lt;&lt; p.second&lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>make_pair</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">pair&lt;int int&gt; p;p.first = 10;p.second = 20;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">pair&lt;int, int&gt; p;p = make_pair(10, 20);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="函数返回多值"><a href="#函数返回多值" class="headerlink" title="函数返回多值"></a>函数返回多值</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;utility&gt;using namespace std;pair&lt;string, int&gt; getClass(int id) {    return make_pair("DOTCPP!", id);}int main(int argc, char **argv) {    pair&lt;string, int&gt; a;    a= getClass(10);    cout &lt;&lt; a.first &lt;&lt; " " &lt;&lt; a.second  &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><h3 id="双返回值-pair"><a href="#双返回值-pair" class="headerlink" title="双返回值 pair"></a>双返回值 pair</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">pair&lt;string, int&gt; getClass(int id){    return make_pair("DOTCPP!", id);}int main(int argc, char **argv) {    pair&lt;string, int&gt; a;    a = getClass(10);    cout &lt;&lt; a.first &lt;&lt; " " &lt;&lt; a.second &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="c-加快输入效率"><a href="#c-加快输入效率" class="headerlink" title="c++加快输入效率"></a>c++加快输入效率</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int main(){    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="c-快读"><a href="#c-快读" class="headerlink" title="c++快读"></a>c++快读</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inline int read(){    int X = 0; bool flag = 1; char ch = getchar();    while(ch&lt;'0' || ch&gt;'9') {        if(ch == '-') flag = 0;        ch = getchar;    }    while(ch&gt;='0' &amp;&amp; ch&lt;'9') {        X = (X&lt;&lt;1) + (X&lt;&lt;3) + ch-'0';        ch = getchar();    }    if(flag) return X;    return ~(X-1);}{int tmp = read();    std::cout &lt;&lt; temp &lt;&lt; std::endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>扩展:快速输出</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inline void write(int X){if(X&lt;0) {        X = ~(X-1);        putchar('-');    }    if(X&gt;9) write(X/10);    putchar(X%10 + '0');    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="goto跳转语句"><a href="#goto跳转语句" class="headerlink" title="goto跳转语句"></a>goto跳转语句</h2><p>goto FLAG:</p><p>FLAG:</p><p><strong>不推荐使用</strong></p><h2 id="数组逆置"><a href="#数组逆置" class="headerlink" title="数组逆置"></a>数组逆置</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int arr[10];int beg = 0;int end = sizeof(arr)/sizeof(arr[0]) -1;for(int i=beg, j = end; i&lt;= end/2/*i&lt;j*/; i++, j--){    //n -1 - i;    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int i =1; i &lt;n ;i++ ){//已经排序好的个数    for(int j=0; j&lt;n-i j++){//进行交换的        if(a[j+1] &lt; a[j]){            swap(a[j+1], a[j]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="重复执行n次的简单模板"><a href="#重复执行n次的简单模板" class="headerlink" title="重复执行n次的简单模板"></a>重复执行n次的简单模板</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while(n--) {    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="曼哈顿距离-直走-d-abs-x1-x2-abs-y1-y2"><a href="#曼哈顿距离-直走-d-abs-x1-x2-abs-y1-y2" class="headerlink" title="曼哈顿距离(直走):d = abs(x1-x2)+abs(y1-y2);"></a>曼哈顿距离(直走):d = abs(x1-x2)+abs(y1-y2);</h3><h3 id="切比雪夫距离-直走加斜着走-最短距离-min-abs-x1-x2-abs-y1-y2"><a href="#切比雪夫距离-直走加斜着走-最短距离-min-abs-x1-x2-abs-y1-y2" class="headerlink" title="切比雪夫距离:直走加斜着走: 最短距离: min(abs(x1-x2), abs(y1-y2));"></a>切比雪夫距离:直走加斜着走: 最短距离: min(abs(x1-x2), abs(y1-y2));</h3><h3 id="输入一个n，再输入n个整数。将这个数组顺时针旋转k-k"><a href="#输入一个n，再输入n个整数。将这个数组顺时针旋转k-k" class="headerlink" title="输入一个n，再输入n个整数。将这个数组顺时针旋转k(k <= n)次，最后将结果输出。"></a>输入一个n，再输入n个整数。将这个数组顺时针旋转k(k &lt;= n)次，最后将结果输出。</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//数组一个一个拿,最后循环做这个就行了#include&lt;iostream&gt;using namespace std;int a[100];int main() {    int n, k;    cin &gt;&gt; n &gt;&gt; k;    for(int i= 0; i&lt;n; i++){        cin &gt;&gt; a[i];    }    while(k--){        int t = a[n-1];        for(int i = n-2; i&gt;=0; i--){            a[i+1] = a[i];        }        a[0] = t;    }    for(int i = 0; i&lt;n; i++) cout &lt;&lt; a[i] &lt;&lt; a[i] &lt;&lt; ' ';//循环输出}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h1><p>常量(的)指针:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int* p = &amp;a;//指针指向可以修改,但是指针指向的值不可以改<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指针(的)常量:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int* const p = &amp;a;//指针的指向不可以改,指针指向的值可以改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>即修饰常量又修饰指针:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int* const p = &amp;a;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="结构体赋值"><a href="#结构体赋值" class="headerlink" title="结构体赋值:"></a>结构体赋值:</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Student{    string name;    int age;    int score;    }s3;struct Student S1;struct Student S2 = {"李四", 19, 80};3.定义结构体时创建结构体变量c++中struct创建结构体变量时可以省略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结构体数组:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct student arr[3] = {    {"张三", 18, 80},    {"李四", 19, 60},    {"李四", 19, 60}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针:"></a>结构体指针:</h3><p>student *p = &amp;s;</p><h1 id="char数组难点"><a href="#char数组难点" class="headerlink" title="char数组难点:"></a>char数组难点:</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char a[] = {'C', '+', '+'};char b[4] = {'D', '+', '+', '\0'};char c[5] = {'E', '+', '+', '\0'};// 最后一个位置会补\0cout &lt;&lt; a &lt;&lt; endl;// 输出"C++D++"，因为字符数组a不会自动添加'\0'，cout会读取到b的部分<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="string库函数"><a href="#string库函数" class="headerlink" title="string库函数:"></a>string库函数:</h2><p>string s;</p><p>s.find(‘a’);//从左往右找</p><p>s.rfind(‘a’);//从右往左找</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"># include&lt;string&gt;# include&lt;iostream&gt;using namespace std;int main(){string str = "123456123456123456";cout&lt;&lt;str&lt;&lt;endl&lt;&lt;"0123456789ABCDEFGHJ"&lt;&lt;endl;//方便查看上面字符串的下标 int pos = str.rfind("456",12);cout&lt;&lt;pos&lt;&lt;endl;;return 0;} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二者均返回其在字符串中的下标</p><p>rfind(str, pos)从pos开始,向前查找符合条件的字符串</p><p>如果前面没有符合条件的字符串会返回string::nops</p><p>int pos = string::nops;//此时pos为-1</p><p>运行结果：</p><p>那么问题来了，如果从pos开始，前面没有符合条件的字符串，会返回什么位置呢？</p><pre><code>int pos = str.rfind("456",2);运行结果：</code></pre><p>返回无匹配项，即string::npos</p><p>另外，如果指定的位置，恰好处在原字符串中可以匹配的某一位置时呢？</p><pre><code>int pos = str.rfind("456",3);//位置4,5,6返回值也相同</code></pre><p>运行结果：</p><p>上面的情况是处在第一个可以匹配的子串当中，会返回该子串的位置，但如果是处于第二个可匹配的子串当中，那么又会返回什么呢？</p><pre><code>int pos = str.rfind("456",9);//位置10,11,12返回值也相同</code></pre><h3 id="综上所述可以得出rfind-str-pos-实际的开始的位置是，pos-str-size-，即从该位置开始（不包括该位置字符）向前寻找匹配项-如果有则返回字符串位置，如果没有则返回string-npos。"><a href="#综上所述可以得出rfind-str-pos-实际的开始的位置是，pos-str-size-，即从该位置开始（不包括该位置字符）向前寻找匹配项-如果有则返回字符串位置，如果没有则返回string-npos。" class="headerlink" title="综上所述可以得出rfind(str,pos)实际的开始的位置是，pos+str.size()，即从该位置开始（不包括该位置字符）向前寻找匹配项,如果有则返回字符串位置，如果没有则返回string::npos。"></a>综上所述<em>可以得出rfind(str,pos)实际的开始的位置是，pos+str.size()，即从该位置开始（不包括该位置字符）向前寻找匹配项,如果有则返回字符串位置，如果没有则返回string::npos。</em></h3><p><em><strong>find(str,pos)是用来寻找从pos开始(包括pos处字符)匹配str的位置</strong></em></p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>char s[100];</p><p>cin.getline(s, 100);</p><p>fgets(a, 100, stdin);//会把回车读进来</p><p>如果是string s;</p><p>可以用getline(cin, s);来读一整行</p><p>puts(s);等价于printf(“%s\n”, s);</p><p>#include&lt;string.h&gt;</p><p>strlen(s); //时间复杂度O(n);</p><p>strcmp(s1, s2);//大于就是1, 等于就是0, 小于就是-1;</p><h2 id="string字符串"><a href="#string字符串" class="headerlink" title="string字符串"></a>string字符串</h2><p>string s1;</p><p>string s2 = s1;</p><p>string s3 = “hita”;</p><p>string s4 (10, ‘c’);</p><p>string的输入只能用cin, 但是输出可以使用printf(“%s\n”, s1.c_str());//其中s1.c_str()返回的是转化成字符数组的指针</p><p>s1.empty();//非空返回false, 空返回true</p><p>s1.size();//O(1)</p><p>支持两个string相加</p><p>至少有一个是string型,如果两个都是字符串会报错</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string s1 = "helloworld";for(char/*auto*/ c : s1){cout &lt;&lt; c &lt;&lt; endl;}for(char &amp;c : s1){    //这里可以通过改变c来改变s1中的某一个字符}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>char str[101];</p><p>fgets(str, 101, stdin);</p><p>求某个字符串中的某一段:</p><p>s.substr(i, len);//如果len很长,那么最多到最后一个就截止了</p><p>s.substr(i+1);//从i+1往后所有的</p><h3 id="将一个数组中中多少位数赋值到另一个数组中"><a href="#将一个数组中中多少位数赋值到另一个数组中" class="headerlink" title="将一个数组中中多少位数赋值到另一个数组中"></a>将一个数组中中多少位数赋值到另一个数组中</h3><p>#include<cstring></cstring></p><p>memcpy(b/<em>目标数组</em>/, a ,size*sizeof(a[0]));welll 0</p><h1 id="struct类"><a href="#struct类" class="headerlink" title="struct类"></a>struct类</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Person{    int age, height;    double money;    Person() {            }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2023/09/15/shu-ju-jie-gou/"/>
      <url>/2023/09/15/shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><p>1.存储数据</p><p>2.存储数据表的长度</p><p>3.记录存储容量</p><h2 id="c语言定义结构体来表示顺序表"><a href="#c语言定义结构体来表示顺序表" class="headerlink" title="c语言定义结构体来表示顺序表"></a>c语言定义结构体来表示顺序表</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token punctuation">}</span> Table<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建顺序表"><a href="#创建顺序表" class="headerlink" title="创建顺序表"></a>创建顺序表</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Size</span> <span class="token expression"><span class="token number">5</span> </span><span class="token comment">//宏定义,表示最大存储容量</span></span><span class="token keyword">void</span> <span class="token function">initTable</span><span class="token punctuation">(</span>Table <span class="token operator">*</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//构造空表,动态申请内存空间</span>    t<span class="token operator">-&gt;</span>head <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>Size <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//如申请失败,作出提示并直接退出程序</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>t <span class="token operator">-&gt;</span> head<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"初始化失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//空表长度初始化为0</span>    t<span class="token operator">-&gt;</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//空表初始存储空间</span>    t<span class="token operator">-&gt;</span>size <span class="token operator">=</span> Size<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表使用"><a href="#顺序表使用" class="headerlink" title="顺序表使用"></a>顺序表使用</h2><p>创建顺序表并存储元素{1, 2, 3, 4, 5};</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Size</span> <span class="token expression"><span class="token number">5</span> </span><span class="token comment">// 对Size进行宏定义,表示顺序表的最大容量</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token operator">*</span> head<span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">initTable</span><span class="token punctuation">(</span>Table <span class="token operator">*</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t<span class="token operator">-&gt;</span>head <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>Size <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//如果申请失败,作出提示并直接退出</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>t <span class="token operator">-&gt;</span> head<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"初始化失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">/* 该程序中，exit(0)的作用是什么，为何要有这一句？ 展开Exit() 是电脑函数。函数名: exit()所在头文件：stdlib.h功 能: 关闭所有文件，终止正在执行的进程。exit(1)表示异常退出.这个1是返回给操作系统的。exit(x)（x不为0）都表示异常退出exit(0)表示正常退出exit()的参数会被传递给一些操作系统，包括UNIX,Linux,和MS DOS，以供其他程序使用。stdlib.h: void exit(int status);参 数 : status //程序退出的返回值.*/</span>    <span class="token punctuation">}</span>    t<span class="token operator">-&gt;</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    t<span class="token operator">-&gt;</span>size <span class="token operator">=</span> Size<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//输出顺序表中元素的函数</span><span class="token keyword">void</span> <span class="token function">displayTable</span><span class="token punctuation">(</span>Table t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> t<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    Table t <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>Size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"顺序表中存储的元素分别是: \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">displayTable</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放申请的堆内存</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>数据域|指针域</p><p>c语言用结构体表示链表中的结点,</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">link</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> elem<span class="token punctuation">;</span><span class="token comment">//数据域</span>    <span class="token keyword">struct</span> <span class="token class-name">link</span><span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment">//代表指针域,指向直接后继元素</span><span class="token punctuation">}</span>Link<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>//习惯将结点中的指针命名为next,因此指针域又被称为Next域</p><p>地标指针</p><p>串连指针</p><h3 id="创建一个不含头节点的链表"><a href="#创建一个不含头节点的链表" class="headerlink" title="创建一个不含头节点的链表"></a>创建一个不含头节点的链表</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">Link<span class="token operator">*</span> <span class="token function">initLink</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token comment">//1.创建头指针</span>    Link<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">//2.创建首元结点</span>    Link<span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token punctuation">(</span>Link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    temp<span class="token operator">-&gt;</span>elem <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    temp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token comment">//每创建一个结点,都令其直接前驱结点指向它</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//创建一个结点</span>        Link<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>Link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         a<span class="token operator">-&gt;</span>elem <span class="token operator">=</span> i<span class="token punctuation">;</span>    a<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    temp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> a<span class="token punctuation">;</span>        temp <span class="token operator">=</span> temp <span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建含有头节点的链表"><a href="#创建含有头节点的链表" class="headerlink" title="创建含有头节点的链表"></a>创建含有头节点的链表</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">Link<span class="token operator">*</span> <span class="token function">initLink</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>       <span class="token comment">//创建头指针的同时创建头结点</span>    Link<span class="token operator">*</span> head <span class="token operator">=</span> <span class="token punctuation">(</span>Link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head <span class="token operator">-&gt;</span> elem <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    head <span class="token operator">-&gt;</span> next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">//创建串联指针</span>    Link<span class="token operator">*</span> temp <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Link<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>Link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token operator">-&gt;</span>elem <span class="token operator">=</span> i<span class="token punctuation">;</span>        a<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment">//每次 temp 指向的结点就是a的直接前驱结点</span>        temp <span class="token operator">-&gt;</span> next <span class="token operator">=</span> a<span class="token punctuation">;</span>        temp <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链表-含有头节点-插入元素"><a href="#链表-含有头节点-插入元素" class="headerlink" title="链表(含有头节点)插入元素"></a>链表(含有头节点)插入元素</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">insertElem</span><span class="token punctuation">(</span>Link<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> elem<span class="token punctuation">,</span> <span class="token keyword">int</span> add<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    Link<span class="token operator">*</span> c <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    Link<span class="token operator">*</span> temp <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//创建临时结点temp</span>    <span class="token comment">//首先要找到插入位置的上一个结点</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> add<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        temp <span class="token operator">=</span> temp <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"插入位置无效"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    c <span class="token operator">=</span> <span class="token punctuation">(</span>Link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c <span class="token operator">-&gt;</span> elem <span class="token operator">=</span> elem<span class="token punctuation">;</span>    c<span class="token operator">-&gt;</span>next <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    temp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链表-无头节点-插入元素"><a href="#链表-无头节点-插入元素" class="headerlink" title="链表(无头节点)插入元素"></a>链表(无头节点)插入元素</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">Link<span class="token operator">*</span> <span class="token function">insertElem</span><span class="token punctuation">(</span>Link<span class="token operator">*</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> elem<span class="token punctuation">,</span> <span class="token keyword">int</span> add<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>add <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//创建插入结点c</span>        Link<span class="token operator">*</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>Link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token operator">-&gt;</span>elem <span class="token operator">=</span> elem<span class="token punctuation">;</span>        c<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>        p <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        Link<span class="token operator">*</span> c <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        Link<span class="token operator">*</span> temp <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//创建临时结点temp;</span>        <span class="token comment">//首先找到要插入位置的上一个结点</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> add<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            temp <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"插入位置无效\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> p<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//创建插入结点c</span>        c <span class="token operator">=</span> <span class="token punctuation">(</span>Link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token operator">-&gt;</span>elem <span class="token operator">=</span> elem<span class="token punctuation">;</span>        c<span class="token operator">-&gt;</span>next <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        temp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链表-带头节点-删除元素"><a href="#链表-带头节点-删除元素" class="headerlink" title="链表(带头节点)删除元素"></a>链表(带头节点)删除元素</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//p为原链表,elem为要删除的目标元素</span><span class="token keyword">int</span> <span class="token function">delElem</span><span class="token punctuation">(</span>Link<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Link<span class="token operator">*</span> del <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">*</span>temp <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">int</span> find <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//1,找到目标元素的直接前驱结点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>elem <span class="token operator">==</span> elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>            find <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        temp <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>find <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//删除失败</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token comment">//标记要删除的结点</span>        del <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        temp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>del<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链表-不带头节点-删除元素"><a href="#链表-不带头节点-删除元素" class="headerlink" title="链表(不带头节点)删除元素"></a>链表(不带头节点)删除元素</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//p为原链表,elem为要删除的目标元素</span><span class="token keyword">int</span> <span class="token function">delElem</span><span class="token punctuation">(</span>Link<span class="token operator">*</span><span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Link<span class="token operator">*</span> del <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token operator">*</span>temp <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token comment">//删除首元结点需要单独考虑</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">-&gt;</span>elem <span class="token operator">==</span> elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> find <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//找到目标元素直接前驱结点</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>elem <span class="token operator">==</span> elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>                find <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            temp <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>find<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//删除失败</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment">//标记要删除的结点</span>            del <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            <span class="token comment">//将,目标结点从链表上摘除</span>            temp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            <span class="token function">free</span><span class="token punctuation">(</span>del<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数返回1时, 表示删除成功;返回-1,表示删除失败.注意,该函数的形参p为二级指针,调用时需要传递链表头指针的地址</p><h3 id="链表查找元素"><a href="#链表查找元素" class="headerlink" title="链表查找元素"></a>链表查找元素</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//p为原链表,elem表示被查找元素</span><span class="token keyword">int</span> <span class="token function">selectElem</span><span class="token punctuation">(</span>Link<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span>  <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//带头节点,p指向首元结点</span>    p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>elem <span class="token operator">==</span> elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//返回-1,表示未找到</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不带头节点的链表注释掉第五行</p><h3 id="链表更新元素"><a href="#链表更新元素" class="headerlink" title="链表更新元素"></a>链表更新元素</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//p为有头节点的链表,oldElem为旧元素,newElem为新元素</span><span class="token keyword">int</span> <span class="token function">amendElem</span><span class="token punctuation">(</span>Link<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> oldElem<span class="token punctuation">,</span> <span class="token keyword">int</span> newElem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>elem <span class="token operator">==</span> oldElem<span class="token punctuation">)</span> <span class="token punctuation">{</span>            p<span class="token operator">-&gt;</span>elem <span class="token operator">=</span> newElem<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回1,表示成功;返回-1,表示失败.如果是没有头结点,注释掉第三行</p><h3 id="对有头节点的链表实现增删查改"><a href="#对有头节点的链表实现增删查改" class="headerlink" title="对有头节点的链表实现增删查改"></a>对有头节点的链表实现增删查改</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">incldue</span><span class="token expression"><span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span><span class="token comment">//链表中结点的结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">link</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> elem<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">link</span><span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span>Link<span class="token punctuation">;</span>Link<span class="token operator">*</span> <span class="token function">initLink</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    Link<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    Link<span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token punctuation">(</span>Link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    temp<span class="token operator">-&gt;</span>elem <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    temp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//创建一个结点</span>        Link<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>Link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token operator">-&gt;</span>elem <span class="token operator">=</span> i<span class="token punctuation">;</span>        a<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        temp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> a<span class="token punctuation">;</span>        temp <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">insertElem</span><span class="token punctuation">(</span>Link<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> elem<span class="token punctuation">,</span> <span class="token keyword">int</span> add<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    Link<span class="token operator">*</span> c <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    Link<span class="token operator">*</span> temp <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> add<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        temp <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"插入位置无效\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    c <span class="token operator">=</span> <span class="token punctuation">(</span>Link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c<span class="token operator">-&gt;</span>elem <span class="token operator">=</span> elem<span class="token punctuation">;</span>    c<span class="token operator">-&gt;</span>next <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    temp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">delElem</span><span class="token punctuation">(</span>Link<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Link<span class="token operator">*</span> del <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token operator">*</span>temp <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token keyword">int</span> find <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>elem <span class="token operator">==</span> elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>            find <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        temp <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>find <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        del <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        temp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>del<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">selectElem</span><span class="token punctuation">(</span>Link<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>elem <span class="token operator">=</span> elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">amendElem</span><span class="token punctuation">(</span>Link<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> oldElem<span class="token punctuation">,</span> <span class="token keyword">int</span> newElem<span class="token punctuation">)</span> <span class="token punctuation">{</span>    p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>elem <span class="token operator">==</span> oldElem<span class="token punctuation">)</span> <span class="token punctuation">{</span>            p<span class="token operator">-&gt;</span>elem <span class="token operator">=</span> newElem<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">diaplay</span><span class="token punctuation">(</span>Link<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;d"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">Link_free</span><span class="token punctuation">(</span>Link<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Link<span class="token operator">*</span> fr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        fr <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>fr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Link<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">initLink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"初始化链表为:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">display</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"在第3的位置上添加元素6:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">insertElem</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">display</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"删除元素4:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">delElem</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">display</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"查找元素 2:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"元素2的位置为: %d\n"</span><span class="token punctuation">,</span> <span class="token function">selectElem</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"更元素1的值为6\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">amendElem</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">display</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Link_free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链表反转的四种方法-无头节点实现版"><a href="#链表反转的四种方法-无头节点实现版" class="headerlink" title="链表反转的四种方法(无头节点实现版)"></a>链表反转的四种方法(无头节点实现版)</h3><h4 id="迭代反转法-可有头结点可无"><a href="#迭代反转法-可有头结点可无" class="headerlink" title="迭代反转法(可有头结点可无)"></a>迭代反转法(可有头结点可无)</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//迭代反转法,head为无头节点的头指针</span>link<span class="token operator">*</span> <span class="token function">iteration_reverse</span><span class="token punctuation">(</span>link<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> head<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        link<span class="token operator">*</span> beg <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        link<span class="token operator">*</span> mid <span class="token operator">=</span> head<span class="token punctuation">;</span>        link<span class="token operator">*</span> end <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token comment">//一直遍历</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment">//修改mid所指节点的指向</span>mid<span class="token operator">-&gt;</span>next <span class="token operator">=</span> beg<span class="token punctuation">;</span>            <span class="token comment">//此时判断end是否为NULL, 如果成立则退出循环</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>end <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//整体向后移动3个指针</span>            beg <span class="token operator">=</span> mid<span class="token punctuation">;</span>            mid <span class="token operator">=</span> end<span class="token punctuation">;</span>            end <span class="token operator">=</span> end<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//最后修改head头指针的指向</span>        head <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="递归实现链表反转-可头可不头-但是带头节点麻烦"><a href="#递归实现链表反转-可头可不头-但是带头节点麻烦" class="headerlink" title="递归实现链表反转(可头可不头,但是带头节点麻烦)"></a>递归实现链表反转(可头可不头,但是带头节点麻烦)</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">link<span class="token operator">*</span> <span class="token function">recursive_reverse</span><span class="token punctuation">(</span>link<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//递归的出口</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> head<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//空链表或只有一个结点,直接返回头指针</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token comment">//一直递归,找到链表中最后一个结点</span>        link<span class="token operator">*</span> new_head <span class="token operator">=</span> <span class="token function">recursive_reverse</span><span class="token punctuation">(</span>head<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//当逐层退出时, new_head 的指向都不变,一直指向原链表中最后一个结点</span>        <span class="token comment">//递归每退出一层,函数中head的指向都会发生改变,都指向上一个结点</span>        <span class="token comment">//每退出一层,都需要改变head-&gt;next结点指针域的指向,同时令head所指节点的 指针域为NULL</span>        head<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        head<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token comment">//每一层递归结束都要将新的头指针返回给上一层</span>        <span class="token keyword">return</span> new_head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">link<span class="token operator">*</span> <span class="token function">head_reverse</span><span class="token punctuation">(</span>link<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    link<span class="token operator">*</span> new_head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    link<span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> head<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        temp <span class="token operator">=</span> head<span class="token punctuation">;</span>        head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        temp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> new_head<span class="token punctuation">;</span>        new_head <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> new_head<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="就地逆置"><a href="#就地逆置" class="headerlink" title="就地逆置"></a>就地逆置</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">link<span class="token operator">*</span> <span class="token function">local_reverse</span><span class="token punctuation">(</span>link<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    link<span class="token operator">*</span> beg <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    link<span class="token operator">*</span> end <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">||</span>head<span class="token operator">-&gt;</span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    beg <span class="token operator">=</span> head<span class="token punctuation">;</span>    end <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>beg<span class="token operator">-&gt;</span>next<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        beg<span class="token operator">-&gt;</span>next <span class="token operator">=</span> end<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        end<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        head <span class="token operator">=</span> end<span class="token punctuation">;</span>        end <span class="token operator">=</span> beg<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就地逆置:先把一个反转逻辑粗糙的写出来,然后优化,关键是要想出指针的骚操作</p><h3 id="判断链表相交"><a href="#判断链表相交" class="headerlink" title="判断链表相交"></a>判断链表相交</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Link</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> elem<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Link</span><span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">}</span>link<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>开始判断</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//自定义bool类型</span><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token class-name">bool</span><span class="token punctuation">{</span>    False <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    True <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span>bool<span class="token punctuation">;</span><span class="token comment">//L1和L2为2个单链表, 函数返回True表示链表相交,返回False表示不相交</span>bool <span class="token function">LinkIntersect</span><span class="token punctuation">(</span>link<span class="token operator">*</span> L1<span class="token punctuation">,</span> link<span class="token operator">*</span> L2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    link<span class="token operator">*</span> p1 <span class="token operator">=</span> L1<span class="token punctuation">;</span>    link<span class="token operator">*</span> p2 <span class="token operator">=</span> L2<span class="token punctuation">;</span>    <span class="token comment">//逐个遍历L1链表中的各个节点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">//遍历L2链表,针对每个p1,依次和p2所指节点作比较</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//p1,p2中记录的就是各个节点的存储地址,直接比较即可</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> True<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            p2 <span class="token operator">=</span> p2<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p1 <span class="token operator">=</span> p1<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> False<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优化一"><a href="#优化一" class="headerlink" title="优化一:"></a>优化一:</h4><h5 id="实际上，第-1-种实现方案还可以进一步优化。结合图-1②，2-个单链表相交有一个必然结果，即这-2-个链表-的最后一个节点必定相同；反之，如果-2-个链表不相交，则这-2-个链表的最后一个节点必定不相同。"><a href="#实际上，第-1-种实现方案还可以进一步优化。结合图-1②，2-个单链表相交有一个必然结果，即这-2-个链表-的最后一个节点必定相同；反之，如果-2-个链表不相交，则这-2-个链表的最后一个节点必定不相同。" class="headerlink" title="实际上，第 1 种实现方案还可以进一步优化。结合图 1②，2 个单链表相交有一个必然结果，即这 2 个链表 的最后一个节点必定相同；反之，如果 2 个链表不相交，则这 2 个链表的最后一个节点必定不相同。"></a>实际上，第 1 种实现方案还可以进一步优化。结合图 1②，2 个单链表相交有一个必然结果，即这 2 个链表 的最后一个节点必定相同；反之，如果 2 个链表不相交，则这 2 个链表的最后一个节点必定不相同。</h5><p>利用判断最后一个节点的方法判断相交</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">LinkIntersect</span><span class="token punctuation">(</span>link<span class="token operator">*</span> L1<span class="token punctuation">,</span> link<span class="token operator">*</span> L2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    link<span class="token operator">*</span> p1 <span class="token operator">=</span> L1<span class="token punctuation">;</span>    link<span class="token operator">*</span> p2 <span class="token operator">=</span> L2<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p1<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p1 <span class="token operator">=</span> p1<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p2<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p2 <span class="token operator">=</span> p2<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> True<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> False<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过优化.时间复杂度缩小为O(n)</p><h4 id="优化二"><a href="#优化二" class="headerlink" title="优化二:"></a>优化二:</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">LinkIntersect</span><span class="token punctuation">(</span>link<span class="token operator">*</span> L1<span class="token punctuation">,</span> link<span class="token operator">*</span> L2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    link<span class="token operator">*</span> plong <span class="token operator">=</span> L1<span class="token punctuation">;</span>    link<span class="token operator">*</span> pshort <span class="token operator">=</span> L2<span class="token punctuation">;</span>    link<span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> num2  <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>plong<span class="token punctuation">)</span> <span class="token punctuation">{</span>        num1<span class="token operator">++</span><span class="token punctuation">;</span>        plong <span class="token operator">=</span> plong<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>pshort<span class="token punctuation">)</span> <span class="token punctuation">}</span>        num2<span class="token operator">++</span><span class="token punctuation">;</span>        pshort <span class="token operator">=</span> pshort<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//重置plong和pshort,使plong代表较长的链表,pshort代表较短 的链表</span>plong <span class="token operator">=</span> L1<span class="token punctuation">;</span>pshort <span class="token operator">=</span> L2<span class="token punctuation">;</span>step <span class="token operator">=</span> num1 <span class="token operator">-</span> num2<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>num1 <span class="token operator">&lt;</span> num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>plong <span class="token operator">=</span> L2<span class="token punctuation">;</span>     pshort <span class="token operator">=</span> L1<span class="token punctuation">;</span>        step <span class="token operator">=</span> num2 <span class="token operator">-</span>num1<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//在plong链表中找到和pshort等长度的子链表</span>   temp <span class="token operator">=</span> plong<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>step<span class="token punctuation">)</span> <span class="token punctuation">{</span>        temp <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        step<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>temp <span class="token operator">&amp;&amp;</span> pshort<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>temp <span class="token operator">==</span> pshort<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> True<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        temp <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        pshort <span class="token operator">=</span> pshort<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">return</span> False<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点分析;:</p><p>可以找到2个单链表相交的交点(也就是相交时的第一个交点),也就是使LinkIntersect()函数返回True时的temp指针指向的那个节点.另外,此方案的时间复杂度也为O(n)</p><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p>数据域 游标</p><p>c语言实现节点</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> date<span class="token punctuation">;</span>    <span class="token keyword">int</span> cur<span class="token punctuation">;</span><span class="token punctuation">}</span>component<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>静态链表中,除了数据本身通过游标组成的链表外,还需要有一条连接各个空闲位置的链表,称为备用链表</p><p>备用链表的作用是回收数组中未使用或之前使用过(目前未使用) 的存储空间,留待后期使用.也就是说,静态链表使用数组申请的物理空间中,存有两个链表,一条连接数据,另一条连接数组中未使用的空间</p><p><strong>通常备用链表的表头位于数组下标为0(a[0])的位置,而数据链表的表头位于数组下标为1(a[1])的位置</strong></p><p>静态链表中设置备用链表的好处是,可以清楚的知道数组是否有空闲位置,以便数据链表添加新数据时使用.比如, 若静态链表中数组下标为0的位置上存有数据,则证明数组已满</p><p>例如使用静态链表存储{1,2,3} , 假设使用长度为6的数组a,则存储状态</p><p>备用链表上连接的依次是a[0]. a[2] . a[4].而数据链表上连接的依次是a[1].  a[3] 和a[5]</p><h4 id="创建静态链表c语言实现"><a href="#创建静态链表c语言实现" class="headerlink" title="创建静态链表c语言实现"></a>创建静态链表c语言实现</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">maxSize</span> <span class="token expression"><span class="token number">6</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> date<span class="token punctuation">;</span>    <span class="token keyword">int</span> cur<span class="token punctuation">;</span><span class="token punctuation">}</span>component<span class="token punctuation">;</span><span class="token comment">//将结构体数组中所有分量连接到备用链表中</span><span class="token keyword">void</span> <span class="token function">reserveArr</span><span class="token punctuation">(</span>component<span class="token operator">*</span> arry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//初始化静态链表</span><span class="token keyword">int</span> <span class="token function">initArr</span><span class="token punctuation">(</span>component<span class="token operator">*</span> arry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">displayAr</span><span class="token punctuation">(</span>component<span class="token operator">*</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从备用链表上摘下空闲节点的函数</span><span class="token keyword">int</span> <span class="token function">mallocArr</span><span class="token punctuation">(</span>component<span class="token operator">*</span> array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    component array<span class="token punctuation">[</span>maxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> body <span class="token operator">=</span> <span class="token function">initArr</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"静态链表为:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">displayArr</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//创建备用链表</span><span class="token keyword">void</span> <span class="token function">reserveArr</span><span class="token punctuation">(</span>component<span class="token operator">*</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//将每个数组分量链接到一起</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>date <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    array<span class="token punctuation">[</span>maxSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//链表最后一个结点的游标值为0</span><span class="token punctuation">}</span><span class="token comment">//提取分配空间</span><span class="token keyword">int</span> <span class="token function">mallocArr</span><span class="token punctuation">(</span>component<span class="token operator">*</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//若备用链表非空, 则返回分配的结点下标,否则返回0(当分配到最后一个结点时,该结点的游标值为0)</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>        array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//初始化静态链表</span><span class="token keyword">int</span> <span class="token function">initArr</span><span class="token punctuation">(</span>component<span class="token operator">*</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tempBody <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> body <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">reserveArr</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>    body <span class="token operator">=</span> <span class="token function">mallocArr</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//建立首元结点</span>    array<span class="token punctuation">[</span>body<span class="token punctuation">]</span><span class="token punctuation">.</span>date <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    array<span class="token punctuation">[</span>body<span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//声明一个变量,把它当指针使, 指向链表的最后的一个结点,当前和首元结点重合</span>    tempBody <span class="token operator">=</span> body<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">mallocArr</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从备用链表中拿出空闲的分量</span>        array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">//初始化新得到的 空间结点</span>        array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token operator">=</span> j<span class="token punctuation">;</span><span class="token comment">//将新得到的结点链接到数据链表的尾部</span>        tempBody <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 将指向链表最后一个节点的指针后移</span>    <span class="token punctuation">}</span>    array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//新链表最后一个结点的指针设置为0</span>    <span class="token keyword">return</span> body<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">displayArr</span><span class="token punctuation">(</span>component<span class="token operator">*</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> body<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tempBody <span class="token operator">=</span> body<span class="token punctuation">;</span><span class="token comment">//tempBody准备做遍历使用</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d, %d\n"</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span> array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>        tempBody <span class="token operator">=</span> array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d, %d\n"</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span> array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>链表插入元素</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//body表示链表头节点所在的位置,add表示插入元素的位置,num表示要插入的数据</span><span class="token keyword">int</span> <span class="token function">insertArr</span><span class="token punctuation">(</span>component<span class="token operator">*</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> body<span class="token punctuation">,</span> <span class="token keyword">int</span> add<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tempBody <span class="token operator">=</span> body<span class="token punctuation">;</span><span class="token comment">//tempBody做遍历结构体数组使用</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> insert <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构(c语言) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言头文件</title>
      <link href="/2023/09/12/c-yu-yan-tou-wen-jian/"/>
      <url>/2023/09/12/c-yu-yan-tou-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>  什么情况下用&lt;&gt;, 什么情况下用””</p><p>(1)如果是系统头文件,string.h , stdlib.h等,&lt;&gt;</p><p>(2)如果是独立的第三方模块安装的 &lt;&gt; 比如 mysql.h</p><p>(3)如果是自己项目的头文件, 一定使用””</p><p>为什么不全部用”” , 而还要混合&lt;&gt; 来自寻烦恼呢?</p><p>​1&gt;加快编译器搜索头文件的速度</p><p>​2&gt;方便维护</p><p>可以知道是不是自己做的</p><h3 id="头文件代码模块"><a href="#头文件代码模块" class="headerlink" title="头文件代码模块"></a>头文件代码模块</h3><p>不给外部模块用的函数一定不要写到头文件里面</p><p>头文件一定要写上防止重复包含</p><p>不要在头文件里面定义全局变量,如果有两个模块都包含了这个头文件,那么就会定义两次全局变量,那么会重复定义</p><p>“”三种方式:</p><p>主程序所在文件夹:自己写的</p><p>库函数</p><p>第三方库</p><p>&lt;&gt;两种方式</p>]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言字符与字符串</title>
      <link href="/2023/09/12/c-yu-yan-zi-fu-yu-zi-fu-chuan/"/>
      <url>/2023/09/12/c-yu-yan-zi-fu-yu-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<p> c语言字符串是以’\0’结尾</p><p>‘\0’即0</p><p>字符串内存除了存放数据以外,还要存放结束符,所以内存要+1</p><p>字符串的定义</p><p>(1)常量字符串定义,一旦定义常驻内存,不可修改</p><p>(2)全局的,只读的,不可修改的,分配在代码段上</p><p>有一个char*的指针变量指向这个常量字符串</p><p>指向字符串内存第一个字符的首地址</p><p>在代码段上定义一个常量字符串,并有一个指针变量☞过去</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> str_ptr <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Hello</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>str_ptr<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">//llo</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果有多个地方使用同一个常量字符串那么他们是同一块内存</p><p>验证</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> str_ptr2 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%x  0x%x"</span><span class="token punctuation">,</span> str_ptr <span class="token punctuation">,</span> str_ptr2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>//常量字符串定义在代码段上的,  –&gt;只读的</p><p>str_ptr2[0] =’y’;  //会报错,因为是受保护的内存</p><p>非常量字符串<br>内存,内容<br>hello</p><p>char str_data[5+1]  = {‘H’, ‘e’, ‘l’, ‘l’, ‘o’, ‘\0’};</p><p>char str_data[5+1] = “hello”;</p><p>char str_data3[] = “helloworld”;</p><p>//动态内存分配</p><p>char* str_data4= malloc(10+1);</p><p>char* str = (char * ) malloc(15); 如果不加malloc前面不加(char*)会有影响吗</p><p><a href="https://www.zhihu.com/question/280418752">不加(char*)的影响取决于你使用的编译器和C标准。在C89标准中，malloc返回的是void<em>类型的指针，这种指针可以隐式转换为任何其他类型的指针，所以不需要强制类型转换。但是在C99和C11标准中，malloc返回的还是void</em>类型的指针，但是这种指针不能隐式转换为其他类型的指针，所以需要强制类型转换。如果不加(char*)，可能会导致编译器报警告或错误</a><a href="https://www.zhihu.com/question/280418752">1</a><a href="https://www.zhihu.com/question/399399009">2</a><a href="https://zhidao.baidu.com/question/1673888175226093307.html">3</a>。</p><p><a href="https://blog.csdn.net/SillyGOAT/article/details/121330462">另外，如果你使用的是C++编译器，那么malloc返回的void<em>类型的指针也不能隐式转换为其他类型的指针，所以也需要强制类型转换。如果不加(char</em>)，会导致编译错误</a><a href="https://blog.csdn.net/SillyGOAT/article/details/121330462">4</a>。</p><p>总之，为了保证代码的可移植性和规范性，建议你在malloc前面加上(char*)。</p><h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> str_data4<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>str_data4<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token char">'H'</span><span class="token punctuation">;</span>str_data4<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'e'</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> src <span class="token operator">=</span> <span class="token string">"Helloworld"</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>str_data4<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> str_data4<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//'\0'</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> str_data4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>str_data4<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内存:全局的(常字符串),栈上的,堆上的</p><p>统计字符串字符字数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">my_strlen</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span> walk <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>walk <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        walk<span class="token operator">++</span><span class="token punctuation">;</span>        len<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串copy</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> src_ptr <span class="token operator">=</span> <span class="token string">"helloworld!!"</span><span class="token punctuation">;</span><span class="token keyword">char</span> dst_ptr<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">my_strcpy</span><span class="token punctuation">(</span>dst_ptr<span class="token punctuation">,</span> src_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">my_strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> dst<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> src<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>src <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token operator">*</span>dst <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token punctuation">;</span>        dst<span class="token operator">++</span><span class="token punctuation">;</span>        src<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>dst <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你使用指针访问内存时,内存多大要清楚,否则运行时会报错</p><p>函数my_strcmp(char* str1, char* str2);</p><p>要判断是否会越界之类的</p><p>大写字符二进制值小于小写</p><p>字符串操作函数</p><p>printf(“%s”);%s格式化输出一个字符串,把字符串内容打印出来</p><p>strlen(字符串首地址); 返回字符串的长度(一个字符串包含字符的个数)</p><p>strcpy(目标内存地址, 字符串首地址);</p><p>strcmp(左边字符串对象, 右边字符串对象),判断是否==0 相等</p><p>strncpy(目标字符串地址,已有字符串, 个数n)拷贝指定的字符个数到目标地址,(<strong>记得在目标字符串尾加上0</strong>)</p><p>strncmp:比较特定个数的字符串</p><p>strdup:复制一个字符串对象:内存分配到堆上(内部调用malloc), 不用了,用free释放</p><p>数组名字,sizeof(数组名字)返回的是数组的大小</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>头文件怎么制作</title>
      <link href="/2023/09/10/tou-wen-jian-zen-me-zhi-zuo/"/>
      <url>/2023/09/10/tou-wen-jian-zen-me-zhi-zuo/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_MY_MATH_H_</span><span class="token comment">//防止重复包含</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_MY_MATH_H_</span></span><span class="token comment">//如果这个函数可以公布给给别人使用,那么可以把这个函数接口</span><span class="token comment">//申明到头文件</span><span class="token keyword">int</span> <span class="token function">math_abs</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">math_sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存操作函数_宏_条件编译_代码模块</title>
      <link href="/2023/09/10/nei-cun-cao-zuo-han-shu-hong-tiao-jian-bian-yi-dai-ma-mo-kuai/"/>
      <url>/2023/09/10/nei-cun-cao-zuo-han-shu-hong-tiao-jian-bian-yi-dai-ma-mo-kuai/</url>
      
        <content type="html"><![CDATA[<p>char* ptr = (int*)malloc(100);</p><p>memset(ptr , 0x0 , 100);</p><p>memmove一个一个来的 ,比较安全</p><p>memcopy大段</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++引用</title>
      <link href="/2023/09/08/c-yin-yong/"/>
      <url>/2023/09/08/c-yin-yong/</url>
      
        <content type="html"><![CDATA[<p> 引用和指针的区别.</p><p>指针存储的是一块内存的地址,通过地址,可以访问这块内存<br>引用是一个变量的别名,在创建时必须初始化</p><p>引用在初始化之后不可变,指针可以修改指向的对象</p><pre class="line-numbers language-none"><code class="language-none">int *p = &amp;a;//初始化指针p,指向a的地址int &amp;r = a;//给a取一个别名r,可以说r就是a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>指针写法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void swap(int *a,int *b){int tmp;tmp = *a;*a = *b;*b = tmp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引用写法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void swap(int &amp;a,int &amp;b){int tmp;tmp = a;a = b;b = tmp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static修饰符</title>
      <link href="/2023/09/05/static-xiu-shi-fu/"/>
      <url>/2023/09/05/static-xiu-shi-fu/</url>
      
        <content type="html"><![CDATA[<p> static修饰的全局变量只能在当前.c文件中访问,减少代码维护成本</p><p>static修饰的局部变量只能在声明的函数中使用,不随函数的结束而释放</p>]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码规范与整洁</title>
      <link href="/2023/09/05/dai-ma-gui-fan-yu-zheng-ji/"/>
      <url>/2023/09/05/dai-ma-gui-fan-yu-zheng-ji/</url>
      
        <content type="html"><![CDATA[<p> 注意tab缩进</p><p>注意类似for里面的缩进</p><p>注意每个单独逻辑之间用空行分开</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常见程序英文缩写</title>
      <link href="/2023/09/05/chang-jian-cheng-xu-ying-wen-suo-xie/"/>
      <url>/2023/09/05/chang-jian-cheng-xu-ying-wen-suo-xie/</url>
      
        <content type="html"><![CDATA[<p> i -&gt; index</p><p>pointer -&gt; ptr</p><p>source –&gt; src</p><p>function -&gt; func</p><p>left hand side-&gt;lhs</p><p>right hand side -&gt; rhs</p><p>stand -&gt; std</p><p>memory -&gt;mem</p><p>library -&gt; lib</p><p>input/output -&gt; io</p><p>file stream -&gt; fs</p><p>file open -&gt; fopen</p><p>header -&gt; h</p>]]></content>
      
      
      <categories>
          
          <category> 程序员英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三种命名方法</title>
      <link href="/2023/09/05/san-chong-ming-ming-fang-fa/"/>
      <url>/2023/09/05/san-chong-ming-ming-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>1.linux命名法</p><p>test_func</p><p>2.驼峰命名法</p><p>testFunc</p><p>3.微软匈牙利命名法</p><p>TestFunc</p>]]></content>
      
      
      
        <tags>
            
            <tag> 变量命名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>argc与argv-c语言main函数中参数的意义</title>
      <link href="/2023/09/05/argc-yu-argv-c-yu-yan-main-han-shu-zhong-can-shu-de-yi-yi/"/>
      <url>/2023/09/05/argc-yu-argv-c-yu-yan-main-han-shu-zhong-can-shu-de-yi-yi/</url>
      
        <content type="html"><![CDATA[<p> argc:argument count</p><p>argv: argument value字符串数组</p>]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS头文件不同符号的区别和使用</title>
      <link href="/2023/09/01/vs-tou-wen-jian-bu-tong-fu-hao-de-qu-bie-he-shi-yong/"/>
      <url>/2023/09/01/vs-tou-wen-jian-bu-tong-fu-hao-de-qu-bie-he-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>​包含头文件的方式</p><h4 id="No-1-include"><a href="#No-1-include" class="headerlink" title="No.1 #include<stdio.h>"></a>No.1 #include&lt;stdio.h&gt;</h4><p>//在标准库的目录下查找</p><h4 id="No-2-include”xxx-h”"><a href="#No-2-include”xxx-h”" class="headerlink" title="No.2#include”xxx.h”"></a>No.2#include”xxx.h”</h4><p>//先在标准库目录下找,按照路径的方式查找</p><h4 id="No-3-路径"><a href="#No-3-路径" class="headerlink" title="No.3 路径"></a>No.3 路径</h4><p>//绝对路径:带盘符</p><p>#include”F:/fhead.h”</p><p>//相对路径不带盼复</p><p>#includue “myHead.h”</p><p>#include”xxx\ \mm.h”\一般路径用反斜杠或者 \ \</p><p>#include&lt;xxx.h&gt;</p><p>//无法打开包括文件:”xxx.h”: No such file or directory</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VS </tag>
            
            <tag> 头文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器指令与汇编语言</title>
      <link href="/2023/08/31/ji-qi-zhi-ling-yu-hui-bian-yu-yan/"/>
      <url>/2023/08/31/ji-qi-zhi-ling-yu-hui-bian-yu-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="机器指令与汇编语言"><a href="#机器指令与汇编语言" class="headerlink" title="机器指令与汇编语言"></a>机器指令与汇编语言</h1><h3 id="1-cpu指令体系"><a href="#1-cpu指令体系" class="headerlink" title="1.cpu指令体系:"></a>1.cpu指令体系:</h3><p>cpu有一个指令集的规范,怎样向cpu下达指令</p><p>每种类型cpu都有统一指令集的规范,不同厂家生产的同类型cpu指令基本是兼容的 </p><p>计算机只有二进制数据0,1,所以每条机器指令是由一串二进制组成</p><p>每条指令都有一个二进制模板,这个模板定义在cpu指令集里</p><h3 id="2-机器代码"><a href="#2-机器代码" class="headerlink" title="2.机器代码"></a>2.机器代码</h3><p>完成一个特定功能的,一连串机器指令的集合</p><p>cpu一条一条指令执行这些机器代码,完成特定的功能</p><h3 id="3-程序"><a href="#3-程序" class="headerlink" title="3.程序"></a>3.程序</h3><p>编写指令给cpu,让他完成特定的功能</p><h3 id="4-汇编语言"><a href="#4-汇编语言" class="headerlink" title="4.汇编语言"></a>4.汇编语言</h3><p>指令助记符号,帮助我们记忆和使用指令模板,大大降低程序的编写复杂度和阅读困难</p>]]></content>
      
      
      <categories>
          
          <category> 游戏服务器开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器指令与汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>office软件页面变成灰色</title>
      <link href="/2023/08/31/office-ruan-jian-bian-cheng-hui-se/"/>
      <url>/2023/08/31/office-ruan-jian-bian-cheng-hui-se/</url>
      
        <content type="html"><![CDATA[<p> 进入选项-&gt;常规-&gt;个性化设置</p>]]></content>
      
      
      <categories>
          
          <category> 故障 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>套接字Socket</title>
      <link href="/2023/08/30/tao-jie-zi-socket/"/>
      <url>/2023/08/30/tao-jie-zi-socket/</url>
      
        <content type="html"><![CDATA[<p> <strong>套接字</strong> </p><p>网络连接的每一端都需要存储一些信息，这些信息至少包括：<strong>连 接使用的协议</strong>、<strong>自己的地址</strong>、<strong>对方的地址</strong>、<strong>将要发送的数据</strong>、<strong>接收到 的数据</strong>等。存储和处理这些信息的结构称为<strong>套接字（Socket）</strong>。图1-7 展示了套接字包含的内容，每个Socket都包含网络连接中一端的信 息。每个客户端需要一个Socket结构，服务端则需要<strong>N+1</strong>个Socket结 构，其中N为客户端的连接数，另外一个是服务端打开监听的套接字。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无法创建虚拟机</title>
      <link href="/2023/08/29/wu-fa-chuang-jian-xu-ni-ji/"/>
      <url>/2023/08/29/wu-fa-chuang-jian-xu-ni-ji/</url>
      
        <content type="html"><![CDATA[<p> 无法创建新虚拟机: 不具备执行此操作的权限:</p><p>用管理员方式打开VMware</p>]]></content>
      
      
      <categories>
          
          <category> 故障 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限故障 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不具备执行此操作的权限解决办法</title>
      <link href="/2023/08/29/bu-ju-bei-zhi-xing-ci-cao-zuo-de-quan-xian-jie-jue-ban-fa/"/>
      <url>/2023/08/29/bu-ju-bei-zhi-xing-ci-cao-zuo-de-quan-xian-jie-jue-ban-fa/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何使用VMware搭建linux即CentOS服务器</title>
      <link href="/2023/08/29/ru-he-shi-yong-vmware-da-jian-linux-ji-centos-fu-wu-qi/"/>
      <url>/2023/08/29/ru-he-shi-yong-vmware-da-jian-linux-ji-centos-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<p> [在VMware中安装CentOS7（超详细的图文教程）_vm安装centos7_qq_45743985的博客-CSDN博客](<a href="https://blog.csdn.net/qq_45743985/article/details/121152504#:~:text=%E5%9C%A8VMware%E4%B8%AD%E5%AE%89%E8%A3%85CentOS7%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B%EF%BC%89">https://blog.csdn.net/qq_45743985/article/details/121152504#:~:text=在VMware中安装CentOS7（超详细的图文教程）</a> 1 1、CentOS7的下载 官网下载地址： Download 。 进入CentOS下载官网，找到64位的CentOS7版本。 ,4、CentOS7的网络配置 因为前面在设置CentOS7的网络适配器的时候，设置是NAT模式。 所以这里有两种方法，一种是自动获取IP，另一种是固定获取IP … 5 5、XShell连接CentOS7 我们实际在启动CentOS之后，通常都不会直接在VMware操作CentOS，而是使用工具，推荐使用Xshell。 )</p><p>按下ctrl+c可以终止</p>]]></content>
      
      
      <categories>
          
          <category> 软件环境安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>键盘录入</title>
      <link href="/2023/08/26/jian-pan-lu-ru/"/>
      <url>/2023/08/26/jian-pan-lu-ru/</url>
      
        <content type="html"><![CDATA[<p> 第一套体系:</p><p>​import java.util.scanner</p><p>​Scanner sc = new Scanner(System.in);</p><p>nextInt();接收整数</p><p>nextDouble(); 接收小数</p><p>next(); 接收字符串</p><p>遇到空格, 制表符 , 回车就会停止接受 . 这些数据后面的数据就不会接受了</p><p>第二套体系</p><p>nextInt();接受字符串</p><p>可以接收空格,制表符,遇到回车才会停止接收数据</p><h4 id="两套体系最好不要混用"><a href="#两套体系最好不要混用" class="headerlink" title="两套体系最好不要混用"></a>两套体系最好不要混用</h4>]]></content>
      
      
      <categories>
          
          <category> 初学者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java文字小游戏</title>
      <link href="/2023/08/25/java-wen-zi-xiao-you-xi/"/>
      <url>/2023/08/25/java-wen-zi-xiao-you-xi/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>cugbwfx<span class="token punctuation">.</span>test2</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GameTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Role</span> r1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Role</span><span class="token punctuation">(</span><span class="token string">"哈哈"</span> <span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">,</span> <span class="token char">'男'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Role</span> r2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Role</span><span class="token punctuation">(</span><span class="token string">"嘿嘿"</span> <span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">,</span> <span class="token char">'男'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        r1<span class="token punctuation">.</span><span class="token function">showRoleInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        r2<span class="token punctuation">.</span><span class="token function">showRoleInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            r1<span class="token punctuation">.</span><span class="token function">attack</span><span class="token punctuation">(</span>r2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>r2<span class="token punctuation">.</span><span class="token function">getBlood</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>r1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ko了"</span> <span class="token operator">+</span> r2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            r2<span class="token punctuation">.</span><span class="token function">attack</span><span class="token punctuation">(</span>r1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>r1<span class="token punctuation">.</span><span class="token function">getBlood</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>r2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ko了"</span> <span class="token operator">+</span> r1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span></span><span class="token punctuation">;</span> <span class="token keyword">class</span> <span class="token class-name">Role</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> blood<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">char</span> gender<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> face<span class="token punctuation">;</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> attacks_desc<span class="token operator">=</span><span class="token punctuation">{</span>            <span class="token string">"%s使出了一招【背心钉】，转到对方的身后，一掌向%s背心的灵台穴拍去。"</span><span class="token punctuation">,</span>            <span class="token string">"%s使出了一招【游空探爪】，飞起身形自半空中变掌为抓锁向%s。"</span><span class="token punctuation">,</span>            <span class="token string">"%s大喝一声，身形下伏，一招【劈雷坠地】，捶向%s双腿。"</span><span class="token punctuation">,</span>            <span class="token string">"%s运气于掌，一瞬间掌心变得血红，一式【掌心雷】，推向%s。"</span><span class="token punctuation">,</span>            <span class="token string">"%s阴手翻起阳手跟进，一招【没遮拦】，结结实实的捶向%s。"</span><span class="token punctuation">,</span>            <span class="token string">"%s上步抢身，招中套招，一招【劈挂连环】，连环攻向%s。"</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> injureds_desc<span class="token operator">=</span><span class="token punctuation">{</span>            <span class="token string">"结果%s退了半步，毫发无损"</span><span class="token punctuation">,</span>            <span class="token string">"结果给%s造成一处瘀伤"</span><span class="token punctuation">,</span>            <span class="token string">"结果一击命中，%s痛得弯下腰"</span><span class="token punctuation">,</span>            <span class="token string">"结果%s痛苦地闷哼了一声，显然受了点内伤"</span><span class="token punctuation">,</span>            <span class="token string">"结果%s摇摇晃晃，一跤摔倒在地"</span><span class="token punctuation">,</span>            <span class="token string">"结果%s脸色一下变得惨白，连退了好几步"</span><span class="token punctuation">,</span>            <span class="token string">"结果『轰』的一声，%s口中鲜血狂喷而出"</span><span class="token punctuation">,</span>            <span class="token string">"结果%s一声惨叫，像滩软泥般塌了下去"</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> boyfaces <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"风流俊雅"</span><span class="token punctuation">,</span> <span class="token string">"气宇轩昂"</span><span class="token punctuation">,</span> <span class="token string">"相貌英俊"</span><span class="token punctuation">,</span> <span class="token string">"五官端正"</span><span class="token punctuation">,</span> <span class="token string">"相貌平平"</span><span class="token punctuation">,</span> <span class="token string">"一塌糊涂"</span><span class="token punctuation">,</span> <span class="token string">"面目狰狞"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> girlfaces <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"美奂绝伦"</span><span class="token punctuation">,</span> <span class="token string">"沉鱼落雁"</span><span class="token punctuation">,</span> <span class="token string">"婷婷玉立"</span><span class="token punctuation">,</span> <span class="token string">"身材娇好"</span><span class="token punctuation">,</span> <span class="token string">"相貌平平"</span><span class="token punctuation">,</span> <span class="token string">"相貌简陋"</span><span class="token punctuation">,</span> <span class="token string">"惨不忍睹"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Role</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Role</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> blood<span class="token punctuation">,</span> <span class="token keyword">char</span> gender<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>blood <span class="token operator">=</span> blood<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>        <span class="token function">setFace</span><span class="token punctuation">(</span>gender<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFace</span><span class="token punctuation">(</span><span class="token keyword">char</span> gender<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Random</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>gender <span class="token operator">==</span><span class="token char">'男'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>boyfaces<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>face <span class="token operator">=</span> boyfaces<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>gender <span class="token operator">==</span> <span class="token char">'女'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>girlfaces<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>face <span class="token operator">=</span> girlfaces<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>face <span class="token operator">=</span> <span class="token string">"面目狰狞"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getBlood</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> blood<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBlood</span><span class="token punctuation">(</span><span class="token keyword">int</span> blood<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>blood <span class="token operator">=</span> blood<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//方法的调用者去攻击参数</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attack</span><span class="token punctuation">(</span><span class="token class-name">Role</span> role<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Random</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>attacks_desc<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> <span class="token class-name">Kungfu</span> <span class="token operator">=</span> attacks_desc<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//输出攻击效果</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token class-name">Kungfu</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> role<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//计算伤害</span>        <span class="token keyword">int</span> hurt <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> remainBlood <span class="token operator">=</span> role<span class="token punctuation">.</span><span class="token function">getBlood</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> hurt<span class="token punctuation">;</span>        remainBlood <span class="token operator">=</span> remainBlood <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> remainBlood<span class="token punctuation">;</span>        role<span class="token punctuation">.</span><span class="token function">setBlood</span><span class="token punctuation">(</span>remainBlood<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//受伤描述</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>remainBlood <span class="token operator">&gt;</span> <span class="token number">90</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>injureds_desc<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> role<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>remainBlood <span class="token operator">&gt;</span> <span class="token number">80</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>injureds_desc<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> role<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>remainBlood <span class="token operator">&gt;</span> <span class="token number">70</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>injureds_desc<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> role<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>remainBlood <span class="token operator">&gt;</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>injureds_desc<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> role<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>remainBlood <span class="token operator">&gt;</span> <span class="token number">40</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>injureds_desc<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> role<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>remainBlood <span class="token operator">&gt;</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>injureds_desc<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> role<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>remainBlood <span class="token operator">&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>injureds_desc<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> role<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>remainBlood <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>injureds_desc<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> role<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showRoleInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"姓名: "</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"长相: "</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>face<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"血量: "</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>blood<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"性别: "</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>gender<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非常有意思的文字游戏,很有成就感.</p>]]></content>
      
      
      <categories>
          
          <category> 初学者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 文字游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2023/08/25/ce-shi/"/>
      <url>/2023/08/25/ce-shi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>0823日记</title>
      <link href="/2023/08/23/0823-ri-ji/"/>
      <url>/2023/08/23/0823-ri-ji/</url>
      
        <content type="html"><![CDATA[<p> 好难,一会要java一会c++一会go,我觉得是不是要先入行再想着转岗呢,现在要现有一个主业,然后再想着进阶或者转岗的事情呢?java工资确实低,但是总有工资高的,具体的怎么看呢,其实我自己是一个天生的喜欢偷懒的人,一旦有一个可以玩的借口了那就如同洪水猛兽一样不可控制,等到不想玩了时间又都过去了,空留懊悔,我觉得我应该一边学着黑马的视频,一边学着左程云的算法,一边进行分布式系统的课程进行学习,</p><p>黑马是底线,左程云是进阶,分布式是进进阶</p><p>同时到学校开始上课以后,我需要面对很多的课业,我得好好学以此来应对读研,读一年,然后一定要继续读博,回来拿编制,业余时间足够多之后去搞副业</p><p>我觉得人越是放松越是失去了目标,失去了动力,我也不知道为什么,网络上盛行着的躺平言论似乎并不适合年轻人,你要是说你到了中年身体所有可能性断绝了再去躺平也就是了,为啥要在有可能的时候去躺平呢,这是很难以理解的,他们那样的想法的出现好像是别人给他们的,他们不得不去实现别人给的目标才去躺平,可是那些目标好像就是我想要的啊,一辈子为了房子奋斗,但是要是两个人还款也没有那么不堪啊,自己一个人买小房子不就行了,我以后一定要读博然后当大学教授,这可是为数不多的阶层跃升的好机会,我已经错过了医生,也不想去严格的军工企业,不能再去错过这个了</p><p>​我突然还有一个想法,就是把目前的目标再去细化,细化到每一个可执行的步骤,最主要的就是可执行,执行不了就一直细化,知道细化到可执行不就行了吗</p>]]></content>
      
      
      <categories>
          
          <category> 心得 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机科学导论</title>
      <link href="/2023/08/21/ji-suan-ji-ke-xue-dao-lun/"/>
      <url>/2023/08/21/ji-suan-ji-ke-xue-dao-lun/</url>
      
        <content type="html"><![CDATA[<p>  锁存器</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-08-21 213555.png)</p><p>八进位器</p><p>![](C:\Users\10482\Pictures\Screenshots\屏幕截图 2023-08-21 205510.png)</p><p>cpu</p><p>一个寄存器追踪程序运行到哪了,指令地址寄存器</p><p>一个寄存器用来存当前地址,我们叫它指令地址寄存器</p><p><img src="C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20230821222729540.png" alt="image-20230821222729540"></p>]]></content>
      
      
      <categories>
          
          <category> 英文课 </category>
          
          <category> 计算机科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机科学 </tag>
            
            <tag> 计算机存储设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>局部变量和成员变量区别</title>
      <link href="/2023/08/19/ju-bu-bian-liang-he-cheng-yuan-bian-liang-qu-bie/"/>
      <url>/2023/08/19/ju-bu-bian-liang-he-cheng-yuan-bian-liang-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>​</p><table><thead><tr><th>区别</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>类中位置不同</td><td>类中,方法外</td><td>方法内,方法声明上</td></tr><tr><td>初始化值不同</td><td>有默认初始化值</td><td>没有,使用前需要赋值</td></tr><tr><td>内存位置不同</td><td>堆内存</td><td>栈内存</td></tr><tr><td>生命周期不同</td><td>对象创建而存在,对象消失而消失</td><td>随方法调用而存在,随方法运行结束而消失</td></tr><tr><td>作用域</td><td>整个类中有效</td><td>当前方法有效</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 局部变量 </tag>
            
            <tag> 成员变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javane</title>
      <link href="/2023/08/18/java-nei-cun-fen-pei/"/>
      <url>/2023/08/18/java-nei-cun-fen-pei/</url>
      
        <content type="html"><![CDATA[<p> java内存分配介绍</p><p>栈:类似子弹夹,先进后出(方法,变量等)</p><p>方法运行时使用的内存,如main方法运行,进入方法栈中执行</p><p>堆:存储对象或组,new来创建的,都存储在堆内存</p><p>方法区: 存储可以运行的class文件</p><h4 id="jdk8以后取消方法区-新增元空间-把原来方法区进行拆分-有点进入元空间-有点进入堆"><a href="#jdk8以后取消方法区-新增元空间-把原来方法区进行拆分-有点进入元空间-有点进入堆" class="headerlink" title="(jdk8以后取消方法区,新增元空间,把原来方法区进行拆分,有点进入元空间,有点进入堆)"></a>(jdk8以后取消方法区,新增元空间,把原来方法区进行拆分,有点进入元空间,有点进入堆)</h4><p>本地方法栈:jvm在使用操作系统功能时使用,和开发无关</p><p>寄存器 : 给cpu使用,和开发无关</p><p>javabean类(实例类)</p><p>main类(测试类)</p><p><strong>封装:对象代表什么就得封装对应的数据,并提供数据对应的行为</strong></p><h2 id="一个对象的创建过程"><a href="#一个对象的创建过程" class="headerlink" title="一个对象的创建过程"></a>一个对象的创建过程</h2><p>1.加载class文件</p><p>2.申请局部变量</p><p>3.开辟堆空间</p><p>4.默认初始化</p><p>5.显示初始化</p><p>6.构造方法初始化</p><p>7.将堆内存中的地址值赋值给左边的局部变量</p><h1 id="this作用"><a href="#this作用" class="headerlink" title="this作用"></a>this作用</h1><p>区分局部变量和成员变量</p><p>this本质是方法调用者的地址值</p>]]></content>
      
      
      <categories>
          
          <category> 初学者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标准javabean类</title>
      <link href="/2023/08/18/biao-zhun-javabean-lei/"/>
      <url>/2023/08/18/biao-zhun-javabean-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="标准javabean"><a href="#标准javabean" class="headerlink" title="标准javabean"></a>标准javabean</h1><p>1.类名见名知意</p><p>2.成员变量使用private修饰</p><p>3.至少使用两个构造方法</p><p>​1)无参构造</p><p>​2)带全部参数的构造</p><p>4.成员方法</p><p>​提供每一个成员变量对应的setXxx() / getXxx()</p><p>​如果有其它行为也需要写上</p>]]></content>
      
      
      <categories>
          
          <category> 初学者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaBean </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造方法</title>
      <link href="/2023/08/18/gou-zao-fang-fa/"/>
      <url>/2023/08/18/gou-zao-fang-fa/</url>
      
        <content type="html"><![CDATA[<h4 id="构造方法作用"><a href="#构造方法作用" class="headerlink" title="构造方法作用:"></a>构造方法作用:</h4><p>​创建对象时,虚拟机自动调用,给成员变量进行初始化</p><h4 id="构造方法有几种-各自作用是什么"><a href="#构造方法有几种-各自作用是什么" class="headerlink" title="构造方法有几种?各自作用是什么?"></a>构造方法有几种?各自作用是什么?</h4><p>无参构造: 初始化对象成员变量均采用默认值</p><p>有参构造: 初始化对象时,同时可为对象赋值</p><h4 id="构造方法有哪些注意事项"><a href="#构造方法有哪些注意事项" class="headerlink" title="构造方法有哪些注意事项?"></a>构造方法有哪些注意事项?</h4><p>任何类定义出来默认自带无参数构造器,写不写都有</p><p>一旦定义了有参数构造器,无参构造器就没有了,此时就需要自己写无参数构造器了</p><p>建议在任何时候都写上空参和带全部参数的构造方法</p>]]></content>
      
      
      <categories>
          
          <category> 初学者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 构造方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异或运算</title>
      <link href="/2023/08/15/yi-huo-yun-suan/"/>
      <url>/2023/08/15/yi-huo-yun-suan/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">0^N = NN ^ N = 0交换律结合律<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="用异或的方式交换两个数"><a href="#用异或的方式交换两个数" class="headerlink" title="用异或的方式交换两个数"></a>用异或的方式交换两个数</h1><p>a[i] = a[i] * a[j];</p><p>a[j] = a[i] ^ a[j];</p><p>a[i] = a[i] ^ a[j];</p><h1 id="一组数-其余数有偶数次-只有一个数是有奇数次-的-求出这个数"><a href="#一组数-其余数有偶数次-只有一个数是有奇数次-的-求出这个数" class="headerlink" title="一组数,其余数有偶数次,只有一个数是有奇数次 的,求出这个数"></a>一组数,其余数有偶数次,只有一个数是有奇数次 的,求出这个数</h1><p>异或运算循环</p><h1 id="怎么把一个int类型的数提取出最右侧的1来"><a href="#怎么把一个int类型的数提取出最右侧的1来" class="headerlink" title="怎么把一个int类型的数提取出最右侧的1来"></a>怎么把一个int类型的数提取出最右侧的1来</h1><p>a&amp;((~a)+1)即a&amp;(-a)</p><h1 id="一个数组中有两种数出现了奇数次-其他数出现了偶数次-求出这两种数"><a href="#一个数组中有两种数出现了奇数次-其他数出现了偶数次-求出这两种数" class="headerlink" title="一个数组中有两种数出现了奇数次,其他数出现了偶数次,求出这两种数"></a>一个数组中有两种数出现了奇数次,其他数出现了偶数次,求出这两种数</h1><p>先循环,全部异或一遍,求出最后的数相当于奇数次 的两个数异或运算</p><p>之后得出一个数eor,求这个数eor二进制位上最右边为1的数a(见上问题)</p><p> 用一个数在数组中遍历,如果这个数与a与运算不为0,把数组的这个数与eor’进行异或运算</p><p>一遍遍历之后我们就得到了其中一个奇数</p><p>把这个奇数与eor进行位运算就得到了另一个奇数,很巧妙</p><h1 id="一个数组中有一种数出现k次-其他数都出现了M次-M-1-K"><a href="#一个数组中有一种数出现k次-其他数都出现了M次-M-1-K" class="headerlink" title="一个数组中有一种数出现k次,其他数都出现了M次,M>1,K<M,找到,出现了k次的数,要求:额外空间复杂度O(1),时间复杂度O(N)"></a>一个数组中有一种数出现k次,其他数都出现了M次,M&gt;1,K&lt;M,找到,出现了k次的数,要求:额外空间复杂度O(1),时间复杂度O(N)</h1><p>代码实现?</p>]]></content>
      
      
      <categories>
          
          <category> 初学者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 异或 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java语言自带排序</title>
      <link href="/2023/08/15/java-yu-yan-zi-dai-pai-xu/"/>
      <url>/2023/08/15/java-yu-yan-zi-dai-pai-xu/</url>
      
        <content type="html"><![CDATA[<p>Arrays.sort(int[] a)<br>这种形式是对一个数组的所有元素进行排序，并且是按从小到大的顺序。</p><p>举例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>0 1 2 3 4 5 6 7 8 9</p><p>Arrays.sort(int[] a, int fromIndex, int toIndex)<br>这种形式是 对数组部分排序，也就是对数组a的下标从fromIndex到toIndex-1的元素排序，注意：下标为toIndex的元素不参与排序哦！</p><p>举例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找及对数器的使用</title>
      <link href="/2023/08/14/er-fen-cha-zhao-ji-dui-shu-qi-de-shi-yong/"/>
      <url>/2023/08/14/er-fen-cha-zhao-ji-dui-shu-qi-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找及对数器检验"><a href="#二分查找及对数器检验" class="headerlink" title="二分查找及对数器检验"></a>二分查找及对数器检验</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Search</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">generateRandomArr</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maxValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>maxSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>maxValue <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>maxValue <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这样可以保证数组中的元素有正有负，且不超过maxValue。</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxSize <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> success <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> testTimes <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> testTimes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token function">generateRandomArr</span><span class="token punctuation">(</span>maxSize<span class="token punctuation">,</span> maxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>maxValue <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>maxValue <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">test</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">isExisted</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"出错了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                success <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>success <span class="token operator">?</span> <span class="token string">"Nice"</span> <span class="token operator">:</span> <span class="token string">"Fucking fucked"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> num<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isExisted</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> <span class="token class-name">L</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token class-name">R</span> <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token class-name">L</span> <span class="token operator">&gt;</span> <span class="token class-name">R</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">L</span> <span class="token operator">+</span> <span class="token class-name">R</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> num<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">R</span> <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token class-name">L</span> <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/*这段代码中，maxValue表示数组元素的最大绝对值，也就是说，数组中的元素的范围是-maxValue到maxValue之间。Math.random()方法会返回一个0到1之间的随机小数，所以(maxValue + 1) * Math.random()会返回一个0到maxValue + 1之间的随机小数。如果我们直接把这个小数转换成整数，那么我们得到的整数的范围是0到maxValue之间，而不是0到maxValue + 1之间。这样就会导致数组中的元素不能达到maxValue + 1这个值。为了让数组中的元素能够达到maxValue + 1这个值，我们需要在转换成整数之前，对这个小数加上0.5。这样，当这个小数大于或等于maxValue + 0.5时，转换成整数后就会变成maxValue + 1。然而，如果我们直接在(maxValue + 1) * Math.random()后面加上0.5，那么我们得到的小数的范围就会变成0.5到maxValue + 1.5之间。这样就会导致数组中的元素可能超过maxValue + 1这个值。为了避免这种情况，我们需要在(maxValue + 1) * Math.random()前面加上一个负号，然后再减去一个负号。这样，我们得到的小数的范围就会变成-maxValue - 1.5到-0.5之间。转换成整数后，就会变成-maxValue - 1到0之间。最后，我们再减去另一个(maxValue + 1) * Math.random()转换成整数后的值，就可以得到-maxValue - 1到maxValue + 1之间的随机整数了。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 对数器 初学者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 对数器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序及对数器的使用</title>
      <link href="/2023/08/14/pai-xu-ji-dui-shu-qi-de-shi-yong/"/>
      <url>/2023/08/14/pai-xu-ji-dui-shu-qi-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="选择-冒泡-排序算法"><a href="#选择-冒泡-排序算法" class="headerlink" title="选择,冒泡,排序算法"></a>选择,冒泡,排序算法</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>cugbwfx<span class="token punctuation">.</span>javaMethod</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code_SelectionSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">insertSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printArry</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span>  <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span><span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>end <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span>end<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> newIndex <span class="token operator">=</span> end<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>newIndex<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&gt;=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>newIndex<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>arr<span class="token punctuation">[</span>newIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>newIndex<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>newIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>                newIndex<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token class-name">N</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> end <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> end<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> second <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> second <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> second<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>second <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>second<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> second <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> second<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//先想边界条件</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> minValueIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">/*if(arr[j]&lt;arr[min]){                    min = j;                }*/</span>                minValueIndex <span class="token operator">=</span> arr<span class="token punctuation">[</span>minValueIndex<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">?</span> j <span class="token operator">:</span> minValueIndex<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> minValueIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printArry</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="对数器的使用-以检验排序算法为例"><a href="#对数器的使用-以检验排序算法为例" class="headerlink" title="对数器的使用,以检验排序算法为例"></a>对数器的使用,以检验排序算法为例</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxLength <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token function">randomLenRandomValue</span><span class="token punctuation">(</span>maxLength<span class="token punctuation">,</span> maxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">test</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序算法有误"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 初学者 对数器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单排序 对数器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同类型数据转二进制输出java</title>
      <link href="/2023/08/14/bu-tong-lei-xing-shu-ju-zhuan-er-jin-zhi-shu-chu-java/"/>
      <url>/2023/08/14/bu-tong-lei-xing-shu-ju-zhuan-er-jin-zhi-shu-chu-java/</url>
      
        <content type="html"><![CDATA[<h1 id="不同型数据转二进制输出"><a href="#不同型数据转二进制输出" class="headerlink" title="不同型数据转二进制输出"></a>不同型数据转二进制输出</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code01</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//将一个数以二进制形式输出</span>        <span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num  <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token function">print</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">31</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span>num <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">?</span> <span class="token string">"0"</span> <span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 初学者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制输出 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> java语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法及常数处理小技巧</title>
      <link href="/2023/08/14/er-fen-fa-ji-chang-shu-chu-li-xiao-ji-qiao/"/>
      <url>/2023/08/14/er-fen-fa-ji-chang-shu-chu-li-xiao-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h1 id="常数处理技巧-位运算"><a href="#常数处理技巧-位运算" class="headerlink" title="常数处理技巧(位运算)"></a>常数处理技巧(位运算)</h1><h5 id="R-L-2如果遇到19亿-20亿这样的数-会溢出"><a href="#R-L-2如果遇到19亿-20亿这样的数-会溢出" class="headerlink" title="(R+L)/2如果遇到19亿,20亿这样的数,会溢出"></a>(R+L)/2如果遇到19亿,20亿这样的数,会溢出</h5><p>所以用<strong>L+(R-L)/2</strong> 来防止溢出</p><p>而**(R-L)/2<strong>可以写为</strong>(R-L)&gt;&gt;1** </p><img src="C:\Users\10482\MyBlog\source\_posts\photo\壁纸.jpg" alt="壁纸" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 初学者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
            <tag> 位运算处理(规避边界溢出) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对数器</title>
      <link href="/2023/08/14/dui-shu-qi/"/>
      <url>/2023/08/14/dui-shu-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="生成随机数组"><a href="#生成随机数组" class="headerlink" title="生成随机数组"></a>生成随机数组</h1><h3 id="生成随机长度和随机值两个步骤"><a href="#生成随机长度和随机值两个步骤" class="headerlink" title="生成随机长度和随机值两个步骤"></a>生成随机长度和随机值两个步骤</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">generateRandomArr</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxSize <span class="token punctuation">,</span> <span class="token keyword">int</span> maxValue<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>maxSize<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxValue<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxValue<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="随机数种子-Math-random"><a href="#随机数种子-Math-random" class="headerlink" title="随机数种子: Math.random()"></a>随机数种子: Math.random()</h5>]]></content>
      
      
      <categories>
          
          <category> 初学者 对数器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对数器 检验 随机数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从这个链接里面的博客学来的,保存一下链接防止以后找不着</title>
      <link href="/2023/08/13/cong-zhe-ge-lian-jie-li-mian-de-bo-ke-xue-lai-de-bao-cun-yi-xia-lian-jie-fang-zhi-yi-hou-zhao-bu-zhao/"/>
      <url>/2023/08/13/cong-zhe-ge-lian-jie-li-mian-de-bo-ke-xue-lai-de-bao-cun-yi-xia-lian-jie-fang-zhi-yi-hou-zhao-bu-zhao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_58608526/article/details/124652412?spm=1001.2014.3001.5506">Hexo+Github博客搭建教程_hexo github_Cisyam-Leo的博客-CSDN博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> -&#39;博客搭建&#39; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>newdraft</title>
      <link href="/2023/08/13/newdraft/"/>
      <url>/2023/08/13/newdraft/</url>
      
        <content type="html"><![CDATA[<p> 这是一个草稿测试文章</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2023/08/13/wo-de-di-yi-pian-bo-ke/"/>
      <url>/2023/08/13/wo-de-di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<p>1.2.1 网站<br>参数描述title网站标题subtitle网站副标题description网站描述author您的名字language网站使用的语言timezone网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</p><p>其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。</p><p>1.2.2 网址<br>参数描述url网址root网站根目录 permalink文章的永久链接格式permalink_defaults永久链接中各部分的默认值</p><p>在这里，你需要把url改成你的网站域名。</p><p>permalink，也就是你生成某个文章时的那个链接格式。</p><p>比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是<a href="http://yoursite.com/2022/05/08/temp%E3%80%82">http://yoursite.com/2022/05/08/temp。</a></p><p>以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找 永久链接 。</p><p>参数结果:year/:month/:day/:title/2019/08/10/hello-world :year-:month-:day-:title.html 2019-08-10-hello-world.html :category/:titlefoo/bar/hello-world</p><p>再往下翻，中间这些都默认就好了。</p><p>theme: landscap</p><p>theme就是选择什么主题，也就是在themes这个文件夹下，在官网上有很多个主题，默认给你安装的是lanscape这个主题。当你需要更换主题时，在官网上下载，把主题的文件放在themes文件夹下，再修改这个主题参数就可以了。</p><p>1.2.3 Front-matter<br>Front-matter 是md文件最上方以 —分隔的区域，用于指定个别文件的变量，举例来说：</p><p>title: Hexo+Github博客搭建记录<br>date: 2022-05-08 15:15:44</p><p>下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><p>参数描述layout布局title标题date建立日期updated更新日期comments开启文章的评论功能tags标签（不适用于分页）categories分类（不适用于分页）permalink覆盖文章网址</p><p>其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说Foo，Bar不等于Bar，Foo；而标签没有顺序和层次。</p><pre class="line-numbers language-none"><code class="language-none">---title: Hexo+Github博客搭建记录date: author: img: /medias/banner/7.jpgcoverImg: /medias/banner/7.jpgtop: truecover: truetoc: truepassword: 5f15b28ffe43f8be4f239bdd9b69af9d80dbafcb20a5f0df5d1677a120ae9110mathjax: truesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要tags:- Hexo- Github- 博客categories:- 软件安装与配置---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.2.4 layout（布局）<br>1.2.4.1 post</p><p>当你每一次使用代码</p><p>hexo new XXX</p><p>它其实默认使用的是post这个布局，也就是在source文件夹下的_post里面。</p><p>Hexo有三种默认布局：post、page和draft，它们分别对应不同的路径，而您自定义的其他布局和post相同，都将储存到source/_posts文件夹。</p><p>而new这个命令其实是：</p><p>hexo new [layout] <title>&lt;/p&gt;&lt;p&gt;只不过这个layout默认是post罢了。&lt;/p&gt;&lt;p&gt;2.4.2 page&lt;/p&gt;&lt;p&gt;如果你想另起一页，那么可以使用&lt;/p&gt;&lt;p&gt;hexo new page newpage&lt;/p&gt;&lt;p&gt;系统会自动给你在source文件夹下创建一个newpage文件夹，以及newpage文件夹中的index.md，这样你访问的newpage对应的链接就是&lt;a href="http://xxx.xxx/newpage"&gt;http://xxx.xxx/newpage&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2.4.3 draft&lt;/p&gt;&lt;p&gt;draft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以&lt;/p&gt;&lt;p&gt;hexo new draft newdraft&lt;/p&gt;&lt;p&gt;这样会在source/_draft中新建一个newdraft.md文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用&lt;/p&gt;&lt;p&gt;hexo server –draft&lt;/p&gt;&lt;p&gt;在本地端口中开启服务预览。&lt;/p&gt;&lt;p&gt;如果你的草稿文件写完了，想要发表到post中，&lt;/p&gt;&lt;p&gt;hexo publish draft newdraft&lt;/p&gt;&lt;p&gt;就会自动把newdraft.md发送到post中。&lt;/p&gt;</title></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/08/13/hello-world/"/>
      <url>/2023/08/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
